// This file is auto-generated by @hey-api/openapi-ts

import {
  type DefaultError,
  queryOptions,
  type UseMutationOptions,
} from '@tanstack/react-query';

import { client } from '../client.gen';
import {
  aliasCreate,
  aliasDeleteById,
  aliasListById,
  aliasReadById,
  aliasUpdateById,
  auditingCalculateHash,
  auditingDisableDevice,
  auditingDisableRequestHeader,
  auditingEnableDevice,
  auditingEnableRequestHeader,
  auditingListEnabledDevices,
  auditingListRequestHeaders,
  auditingReadRequestHeaderInformation,
  authDisableMethod,
  authEnableMethod,
  authListEnabledMethods,
  authReadConfiguration,
  authReadTuningInformation,
  authTuneConfigurationParameters,
  collectHostInformation,
  collectInFlightRequestInformation,
  corsConfigure,
  corsDeleteConfiguration,
  corsReadConfiguration,
  cubbyholeDelete,
  cubbyholeRead,
  cubbyholeWrite,
  decode,
  encryptionKeyConfigureRotateKeyringConfig,
  encryptionKeyConfigureRotationConfiguration,
  encryptionKeyReadRotateKeyringConfig,
  encryptionKeyReadRotationConfiguration,
  encryptionKeyRotate,
  encryptionKeyRotateRotateKeyring,
  encryptionKeyStatus,
  entityBatchDelete,
  entityCreate,
  entityCreateAlias,
  entityDeleteAliasById,
  entityDeleteById,
  entityDeleteByName,
  entityListAliasesById,
  entityListById,
  entityListByName,
  entityLookUp,
  entityMerge,
  entityReadAliasById,
  entityReadById,
  entityReadByName,
  entityUpdateAliasById,
  entityUpdateById,
  entityUpdateByName,
  generateHash,
  generateHashWithAlgorithm,
  generateRandom,
  generateRandomWithBytes,
  generateRandomWithSource,
  generateRandomWithSourceAndBytes,
  groupCreate,
  groupCreateAlias,
  groupDeleteAliasById,
  groupDeleteById,
  groupDeleteByName,
  groupListAliasesById,
  groupListById,
  groupListByName,
  groupLookUp,
  groupReadAliasById,
  groupReadById,
  groupReadByName,
  groupUpdateAliasById,
  groupUpdateById,
  groupUpdateByName,
  haStatus,
  initializeSystem,
  internalCountEntities,
  internalCountRequests,
  internalCountTokens,
  internalGenerateOpenApiDocument,
  internalGenerateOpenApiDocumentWithParameters,
  internalInspectRequest,
  internalInspectRouter,
  internalUiListEnabledFeatureFlags,
  internalUiListEnabledVisibleMounts,
  internalUiListNamespaces,
  internalUiReadMountInformation,
  internalUiReadResultantAcl,
  kvDeleteDataPath,
  kvDeleteMetadataPath,
  kvListDetailedMetadataPath,
  kvReadConfig,
  kvReadDataPath,
  kvReadMetadataPath,
  kvReadSubkeysPath,
  kvWriteConfig,
  kvWriteDataPath,
  kvWriteDeletePath,
  kvWriteDestroyPath,
  kvWriteMetadataPath,
  kvWriteUndeletePath,
  leaderStatus,
  leasesCount,
  leasesForceRevokeLeaseWithPrefix,
  leasesForceRevokeLeaseWithPrefix2,
  leasesList,
  leasesLookUp,
  leasesLookUpWithPrefix,
  leasesReadLease,
  leasesRenewLease,
  leasesRenewLease2,
  leasesRenewLeaseWithId,
  leasesRenewLeaseWithId2,
  leasesRevokeLease,
  leasesRevokeLease2,
  leasesRevokeLeaseWithId,
  leasesRevokeLeaseWithId2,
  leasesRevokeLeaseWithPrefix,
  leasesRevokeLeaseWithPrefix2,
  leasesTidy,
  lockedUsersList,
  lockedUsersUnlock,
  loggersReadVerbosityLevel,
  loggersReadVerbosityLevelFor,
  loggersRevertVerbosityLevel,
  loggersRevertVerbosityLevelFor,
  loggersUpdateVerbosityLevel,
  loggersUpdateVerbosityLevelFor,
  metrics,
  mfaAdminDestroyTotpSecret,
  mfaAdminGenerateTotpSecret,
  mfaConfigureDuoMethod,
  mfaConfigureOktaMethod,
  mfaConfigurePingIdMethod,
  mfaConfigureTotpMethod,
  mfaDeleteDuoMethod,
  mfaDeleteLoginEnforcement,
  mfaDeleteOktaMethod,
  mfaDeletePingIdMethod,
  mfaDeleteTotpMethod,
  mfaGenerateTotpSecret,
  mfaListDuoMethods,
  mfaListLoginEnforcements,
  mfaListMethods,
  mfaListOktaMethods,
  mfaListPingIdMethods,
  mfaListTotpMethods,
  mfaReadDuoMethodConfiguration,
  mfaReadLoginEnforcement,
  mfaReadMethodConfiguration,
  mfaReadOktaMethodConfiguration,
  mfaReadPingIdMethodConfiguration,
  mfaReadTotpMethodConfiguration,
  mfaValidate,
  mfaWriteLoginEnforcement,
  monitor,
  mountsDisableSecretsEngine,
  mountsEnableSecretsEngine,
  mountsListSecretsEngines,
  mountsReadConfiguration,
  mountsReadTuningInformation,
  mountsTuneConfigurationParameters,
  namespacesDeleteNamespacesPath,
  namespacesListNamespaces,
  namespacesReadNamespacesPath,
  namespacesWriteNamespacesApiLockLock,
  namespacesWriteNamespacesApiLockLockPath,
  namespacesWriteNamespacesApiLockUnlock,
  namespacesWriteNamespacesApiLockUnlockPath,
  namespacesWriteNamespacesPath,
  type Options,
  oidcConfigure,
  oidcDeleteAssignment,
  oidcDeleteClient,
  oidcDeleteKey,
  oidcDeleteProvider,
  oidcDeleteRole,
  oidcDeleteScope,
  oidcGenerateToken,
  oidcIntrospect,
  oidcListAssignments,
  oidcListClients,
  oidcListKeys,
  oidcListProviders,
  oidcListRoles,
  oidcListScopes,
  oidcProviderAuthorize,
  oidcProviderAuthorizeWithParameters,
  oidcProviderToken,
  oidcProviderUserInfo,
  oidcProviderUserInfo2,
  oidcReadAssignment,
  oidcReadClient,
  oidcReadConfiguration,
  oidcReadKey,
  oidcReadOpenIdConfiguration,
  oidcReadProvider,
  oidcReadProviderOpenIdConfiguration,
  oidcReadProviderPublicKeys,
  oidcReadPublicKeys,
  oidcReadRole,
  oidcReadScope,
  oidcRotateKey,
  oidcWriteAssignment,
  oidcWriteClient,
  oidcWriteKey,
  oidcWriteProvider,
  oidcWriteRole,
  oidcWriteScope,
  personaCreate,
  personaDeleteById,
  personaListById,
  personaReadById,
  personaUpdateById,
  pluginsCatalogListPlugins,
  pluginsCatalogListPluginsWithType,
  pluginsCatalogReadPluginConfiguration,
  pluginsCatalogReadPluginConfigurationWithType,
  pluginsCatalogRegisterPlugin,
  pluginsCatalogRegisterPluginWithType,
  pluginsCatalogRemovePlugin,
  pluginsCatalogRemovePluginWithType,
  pluginsReloadBackends,
  policiesDeleteAclPolicy,
  policiesDeleteAclPolicy2,
  policiesDeletePasswordPolicy,
  policiesGeneratePasswordFromPasswordPolicy,
  policiesList,
  policiesListAclPolicies,
  policiesListPasswordPolicies,
  policiesReadAclPolicy,
  policiesReadAclPolicy2,
  policiesReadPasswordPolicy,
  policiesWriteAclPolicy,
  policiesWriteAclPolicy2,
  policiesWritePasswordPolicy,
  pprofBlocking,
  pprofCommandLine,
  pprofCpuProfile,
  pprofExecutionTrace,
  pprofGoroutines,
  pprofIndex,
  pprofMemoryAllocations,
  pprofMemoryAllocationsLive,
  pprofMutexes,
  pprofSymbols,
  pprofThreadCreations,
  queryTokenAccessorCapabilities,
  queryTokenCapabilities,
  queryTokenSelfCapabilities,
  rateLimitQuotasConfigure,
  rateLimitQuotasDelete,
  rateLimitQuotasList,
  rateLimitQuotasRead,
  rateLimitQuotasReadConfiguration,
  rateLimitQuotasWrite,
  rawDelete,
  rawDeletePath,
  rawRead,
  rawReadPath,
  rawWrite,
  rawWritePath,
  readHealthStatus,
  readInitializationStatus,
  readSanitizedConfigurationState,
  readWrappingProperties,
  readWrappingProperties2,
  rekeyAttemptCancel,
  rekeyAttemptInitialize,
  rekeyAttemptReadProgress,
  rekeyAttemptUpdate,
  rekeyDeleteBackupKey,
  rekeyDeleteBackupRecoveryKey,
  rekeyReadBackupKey,
  rekeyReadBackupRecoveryKey,
  rekeyVerificationCancel,
  rekeyVerificationReadProgress,
  rekeyVerificationUpdate,
  reloadSubsystem,
  remount,
  remountStatus,
  rewrap,
  rootKeyRotate,
  rootTokenGenerationCancel,
  rootTokenGenerationCancel2,
  rootTokenGenerationInitialize,
  rootTokenGenerationInitialize2,
  rootTokenGenerationReadProgress,
  rootTokenGenerationReadProgress2,
  rootTokenGenerationUpdate,
  rotateAttemptCancel,
  rotateAttemptCancelRotateRecoveryInit,
  rotateAttemptInitialize,
  rotateAttemptInitializeRotateRecoveryInit,
  rotateAttemptReadProgress,
  rotateAttemptReadRotateRecoveryInit,
  rotateAttemptUpdate,
  rotateAttemptUpdateRotateRecoveryUpdate,
  rotateDeleteBackupKey,
  rotateDeleteRotateRecoveryBackup,
  rotateReadBackupKey,
  rotateReadRotateRecoveryBackup,
  rotateVerificationCancel,
  rotateVerificationCancelRotateRecoveryVerify,
  rotateVerificationReadProgress,
  rotateVerificationReadRotateRecoveryVerify,
  rotateVerificationUpdate,
  rotateVerificationUpdateRotateRecoveryVerify,
  seal,
  sealStatus,
  stepDownLeader,
  systemListPoliciesDetailedAcl,
  tokenCreate,
  tokenCreateAgainstRole,
  tokenCreateOrphan,
  tokenDeleteRole,
  tokenListAccessors,
  tokenListRoles,
  tokenLookUpByAccessor,
  tokenLookUpGet,
  tokenLookUpPost,
  tokenLookUpSelfGet,
  tokenLookUpSelfPost,
  tokenReadRole,
  tokenRenew,
  tokenRenewAccessor,
  tokenRenewSelf,
  tokenRevoke,
  tokenRevokeAccessor,
  tokenRevokeOrphan,
  tokenRevokeSelf,
  tokenTidy,
  tokenWriteRole,
  uiHeadersConfigure,
  uiHeadersDeleteConfiguration,
  uiHeadersList,
  uiHeadersReadConfiguration,
  unseal,
  unwrap,
  versionHistory,
  wrap,
} from '../sdk.gen';
import type {
  AliasCreateData,
  AliasDeleteByIdData,
  AliasDeleteByIdResponse,
  AliasListByIdData,
  AliasReadByIdData,
  AliasUpdateByIdData,
  AuditingCalculateHashData,
  AuditingCalculateHashResponse2,
  AuditingDisableDeviceData,
  AuditingDisableDeviceResponse,
  AuditingDisableRequestHeaderData,
  AuditingDisableRequestHeaderResponse,
  AuditingEnableDeviceData,
  AuditingEnableDeviceResponse,
  AuditingEnableRequestHeaderData,
  AuditingEnableRequestHeaderResponse,
  AuditingListEnabledDevicesData,
  AuditingListRequestHeadersData,
  AuditingReadRequestHeaderInformationData,
  AuthDisableMethodData,
  AuthDisableMethodResponse,
  AuthEnableMethodData,
  AuthEnableMethodResponse,
  AuthListEnabledMethodsData,
  AuthReadConfigurationData,
  AuthReadTuningInformationData,
  AuthTuneConfigurationParametersData,
  AuthTuneConfigurationParametersResponse,
  CollectHostInformationData,
  CollectInFlightRequestInformationData,
  CorsConfigureData,
  CorsConfigureResponse,
  CorsDeleteConfigurationData,
  CorsDeleteConfigurationResponse,
  CorsReadConfigurationData,
  CubbyholeDeleteData,
  CubbyholeDeleteResponse,
  CubbyholeReadData,
  CubbyholeWriteData,
  DecodeData,
  EncryptionKeyConfigureRotateKeyringConfigData,
  EncryptionKeyConfigureRotateKeyringConfigResponse,
  EncryptionKeyConfigureRotationConfigurationData,
  EncryptionKeyConfigureRotationConfigurationResponse,
  EncryptionKeyReadRotateKeyringConfigData,
  EncryptionKeyReadRotationConfigurationData,
  EncryptionKeyRotateData,
  EncryptionKeyRotateResponse,
  EncryptionKeyRotateRotateKeyringData,
  EncryptionKeyRotateRotateKeyringResponse,
  EncryptionKeyStatusData,
  EntityBatchDeleteData,
  EntityCreateAliasData,
  EntityCreateData,
  EntityDeleteAliasByIdData,
  EntityDeleteAliasByIdResponse,
  EntityDeleteByIdData,
  EntityDeleteByIdResponse,
  EntityDeleteByNameData,
  EntityDeleteByNameResponse,
  EntityListAliasesByIdData,
  EntityListByIdData,
  EntityListByNameData,
  EntityLookUpData,
  EntityMergeData,
  EntityReadAliasByIdData,
  EntityReadByIdData,
  EntityReadByNameData,
  EntityUpdateAliasByIdData,
  EntityUpdateByIdData,
  EntityUpdateByNameData,
  GenerateHashData,
  GenerateHashResponse2,
  GenerateHashWithAlgorithmData,
  GenerateHashWithAlgorithmResponse2,
  GenerateRandomData,
  GenerateRandomResponse2,
  GenerateRandomWithBytesData,
  GenerateRandomWithBytesResponse2,
  GenerateRandomWithSourceAndBytesData,
  GenerateRandomWithSourceAndBytesResponse2,
  GenerateRandomWithSourceData,
  GenerateRandomWithSourceResponse2,
  GroupCreateAliasData,
  GroupCreateData,
  GroupDeleteAliasByIdData,
  GroupDeleteAliasByIdResponse,
  GroupDeleteByIdData,
  GroupDeleteByIdResponse,
  GroupDeleteByNameData,
  GroupDeleteByNameResponse,
  GroupListAliasesByIdData,
  GroupListByIdData,
  GroupListByNameData,
  GroupLookUpData,
  GroupReadAliasByIdData,
  GroupReadByIdData,
  GroupReadByNameData,
  GroupUpdateAliasByIdData,
  GroupUpdateByIdData,
  GroupUpdateByNameData,
  HaStatusData,
  InitializeSystemData,
  InternalCountEntitiesData,
  InternalCountRequestsData,
  InternalCountTokensData,
  InternalGenerateOpenApiDocumentData,
  InternalGenerateOpenApiDocumentWithParametersData,
  InternalInspectRequestData,
  InternalInspectRouterData,
  InternalUiListEnabledFeatureFlagsData,
  InternalUiListEnabledVisibleMountsData,
  InternalUiListNamespacesData,
  InternalUiReadMountInformationData,
  InternalUiReadResultantAclData,
  KvDeleteDataPathData,
  KvDeleteDataPathResponse,
  KvDeleteMetadataPathData,
  KvDeleteMetadataPathResponse,
  KvListDetailedMetadataPathData,
  KvReadConfigData,
  KvReadDataPathData,
  KvReadMetadataPathData,
  KvReadSubkeysPathData,
  KvWriteConfigData,
  KvWriteDataPathData,
  KvWriteDeletePathData,
  KvWriteDestroyPathData,
  KvWriteMetadataPathData,
  KvWriteUndeletePathData,
  LeaderStatusData,
  LeasesCountData,
  LeasesForceRevokeLeaseWithPrefix2Data,
  LeasesForceRevokeLeaseWithPrefix2Response,
  LeasesForceRevokeLeaseWithPrefixData,
  LeasesForceRevokeLeaseWithPrefixResponse,
  LeasesListData,
  LeasesLookUpData,
  LeasesLookUpWithPrefixData,
  LeasesReadLeaseData,
  LeasesReadLeaseResponse2,
  LeasesRenewLease2Data,
  LeasesRenewLease2Response,
  LeasesRenewLeaseData,
  LeasesRenewLeaseResponse,
  LeasesRenewLeaseWithId2Data,
  LeasesRenewLeaseWithId2Response,
  LeasesRenewLeaseWithIdData,
  LeasesRenewLeaseWithIdResponse,
  LeasesRevokeLease2Data,
  LeasesRevokeLease2Response,
  LeasesRevokeLeaseData,
  LeasesRevokeLeaseResponse,
  LeasesRevokeLeaseWithId2Data,
  LeasesRevokeLeaseWithId2Response,
  LeasesRevokeLeaseWithIdData,
  LeasesRevokeLeaseWithIdResponse,
  LeasesRevokeLeaseWithPrefix2Data,
  LeasesRevokeLeaseWithPrefix2Response,
  LeasesRevokeLeaseWithPrefixData,
  LeasesRevokeLeaseWithPrefixResponse,
  LeasesTidyData,
  LeasesTidyResponse,
  LockedUsersListData,
  LockedUsersUnlockData,
  LoggersReadVerbosityLevelData,
  LoggersReadVerbosityLevelForData,
  LoggersRevertVerbosityLevelData,
  LoggersRevertVerbosityLevelForData,
  LoggersRevertVerbosityLevelForResponse,
  LoggersRevertVerbosityLevelResponse,
  LoggersUpdateVerbosityLevelData,
  LoggersUpdateVerbosityLevelForData,
  LoggersUpdateVerbosityLevelForResponse,
  LoggersUpdateVerbosityLevelResponse,
  MetricsData,
  MfaAdminDestroyTotpSecretData,
  MfaAdminGenerateTotpSecretData,
  MfaConfigureDuoMethodData,
  MfaConfigureOktaMethodData,
  MfaConfigurePingIdMethodData,
  MfaConfigureTotpMethodData,
  MfaDeleteDuoMethodData,
  MfaDeleteDuoMethodResponse,
  MfaDeleteLoginEnforcementData,
  MfaDeleteLoginEnforcementResponse,
  MfaDeleteOktaMethodData,
  MfaDeleteOktaMethodResponse,
  MfaDeletePingIdMethodData,
  MfaDeletePingIdMethodResponse,
  MfaDeleteTotpMethodData,
  MfaDeleteTotpMethodResponse,
  MfaGenerateTotpSecretData,
  MfaListDuoMethodsData,
  MfaListLoginEnforcementsData,
  MfaListMethodsData,
  MfaListOktaMethodsData,
  MfaListPingIdMethodsData,
  MfaListTotpMethodsData,
  MfaReadDuoMethodConfigurationData,
  MfaReadLoginEnforcementData,
  MfaReadMethodConfigurationData,
  MfaReadOktaMethodConfigurationData,
  MfaReadPingIdMethodConfigurationData,
  MfaReadTotpMethodConfigurationData,
  MfaValidateData,
  MfaWriteLoginEnforcementData,
  MonitorData,
  MountsDisableSecretsEngineData,
  MountsEnableSecretsEngineData,
  MountsEnableSecretsEngineResponse,
  MountsListSecretsEnginesData,
  MountsReadConfigurationData,
  MountsReadTuningInformationData,
  MountsTuneConfigurationParametersData,
  NamespacesDeleteNamespacesPathData,
  NamespacesDeleteNamespacesPathResponse2,
  NamespacesListNamespacesData,
  NamespacesReadNamespacesPathData,
  NamespacesWriteNamespacesApiLockLockData,
  NamespacesWriteNamespacesApiLockLockPathData,
  NamespacesWriteNamespacesApiLockLockPathResponse2,
  NamespacesWriteNamespacesApiLockLockResponse2,
  NamespacesWriteNamespacesApiLockUnlockData,
  NamespacesWriteNamespacesApiLockUnlockPathData,
  NamespacesWriteNamespacesApiLockUnlockPathResponse,
  NamespacesWriteNamespacesApiLockUnlockResponse,
  NamespacesWriteNamespacesPathData,
  NamespacesWriteNamespacesPathResponse2,
  OidcConfigureData,
  OidcDeleteAssignmentData,
  OidcDeleteAssignmentResponse,
  OidcDeleteClientData,
  OidcDeleteClientResponse,
  OidcDeleteKeyData,
  OidcDeleteKeyResponse,
  OidcDeleteProviderData,
  OidcDeleteProviderResponse,
  OidcDeleteRoleData,
  OidcDeleteRoleResponse,
  OidcDeleteScopeData,
  OidcDeleteScopeResponse,
  OidcGenerateTokenData,
  OidcIntrospectData,
  OidcListAssignmentsData,
  OidcListClientsData,
  OidcListKeysData,
  OidcListProvidersData,
  OidcListRolesData,
  OidcListScopesData,
  OidcProviderAuthorizeData,
  OidcProviderAuthorizeWithParametersData,
  OidcProviderTokenData,
  OidcProviderUserInfo2Data,
  OidcProviderUserInfoData,
  OidcReadAssignmentData,
  OidcReadClientData,
  OidcReadConfigurationData,
  OidcReadKeyData,
  OidcReadOpenIdConfigurationData,
  OidcReadProviderData,
  OidcReadProviderOpenIdConfigurationData,
  OidcReadProviderPublicKeysData,
  OidcReadPublicKeysData,
  OidcReadRoleData,
  OidcReadScopeData,
  OidcRotateKeyData,
  OidcWriteAssignmentData,
  OidcWriteClientData,
  OidcWriteKeyData,
  OidcWriteProviderData,
  OidcWriteRoleData,
  OidcWriteScopeData,
  PersonaCreateData,
  PersonaDeleteByIdData,
  PersonaDeleteByIdResponse,
  PersonaListByIdData,
  PersonaReadByIdData,
  PersonaUpdateByIdData,
  PluginsCatalogListPluginsData,
  PluginsCatalogListPluginsWithTypeData,
  PluginsCatalogReadPluginConfigurationData,
  PluginsCatalogReadPluginConfigurationWithTypeData,
  PluginsCatalogRegisterPluginData,
  PluginsCatalogRegisterPluginWithTypeData,
  PluginsCatalogRemovePluginData,
  PluginsCatalogRemovePluginWithTypeData,
  PluginsReloadBackendsData,
  PluginsReloadBackendsResponse2,
  PoliciesDeleteAclPolicy2Data,
  PoliciesDeleteAclPolicy2Response,
  PoliciesDeleteAclPolicyData,
  PoliciesDeleteAclPolicyResponse,
  PoliciesDeletePasswordPolicyData,
  PoliciesDeletePasswordPolicyResponse,
  PoliciesGeneratePasswordFromPasswordPolicyData,
  PoliciesListAclPoliciesData,
  PoliciesListData,
  PoliciesListPasswordPoliciesData,
  PoliciesReadAclPolicy2Data,
  PoliciesReadAclPolicyData,
  PoliciesReadPasswordPolicyData,
  PoliciesWriteAclPolicy2Data,
  PoliciesWriteAclPolicy2Response,
  PoliciesWriteAclPolicyData,
  PoliciesWriteAclPolicyResponse,
  PoliciesWritePasswordPolicyData,
  PoliciesWritePasswordPolicyResponse,
  PprofBlockingData,
  PprofCommandLineData,
  PprofCpuProfileData,
  PprofExecutionTraceData,
  PprofGoroutinesData,
  PprofIndexData,
  PprofMemoryAllocationsData,
  PprofMemoryAllocationsLiveData,
  PprofMutexesData,
  PprofSymbolsData,
  PprofThreadCreationsData,
  QueryTokenAccessorCapabilitiesData,
  QueryTokenCapabilitiesData,
  QueryTokenSelfCapabilitiesData,
  RateLimitQuotasConfigureData,
  RateLimitQuotasConfigureResponse,
  RateLimitQuotasDeleteData,
  RateLimitQuotasDeleteResponse,
  RateLimitQuotasListData,
  RateLimitQuotasReadConfigurationData,
  RateLimitQuotasReadData,
  RateLimitQuotasWriteData,
  RateLimitQuotasWriteResponse,
  RawDeleteData,
  RawDeletePathData,
  RawDeletePathResponse,
  RawDeleteResponse,
  RawReadData,
  RawReadPathData,
  RawWriteData,
  RawWritePathData,
  ReadHealthStatusData,
  ReadInitializationStatusData,
  ReadSanitizedConfigurationStateData,
  ReadWrappingProperties2Data,
  ReadWrappingPropertiesData,
  ReadWrappingPropertiesResponse2,
  RekeyAttemptCancelData,
  RekeyAttemptInitializeData,
  RekeyAttemptInitializeResponse2,
  RekeyAttemptReadProgressData,
  RekeyAttemptUpdateData,
  RekeyAttemptUpdateResponse2,
  RekeyDeleteBackupKeyData,
  RekeyDeleteBackupKeyResponse,
  RekeyDeleteBackupRecoveryKeyData,
  RekeyDeleteBackupRecoveryKeyResponse,
  RekeyReadBackupKeyData,
  RekeyReadBackupRecoveryKeyData,
  RekeyVerificationCancelData,
  RekeyVerificationCancelResponse2,
  RekeyVerificationReadProgressData,
  RekeyVerificationUpdateData,
  RekeyVerificationUpdateResponse2,
  ReloadSubsystemData,
  ReloadSubsystemResponse,
  RemountData,
  RemountResponse2,
  RemountStatusData,
  RewrapData,
  RootKeyRotateData,
  RootKeyRotateResponse,
  RootTokenGenerationCancel2Data,
  RootTokenGenerationCancel2Response,
  RootTokenGenerationCancelData,
  RootTokenGenerationCancelResponse,
  RootTokenGenerationInitialize2Data,
  RootTokenGenerationInitialize2Response2,
  RootTokenGenerationInitializeData,
  RootTokenGenerationInitializeResponse2,
  RootTokenGenerationReadProgress2Data,
  RootTokenGenerationReadProgressData,
  RootTokenGenerationUpdateData,
  RootTokenGenerationUpdateResponse2,
  RotateAttemptCancelData,
  RotateAttemptCancelResponse,
  RotateAttemptCancelRotateRecoveryInitData,
  RotateAttemptCancelRotateRecoveryInitResponse,
  RotateAttemptInitializeData,
  RotateAttemptInitializeResponse2,
  RotateAttemptInitializeRotateRecoveryInitData,
  RotateAttemptInitializeRotateRecoveryInitResponse2,
  RotateAttemptReadProgressData,
  RotateAttemptReadRotateRecoveryInitData,
  RotateAttemptUpdateData,
  RotateAttemptUpdateResponse2,
  RotateAttemptUpdateRotateRecoveryUpdateData,
  RotateAttemptUpdateRotateRecoveryUpdateResponse2,
  RotateDeleteBackupKeyData,
  RotateDeleteBackupKeyResponse,
  RotateDeleteRotateRecoveryBackupData,
  RotateDeleteRotateRecoveryBackupResponse,
  RotateReadBackupKeyData,
  RotateReadRotateRecoveryBackupData,
  RotateVerificationCancelData,
  RotateVerificationCancelResponse2,
  RotateVerificationCancelRotateRecoveryVerifyData,
  RotateVerificationCancelRotateRecoveryVerifyResponse2,
  RotateVerificationReadProgressData,
  RotateVerificationReadRotateRecoveryVerifyData,
  RotateVerificationUpdateData,
  RotateVerificationUpdateResponse2,
  RotateVerificationUpdateRotateRecoveryVerifyData,
  RotateVerificationUpdateRotateRecoveryVerifyResponse2,
  SealData,
  SealResponse,
  SealStatusData,
  StepDownLeaderData,
  StepDownLeaderResponse,
  SystemListPoliciesDetailedAclData,
  TokenCreateAgainstRoleData,
  TokenCreateData,
  TokenCreateOrphanData,
  TokenDeleteRoleData,
  TokenDeleteRoleResponse,
  TokenListAccessorsData,
  TokenListRolesData,
  TokenLookUpByAccessorData,
  TokenLookUpByAccessorResponse,
  TokenLookUpGetData,
  TokenLookUpPostData,
  TokenLookUpPostResponse,
  TokenLookUpSelfGetData,
  TokenLookUpSelfPostData,
  TokenLookUpSelfPostResponse,
  TokenReadRoleData,
  TokenRenewAccessorData,
  TokenRenewData,
  TokenRenewSelfData,
  TokenRevokeAccessorData,
  TokenRevokeData,
  TokenRevokeOrphanData,
  TokenRevokeSelfData,
  TokenTidyData,
  TokenWriteRoleData,
  UiHeadersConfigureData,
  UiHeadersDeleteConfigurationData,
  UiHeadersDeleteConfigurationResponse,
  UiHeadersListData,
  UiHeadersReadConfigurationData,
  UnsealData,
  UnsealResponse2,
  UnwrapData,
  UnwrapResponse,
  VersionHistoryData,
  WrapData,
} from '../types.gen';

export type QueryKey<TOptions extends Options> = [
  Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
    _id: string;
    _infinite?: boolean;
    tags?: ReadonlyArray<string>;
  },
];

const createQueryKey = <TOptions extends Options>(
  id: string,
  options?: TOptions,
  infinite?: boolean,
  tags?: ReadonlyArray<string>,
): [QueryKey<TOptions>[0]] => {
  const params: QueryKey<TOptions>[0] = {
    _id: id,
    baseUrl:
      options?.baseUrl || (options?.client ?? client).getConfig().baseUrl,
  } as QueryKey<TOptions>[0];
  if (infinite) {
    params._infinite = infinite;
  }
  if (tags) {
    params.tags = tags;
  }
  if (options?.body) {
    params.body = options.body;
  }
  if (options?.headers) {
    params.headers = options.headers;
  }
  if (options?.path) {
    params.path = options.path;
  }
  if (options?.query) {
    params.query = options.query;
  }
  return [params];
};

export const tokenListAccessorsQueryKey = (
  options: Options<TokenListAccessorsData>,
) => createQueryKey('tokenListAccessors', options);

/**
 * List token accessors, which can then be be used to iterate and discover their properties or revoke them. Because this can be used to cause a denial of service, this endpoint requires 'sudo' capability in addition to 'list'.
 */
export const tokenListAccessorsOptions = (
  options: Options<TokenListAccessorsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await tokenListAccessors({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: tokenListAccessorsQueryKey(options),
  });
};

/**
 * The token create path is used to create new tokens.
 */
export const tokenCreateMutation = (
  options?: Partial<Options<TokenCreateData>>,
): UseMutationOptions<unknown, DefaultError, Options<TokenCreateData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<TokenCreateData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await tokenCreate({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * The token create path is used to create new orphan tokens.
 */
export const tokenCreateOrphanMutation = (
  options?: Partial<Options<TokenCreateOrphanData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<TokenCreateOrphanData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<TokenCreateOrphanData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await tokenCreateOrphan({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * This token create path is used to create new tokens adhering to the given role.
 */
export const tokenCreateAgainstRoleMutation = (
  options?: Partial<Options<TokenCreateAgainstRoleData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<TokenCreateAgainstRoleData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<TokenCreateAgainstRoleData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await tokenCreateAgainstRole({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const tokenLookUpGetQueryKey = (options?: Options<TokenLookUpGetData>) =>
  createQueryKey('tokenLookUpGet', options);

/**
 * This endpoint will lookup a token and its properties.
 */
export const tokenLookUpGetOptions = (
  options?: Options<TokenLookUpGetData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await tokenLookUpGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: tokenLookUpGetQueryKey(options),
  });
};

/**
 * This endpoint will lookup a token and its properties.
 */
export const tokenLookUpPostMutation = (
  options?: Partial<Options<TokenLookUpPostData>>,
): UseMutationOptions<
  TokenLookUpPostResponse,
  DefaultError,
  Options<TokenLookUpPostData>
> => {
  const mutationOptions: UseMutationOptions<
    TokenLookUpPostResponse,
    DefaultError,
    Options<TokenLookUpPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await tokenLookUpPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * This endpoint will lookup a token associated with the given accessor and its properties. Response will not contain the token ID.
 */
export const tokenLookUpByAccessorMutation = (
  options?: Partial<Options<TokenLookUpByAccessorData>>,
): UseMutationOptions<
  TokenLookUpByAccessorResponse,
  DefaultError,
  Options<TokenLookUpByAccessorData>
> => {
  const mutationOptions: UseMutationOptions<
    TokenLookUpByAccessorResponse,
    DefaultError,
    Options<TokenLookUpByAccessorData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await tokenLookUpByAccessor({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const tokenLookUpSelfGetQueryKey = (
  options?: Options<TokenLookUpSelfGetData>,
) => createQueryKey('tokenLookUpSelfGet', options);

/**
 * This endpoint will lookup a token and its properties.
 */
export const tokenLookUpSelfGetOptions = (
  options?: Options<TokenLookUpSelfGetData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await tokenLookUpSelfGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: tokenLookUpSelfGetQueryKey(options),
  });
};

/**
 * This endpoint will lookup a token and its properties.
 */
export const tokenLookUpSelfPostMutation = (
  options?: Partial<Options<TokenLookUpSelfPostData>>,
): UseMutationOptions<
  TokenLookUpSelfPostResponse,
  DefaultError,
  Options<TokenLookUpSelfPostData>
> => {
  const mutationOptions: UseMutationOptions<
    TokenLookUpSelfPostResponse,
    DefaultError,
    Options<TokenLookUpSelfPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await tokenLookUpSelfPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * This endpoint will renew the given token and prevent expiration.
 */
export const tokenRenewMutation = (
  options?: Partial<Options<TokenRenewData>>,
): UseMutationOptions<unknown, DefaultError, Options<TokenRenewData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<TokenRenewData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await tokenRenew({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * This endpoint will renew a token associated with the given accessor and its properties. Response will not contain the token ID.
 */
export const tokenRenewAccessorMutation = (
  options?: Partial<Options<TokenRenewAccessorData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<TokenRenewAccessorData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<TokenRenewAccessorData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await tokenRenewAccessor({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * This endpoint will renew the token used to call it and prevent expiration.
 */
export const tokenRenewSelfMutation = (
  options?: Partial<Options<TokenRenewSelfData>>,
): UseMutationOptions<unknown, DefaultError, Options<TokenRenewSelfData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<TokenRenewSelfData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await tokenRenewSelf({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * This endpoint will delete the given token and all of its child tokens.
 */
export const tokenRevokeMutation = (
  options?: Partial<Options<TokenRevokeData>>,
): UseMutationOptions<unknown, DefaultError, Options<TokenRevokeData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<TokenRevokeData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await tokenRevoke({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * This endpoint will delete the token associated with the accessor and all of its child tokens.
 */
export const tokenRevokeAccessorMutation = (
  options?: Partial<Options<TokenRevokeAccessorData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<TokenRevokeAccessorData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<TokenRevokeAccessorData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await tokenRevokeAccessor({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * This endpoint will delete the token and orphan its child tokens.
 */
export const tokenRevokeOrphanMutation = (
  options?: Partial<Options<TokenRevokeOrphanData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<TokenRevokeOrphanData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<TokenRevokeOrphanData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await tokenRevokeOrphan({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * This endpoint will delete the token used to call it and all of its child tokens.
 */
export const tokenRevokeSelfMutation = (
  options?: Partial<Options<TokenRevokeSelfData>>,
): UseMutationOptions<unknown, DefaultError, Options<TokenRevokeSelfData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<TokenRevokeSelfData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await tokenRevokeSelf({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const tokenListRolesQueryKey = (options: Options<TokenListRolesData>) =>
  createQueryKey('tokenListRoles', options);

/**
 * This endpoint lists configured roles.
 */
export const tokenListRolesOptions = (options: Options<TokenListRolesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await tokenListRoles({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: tokenListRolesQueryKey(options),
  });
};

export const tokenDeleteRoleMutation = (
  options?: Partial<Options<TokenDeleteRoleData>>,
): UseMutationOptions<
  TokenDeleteRoleResponse,
  DefaultError,
  Options<TokenDeleteRoleData>
> => {
  const mutationOptions: UseMutationOptions<
    TokenDeleteRoleResponse,
    DefaultError,
    Options<TokenDeleteRoleData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await tokenDeleteRole({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const tokenReadRoleQueryKey = (options: Options<TokenReadRoleData>) =>
  createQueryKey('tokenReadRole', options);

export const tokenReadRoleOptions = (options: Options<TokenReadRoleData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await tokenReadRole({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: tokenReadRoleQueryKey(options),
  });
};

export const tokenWriteRoleMutation = (
  options?: Partial<Options<TokenWriteRoleData>>,
): UseMutationOptions<unknown, DefaultError, Options<TokenWriteRoleData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<TokenWriteRoleData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await tokenWriteRole({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * This endpoint performs cleanup tasks that can be run if certain error conditions have occurred.
 */
export const tokenTidyMutation = (
  options?: Partial<Options<TokenTidyData>>,
): UseMutationOptions<unknown, DefaultError, Options<TokenTidyData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<TokenTidyData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await tokenTidy({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Deletes the secret at the specified location.
 * Pass-through secret storage to a token-specific cubbyhole in the storage backend, allowing you to read/write arbitrary data into secret storage.
 */
export const cubbyholeDeleteMutation = (
  options?: Partial<Options<CubbyholeDeleteData>>,
): UseMutationOptions<
  CubbyholeDeleteResponse,
  DefaultError,
  Options<CubbyholeDeleteData>
> => {
  const mutationOptions: UseMutationOptions<
    CubbyholeDeleteResponse,
    DefaultError,
    Options<CubbyholeDeleteData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await cubbyholeDelete({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const cubbyholeReadQueryKey = (options: Options<CubbyholeReadData>) =>
  createQueryKey('cubbyholeRead', options);

/**
 * Retrieve the secret at the specified location.
 * Pass-through secret storage to a token-specific cubbyhole in the storage backend, allowing you to read/write arbitrary data into secret storage.
 */
export const cubbyholeReadOptions = (options: Options<CubbyholeReadData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await cubbyholeRead({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: cubbyholeReadQueryKey(options),
  });
};

/**
 * Store a secret at the specified location.
 * Pass-through secret storage to a token-specific cubbyhole in the storage backend, allowing you to read/write arbitrary data into secret storage.
 */
export const cubbyholeWriteMutation = (
  options?: Partial<Options<CubbyholeWriteData>>,
): UseMutationOptions<unknown, DefaultError, Options<CubbyholeWriteData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<CubbyholeWriteData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await cubbyholeWrite({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Create a new alias.
 */
export const aliasCreateMutation = (
  options?: Partial<Options<AliasCreateData>>,
): UseMutationOptions<unknown, DefaultError, Options<AliasCreateData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<AliasCreateData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await aliasCreate({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const aliasListByIdQueryKey = (options: Options<AliasListByIdData>) =>
  createQueryKey('aliasListById', options);

/**
 * List all the alias IDs.
 */
export const aliasListByIdOptions = (options: Options<AliasListByIdData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await aliasListById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: aliasListByIdQueryKey(options),
  });
};

/**
 * Update, read or delete an alias ID.
 */
export const aliasDeleteByIdMutation = (
  options?: Partial<Options<AliasDeleteByIdData>>,
): UseMutationOptions<
  AliasDeleteByIdResponse,
  DefaultError,
  Options<AliasDeleteByIdData>
> => {
  const mutationOptions: UseMutationOptions<
    AliasDeleteByIdResponse,
    DefaultError,
    Options<AliasDeleteByIdData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await aliasDeleteById({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const aliasReadByIdQueryKey = (options: Options<AliasReadByIdData>) =>
  createQueryKey('aliasReadById', options);

/**
 * Update, read or delete an alias ID.
 */
export const aliasReadByIdOptions = (options: Options<AliasReadByIdData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await aliasReadById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: aliasReadByIdQueryKey(options),
  });
};

/**
 * Update, read or delete an alias ID.
 */
export const aliasUpdateByIdMutation = (
  options?: Partial<Options<AliasUpdateByIdData>>,
): UseMutationOptions<unknown, DefaultError, Options<AliasUpdateByIdData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<AliasUpdateByIdData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await aliasUpdateById({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Create a new entity
 */
export const entityCreateMutation = (
  options?: Partial<Options<EntityCreateData>>,
): UseMutationOptions<unknown, DefaultError, Options<EntityCreateData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<EntityCreateData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await entityCreate({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Create a new alias.
 */
export const entityCreateAliasMutation = (
  options?: Partial<Options<EntityCreateAliasData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<EntityCreateAliasData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<EntityCreateAliasData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await entityCreateAlias({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const entityListAliasesByIdQueryKey = (
  options: Options<EntityListAliasesByIdData>,
) => createQueryKey('entityListAliasesById', options);

/**
 * List all the alias IDs.
 */
export const entityListAliasesByIdOptions = (
  options: Options<EntityListAliasesByIdData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await entityListAliasesById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: entityListAliasesByIdQueryKey(options),
  });
};

/**
 * Update, read or delete an alias ID.
 */
export const entityDeleteAliasByIdMutation = (
  options?: Partial<Options<EntityDeleteAliasByIdData>>,
): UseMutationOptions<
  EntityDeleteAliasByIdResponse,
  DefaultError,
  Options<EntityDeleteAliasByIdData>
> => {
  const mutationOptions: UseMutationOptions<
    EntityDeleteAliasByIdResponse,
    DefaultError,
    Options<EntityDeleteAliasByIdData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await entityDeleteAliasById({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const entityReadAliasByIdQueryKey = (
  options: Options<EntityReadAliasByIdData>,
) => createQueryKey('entityReadAliasById', options);

/**
 * Update, read or delete an alias ID.
 */
export const entityReadAliasByIdOptions = (
  options: Options<EntityReadAliasByIdData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await entityReadAliasById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: entityReadAliasByIdQueryKey(options),
  });
};

/**
 * Update, read or delete an alias ID.
 */
export const entityUpdateAliasByIdMutation = (
  options?: Partial<Options<EntityUpdateAliasByIdData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<EntityUpdateAliasByIdData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<EntityUpdateAliasByIdData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await entityUpdateAliasById({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete all of the entities provided
 */
export const entityBatchDeleteMutation = (
  options?: Partial<Options<EntityBatchDeleteData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<EntityBatchDeleteData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<EntityBatchDeleteData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await entityBatchDelete({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const entityListByIdQueryKey = (options: Options<EntityListByIdData>) =>
  createQueryKey('entityListById', options);

/**
 * List all the entity IDs
 */
export const entityListByIdOptions = (options: Options<EntityListByIdData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await entityListById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: entityListByIdQueryKey(options),
  });
};

/**
 * Update, read or delete an entity using entity ID
 */
export const entityDeleteByIdMutation = (
  options?: Partial<Options<EntityDeleteByIdData>>,
): UseMutationOptions<
  EntityDeleteByIdResponse,
  DefaultError,
  Options<EntityDeleteByIdData>
> => {
  const mutationOptions: UseMutationOptions<
    EntityDeleteByIdResponse,
    DefaultError,
    Options<EntityDeleteByIdData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await entityDeleteById({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const entityReadByIdQueryKey = (options: Options<EntityReadByIdData>) =>
  createQueryKey('entityReadById', options);

/**
 * Update, read or delete an entity using entity ID
 */
export const entityReadByIdOptions = (options: Options<EntityReadByIdData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await entityReadById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: entityReadByIdQueryKey(options),
  });
};

/**
 * Update, read or delete an entity using entity ID
 */
export const entityUpdateByIdMutation = (
  options?: Partial<Options<EntityUpdateByIdData>>,
): UseMutationOptions<unknown, DefaultError, Options<EntityUpdateByIdData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<EntityUpdateByIdData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await entityUpdateById({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Merge two or more entities together
 */
export const entityMergeMutation = (
  options?: Partial<Options<EntityMergeData>>,
): UseMutationOptions<unknown, DefaultError, Options<EntityMergeData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<EntityMergeData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await entityMerge({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const entityListByNameQueryKey = (
  options: Options<EntityListByNameData>,
) => createQueryKey('entityListByName', options);

/**
 * List all the entity names
 */
export const entityListByNameOptions = (
  options: Options<EntityListByNameData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await entityListByName({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: entityListByNameQueryKey(options),
  });
};

/**
 * Update, read or delete an entity using entity name
 */
export const entityDeleteByNameMutation = (
  options?: Partial<Options<EntityDeleteByNameData>>,
): UseMutationOptions<
  EntityDeleteByNameResponse,
  DefaultError,
  Options<EntityDeleteByNameData>
> => {
  const mutationOptions: UseMutationOptions<
    EntityDeleteByNameResponse,
    DefaultError,
    Options<EntityDeleteByNameData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await entityDeleteByName({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const entityReadByNameQueryKey = (
  options: Options<EntityReadByNameData>,
) => createQueryKey('entityReadByName', options);

/**
 * Update, read or delete an entity using entity name
 */
export const entityReadByNameOptions = (
  options: Options<EntityReadByNameData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await entityReadByName({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: entityReadByNameQueryKey(options),
  });
};

/**
 * Update, read or delete an entity using entity name
 */
export const entityUpdateByNameMutation = (
  options?: Partial<Options<EntityUpdateByNameData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<EntityUpdateByNameData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<EntityUpdateByNameData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await entityUpdateByName({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Create a new group.
 */
export const groupCreateMutation = (
  options?: Partial<Options<GroupCreateData>>,
): UseMutationOptions<unknown, DefaultError, Options<GroupCreateData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<GroupCreateData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await groupCreate({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Creates a new group alias, or updates an existing one.
 */
export const groupCreateAliasMutation = (
  options?: Partial<Options<GroupCreateAliasData>>,
): UseMutationOptions<unknown, DefaultError, Options<GroupCreateAliasData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<GroupCreateAliasData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await groupCreateAlias({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const groupListAliasesByIdQueryKey = (
  options: Options<GroupListAliasesByIdData>,
) => createQueryKey('groupListAliasesById', options);

/**
 * List all the group alias IDs.
 */
export const groupListAliasesByIdOptions = (
  options: Options<GroupListAliasesByIdData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await groupListAliasesById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: groupListAliasesByIdQueryKey(options),
  });
};

export const groupDeleteAliasByIdMutation = (
  options?: Partial<Options<GroupDeleteAliasByIdData>>,
): UseMutationOptions<
  GroupDeleteAliasByIdResponse,
  DefaultError,
  Options<GroupDeleteAliasByIdData>
> => {
  const mutationOptions: UseMutationOptions<
    GroupDeleteAliasByIdResponse,
    DefaultError,
    Options<GroupDeleteAliasByIdData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await groupDeleteAliasById({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const groupReadAliasByIdQueryKey = (
  options: Options<GroupReadAliasByIdData>,
) => createQueryKey('groupReadAliasById', options);

export const groupReadAliasByIdOptions = (
  options: Options<GroupReadAliasByIdData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await groupReadAliasById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: groupReadAliasByIdQueryKey(options),
  });
};

export const groupUpdateAliasByIdMutation = (
  options?: Partial<Options<GroupUpdateAliasByIdData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<GroupUpdateAliasByIdData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<GroupUpdateAliasByIdData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await groupUpdateAliasById({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const groupListByIdQueryKey = (options: Options<GroupListByIdData>) =>
  createQueryKey('groupListById', options);

/**
 * List all the group IDs.
 */
export const groupListByIdOptions = (options: Options<GroupListByIdData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await groupListById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: groupListByIdQueryKey(options),
  });
};

/**
 * Update or delete an existing group using its ID.
 */
export const groupDeleteByIdMutation = (
  options?: Partial<Options<GroupDeleteByIdData>>,
): UseMutationOptions<
  GroupDeleteByIdResponse,
  DefaultError,
  Options<GroupDeleteByIdData>
> => {
  const mutationOptions: UseMutationOptions<
    GroupDeleteByIdResponse,
    DefaultError,
    Options<GroupDeleteByIdData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await groupDeleteById({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const groupReadByIdQueryKey = (options: Options<GroupReadByIdData>) =>
  createQueryKey('groupReadById', options);

/**
 * Update or delete an existing group using its ID.
 */
export const groupReadByIdOptions = (options: Options<GroupReadByIdData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await groupReadById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: groupReadByIdQueryKey(options),
  });
};

/**
 * Update or delete an existing group using its ID.
 */
export const groupUpdateByIdMutation = (
  options?: Partial<Options<GroupUpdateByIdData>>,
): UseMutationOptions<unknown, DefaultError, Options<GroupUpdateByIdData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<GroupUpdateByIdData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await groupUpdateById({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const groupListByNameQueryKey = (
  options: Options<GroupListByNameData>,
) => createQueryKey('groupListByName', options);

export const groupListByNameOptions = (
  options: Options<GroupListByNameData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await groupListByName({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: groupListByNameQueryKey(options),
  });
};

export const groupDeleteByNameMutation = (
  options?: Partial<Options<GroupDeleteByNameData>>,
): UseMutationOptions<
  GroupDeleteByNameResponse,
  DefaultError,
  Options<GroupDeleteByNameData>
> => {
  const mutationOptions: UseMutationOptions<
    GroupDeleteByNameResponse,
    DefaultError,
    Options<GroupDeleteByNameData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await groupDeleteByName({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const groupReadByNameQueryKey = (
  options: Options<GroupReadByNameData>,
) => createQueryKey('groupReadByName', options);

export const groupReadByNameOptions = (
  options: Options<GroupReadByNameData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await groupReadByName({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: groupReadByNameQueryKey(options),
  });
};

export const groupUpdateByNameMutation = (
  options?: Partial<Options<GroupUpdateByNameData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<GroupUpdateByNameData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<GroupUpdateByNameData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await groupUpdateByName({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Query entities based on various properties.
 */
export const entityLookUpMutation = (
  options?: Partial<Options<EntityLookUpData>>,
): UseMutationOptions<unknown, DefaultError, Options<EntityLookUpData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<EntityLookUpData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await entityLookUp({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Query groups based on various properties.
 */
export const groupLookUpMutation = (
  options?: Partial<Options<GroupLookUpData>>,
): UseMutationOptions<unknown, DefaultError, Options<GroupLookUpData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<GroupLookUpData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await groupLookUp({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const mfaListLoginEnforcementsQueryKey = (
  options: Options<MfaListLoginEnforcementsData>,
) => createQueryKey('mfaListLoginEnforcements', options);

/**
 * List login enforcements
 */
export const mfaListLoginEnforcementsOptions = (
  options: Options<MfaListLoginEnforcementsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await mfaListLoginEnforcements({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: mfaListLoginEnforcementsQueryKey(options),
  });
};

/**
 * Delete a login enforcement
 */
export const mfaDeleteLoginEnforcementMutation = (
  options?: Partial<Options<MfaDeleteLoginEnforcementData>>,
): UseMutationOptions<
  MfaDeleteLoginEnforcementResponse,
  DefaultError,
  Options<MfaDeleteLoginEnforcementData>
> => {
  const mutationOptions: UseMutationOptions<
    MfaDeleteLoginEnforcementResponse,
    DefaultError,
    Options<MfaDeleteLoginEnforcementData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await mfaDeleteLoginEnforcement({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const mfaReadLoginEnforcementQueryKey = (
  options: Options<MfaReadLoginEnforcementData>,
) => createQueryKey('mfaReadLoginEnforcement', options);

/**
 * Read the current login enforcement
 */
export const mfaReadLoginEnforcementOptions = (
  options: Options<MfaReadLoginEnforcementData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await mfaReadLoginEnforcement({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: mfaReadLoginEnforcementQueryKey(options),
  });
};

/**
 * Create or update a login enforcement
 */
export const mfaWriteLoginEnforcementMutation = (
  options?: Partial<Options<MfaWriteLoginEnforcementData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<MfaWriteLoginEnforcementData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<MfaWriteLoginEnforcementData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await mfaWriteLoginEnforcement({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const mfaListMethodsQueryKey = (options: Options<MfaListMethodsData>) =>
  createQueryKey('mfaListMethods', options);

/**
 * List MFA method configurations for all MFA methods
 */
export const mfaListMethodsOptions = (options: Options<MfaListMethodsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await mfaListMethods({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: mfaListMethodsQueryKey(options),
  });
};

export const mfaListDuoMethodsQueryKey = (
  options: Options<MfaListDuoMethodsData>,
) => createQueryKey('mfaListDuoMethods', options);

/**
 * List MFA method configurations for the given MFA method
 */
export const mfaListDuoMethodsOptions = (
  options: Options<MfaListDuoMethodsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await mfaListDuoMethods({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: mfaListDuoMethodsQueryKey(options),
  });
};

/**
 * Delete a configuration for the given MFA method
 */
export const mfaDeleteDuoMethodMutation = (
  options?: Partial<Options<MfaDeleteDuoMethodData>>,
): UseMutationOptions<
  MfaDeleteDuoMethodResponse,
  DefaultError,
  Options<MfaDeleteDuoMethodData>
> => {
  const mutationOptions: UseMutationOptions<
    MfaDeleteDuoMethodResponse,
    DefaultError,
    Options<MfaDeleteDuoMethodData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await mfaDeleteDuoMethod({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const mfaReadDuoMethodConfigurationQueryKey = (
  options: Options<MfaReadDuoMethodConfigurationData>,
) => createQueryKey('mfaReadDuoMethodConfiguration', options);

/**
 * Read the current configuration for the given MFA method
 */
export const mfaReadDuoMethodConfigurationOptions = (
  options: Options<MfaReadDuoMethodConfigurationData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await mfaReadDuoMethodConfiguration({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: mfaReadDuoMethodConfigurationQueryKey(options),
  });
};

/**
 * Update or create a configuration for the given MFA method
 */
export const mfaConfigureDuoMethodMutation = (
  options?: Partial<Options<MfaConfigureDuoMethodData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<MfaConfigureDuoMethodData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<MfaConfigureDuoMethodData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await mfaConfigureDuoMethod({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const mfaListOktaMethodsQueryKey = (
  options: Options<MfaListOktaMethodsData>,
) => createQueryKey('mfaListOktaMethods', options);

/**
 * List MFA method configurations for the given MFA method
 */
export const mfaListOktaMethodsOptions = (
  options: Options<MfaListOktaMethodsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await mfaListOktaMethods({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: mfaListOktaMethodsQueryKey(options),
  });
};

/**
 * Delete a configuration for the given MFA method
 */
export const mfaDeleteOktaMethodMutation = (
  options?: Partial<Options<MfaDeleteOktaMethodData>>,
): UseMutationOptions<
  MfaDeleteOktaMethodResponse,
  DefaultError,
  Options<MfaDeleteOktaMethodData>
> => {
  const mutationOptions: UseMutationOptions<
    MfaDeleteOktaMethodResponse,
    DefaultError,
    Options<MfaDeleteOktaMethodData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await mfaDeleteOktaMethod({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const mfaReadOktaMethodConfigurationQueryKey = (
  options: Options<MfaReadOktaMethodConfigurationData>,
) => createQueryKey('mfaReadOktaMethodConfiguration', options);

/**
 * Read the current configuration for the given MFA method
 */
export const mfaReadOktaMethodConfigurationOptions = (
  options: Options<MfaReadOktaMethodConfigurationData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await mfaReadOktaMethodConfiguration({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: mfaReadOktaMethodConfigurationQueryKey(options),
  });
};

/**
 * Update or create a configuration for the given MFA method
 */
export const mfaConfigureOktaMethodMutation = (
  options?: Partial<Options<MfaConfigureOktaMethodData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<MfaConfigureOktaMethodData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<MfaConfigureOktaMethodData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await mfaConfigureOktaMethod({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const mfaListPingIdMethodsQueryKey = (
  options: Options<MfaListPingIdMethodsData>,
) => createQueryKey('mfaListPingIdMethods', options);

/**
 * List MFA method configurations for the given MFA method
 */
export const mfaListPingIdMethodsOptions = (
  options: Options<MfaListPingIdMethodsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await mfaListPingIdMethods({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: mfaListPingIdMethodsQueryKey(options),
  });
};

/**
 * Delete a configuration for the given MFA method
 */
export const mfaDeletePingIdMethodMutation = (
  options?: Partial<Options<MfaDeletePingIdMethodData>>,
): UseMutationOptions<
  MfaDeletePingIdMethodResponse,
  DefaultError,
  Options<MfaDeletePingIdMethodData>
> => {
  const mutationOptions: UseMutationOptions<
    MfaDeletePingIdMethodResponse,
    DefaultError,
    Options<MfaDeletePingIdMethodData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await mfaDeletePingIdMethod({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const mfaReadPingIdMethodConfigurationQueryKey = (
  options: Options<MfaReadPingIdMethodConfigurationData>,
) => createQueryKey('mfaReadPingIdMethodConfiguration', options);

/**
 * Read the current configuration for the given MFA method
 */
export const mfaReadPingIdMethodConfigurationOptions = (
  options: Options<MfaReadPingIdMethodConfigurationData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await mfaReadPingIdMethodConfiguration({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: mfaReadPingIdMethodConfigurationQueryKey(options),
  });
};

/**
 * Update or create a configuration for the given MFA method
 */
export const mfaConfigurePingIdMethodMutation = (
  options?: Partial<Options<MfaConfigurePingIdMethodData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<MfaConfigurePingIdMethodData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<MfaConfigurePingIdMethodData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await mfaConfigurePingIdMethod({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const mfaListTotpMethodsQueryKey = (
  options: Options<MfaListTotpMethodsData>,
) => createQueryKey('mfaListTotpMethods', options);

/**
 * List MFA method configurations for the given MFA method
 */
export const mfaListTotpMethodsOptions = (
  options: Options<MfaListTotpMethodsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await mfaListTotpMethods({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: mfaListTotpMethodsQueryKey(options),
  });
};

/**
 * Destroys a TOTP secret for the given MFA method ID on the given entity
 */
export const mfaAdminDestroyTotpSecretMutation = (
  options?: Partial<Options<MfaAdminDestroyTotpSecretData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<MfaAdminDestroyTotpSecretData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<MfaAdminDestroyTotpSecretData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await mfaAdminDestroyTotpSecret({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update or create TOTP secret for the given method ID on the given entity.
 */
export const mfaAdminGenerateTotpSecretMutation = (
  options?: Partial<Options<MfaAdminGenerateTotpSecretData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<MfaAdminGenerateTotpSecretData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<MfaAdminGenerateTotpSecretData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await mfaAdminGenerateTotpSecret({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update or create TOTP secret for the given method ID on the given entity.
 */
export const mfaGenerateTotpSecretMutation = (
  options?: Partial<Options<MfaGenerateTotpSecretData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<MfaGenerateTotpSecretData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<MfaGenerateTotpSecretData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await mfaGenerateTotpSecret({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete a configuration for the given MFA method
 */
export const mfaDeleteTotpMethodMutation = (
  options?: Partial<Options<MfaDeleteTotpMethodData>>,
): UseMutationOptions<
  MfaDeleteTotpMethodResponse,
  DefaultError,
  Options<MfaDeleteTotpMethodData>
> => {
  const mutationOptions: UseMutationOptions<
    MfaDeleteTotpMethodResponse,
    DefaultError,
    Options<MfaDeleteTotpMethodData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await mfaDeleteTotpMethod({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const mfaReadTotpMethodConfigurationQueryKey = (
  options: Options<MfaReadTotpMethodConfigurationData>,
) => createQueryKey('mfaReadTotpMethodConfiguration', options);

/**
 * Read the current configuration for the given MFA method
 */
export const mfaReadTotpMethodConfigurationOptions = (
  options: Options<MfaReadTotpMethodConfigurationData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await mfaReadTotpMethodConfiguration({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: mfaReadTotpMethodConfigurationQueryKey(options),
  });
};

/**
 * Update or create a configuration for the given MFA method
 */
export const mfaConfigureTotpMethodMutation = (
  options?: Partial<Options<MfaConfigureTotpMethodData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<MfaConfigureTotpMethodData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<MfaConfigureTotpMethodData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await mfaConfigureTotpMethod({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const mfaReadMethodConfigurationQueryKey = (
  options: Options<MfaReadMethodConfigurationData>,
) => createQueryKey('mfaReadMethodConfiguration', options);

/**
 * Read the current configuration for the given ID regardless of the MFA method type
 */
export const mfaReadMethodConfigurationOptions = (
  options: Options<MfaReadMethodConfigurationData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await mfaReadMethodConfiguration({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: mfaReadMethodConfigurationQueryKey(options),
  });
};

export const oidcReadPublicKeysQueryKey = (
  options?: Options<OidcReadPublicKeysData>,
) => createQueryKey('oidcReadPublicKeys', options);

/**
 * Retrieve public keys
 */
export const oidcReadPublicKeysOptions = (
  options?: Options<OidcReadPublicKeysData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await oidcReadPublicKeys({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: oidcReadPublicKeysQueryKey(options),
  });
};

export const oidcReadOpenIdConfigurationQueryKey = (
  options?: Options<OidcReadOpenIdConfigurationData>,
) => createQueryKey('oidcReadOpenIdConfiguration', options);

/**
 * Query OIDC configurations
 */
export const oidcReadOpenIdConfigurationOptions = (
  options?: Options<OidcReadOpenIdConfigurationData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await oidcReadOpenIdConfiguration({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: oidcReadOpenIdConfigurationQueryKey(options),
  });
};

export const oidcListAssignmentsQueryKey = (
  options: Options<OidcListAssignmentsData>,
) => createQueryKey('oidcListAssignments', options);

/**
 * List OIDC assignments
 */
export const oidcListAssignmentsOptions = (
  options: Options<OidcListAssignmentsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await oidcListAssignments({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: oidcListAssignmentsQueryKey(options),
  });
};

/**
 * CRUD operations for OIDC assignments.
 */
export const oidcDeleteAssignmentMutation = (
  options?: Partial<Options<OidcDeleteAssignmentData>>,
): UseMutationOptions<
  OidcDeleteAssignmentResponse,
  DefaultError,
  Options<OidcDeleteAssignmentData>
> => {
  const mutationOptions: UseMutationOptions<
    OidcDeleteAssignmentResponse,
    DefaultError,
    Options<OidcDeleteAssignmentData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await oidcDeleteAssignment({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const oidcReadAssignmentQueryKey = (
  options: Options<OidcReadAssignmentData>,
) => createQueryKey('oidcReadAssignment', options);

/**
 * CRUD operations for OIDC assignments.
 */
export const oidcReadAssignmentOptions = (
  options: Options<OidcReadAssignmentData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await oidcReadAssignment({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: oidcReadAssignmentQueryKey(options),
  });
};

/**
 * CRUD operations for OIDC assignments.
 */
export const oidcWriteAssignmentMutation = (
  options?: Partial<Options<OidcWriteAssignmentData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<OidcWriteAssignmentData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<OidcWriteAssignmentData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await oidcWriteAssignment({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const oidcListClientsQueryKey = (
  options: Options<OidcListClientsData>,
) => createQueryKey('oidcListClients', options);

/**
 * List OIDC clients
 */
export const oidcListClientsOptions = (
  options: Options<OidcListClientsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await oidcListClients({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: oidcListClientsQueryKey(options),
  });
};

/**
 * CRUD operations for OIDC clients.
 */
export const oidcDeleteClientMutation = (
  options?: Partial<Options<OidcDeleteClientData>>,
): UseMutationOptions<
  OidcDeleteClientResponse,
  DefaultError,
  Options<OidcDeleteClientData>
> => {
  const mutationOptions: UseMutationOptions<
    OidcDeleteClientResponse,
    DefaultError,
    Options<OidcDeleteClientData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await oidcDeleteClient({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const oidcReadClientQueryKey = (options: Options<OidcReadClientData>) =>
  createQueryKey('oidcReadClient', options);

/**
 * CRUD operations for OIDC clients.
 */
export const oidcReadClientOptions = (options: Options<OidcReadClientData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await oidcReadClient({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: oidcReadClientQueryKey(options),
  });
};

/**
 * CRUD operations for OIDC clients.
 */
export const oidcWriteClientMutation = (
  options?: Partial<Options<OidcWriteClientData>>,
): UseMutationOptions<unknown, DefaultError, Options<OidcWriteClientData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<OidcWriteClientData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await oidcWriteClient({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const oidcReadConfigurationQueryKey = (
  options?: Options<OidcReadConfigurationData>,
) => createQueryKey('oidcReadConfiguration', options);

/**
 * OIDC configuration
 */
export const oidcReadConfigurationOptions = (
  options?: Options<OidcReadConfigurationData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await oidcReadConfiguration({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: oidcReadConfigurationQueryKey(options),
  });
};

/**
 * OIDC configuration
 */
export const oidcConfigureMutation = (
  options?: Partial<Options<OidcConfigureData>>,
): UseMutationOptions<unknown, DefaultError, Options<OidcConfigureData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<OidcConfigureData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await oidcConfigure({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Verify the authenticity of an OIDC token
 */
export const oidcIntrospectMutation = (
  options?: Partial<Options<OidcIntrospectData>>,
): UseMutationOptions<unknown, DefaultError, Options<OidcIntrospectData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<OidcIntrospectData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await oidcIntrospect({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const oidcListKeysQueryKey = (options: Options<OidcListKeysData>) =>
  createQueryKey('oidcListKeys', options);

/**
 * List OIDC keys
 */
export const oidcListKeysOptions = (options: Options<OidcListKeysData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await oidcListKeys({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: oidcListKeysQueryKey(options),
  });
};

/**
 * CRUD operations for OIDC keys.
 */
export const oidcDeleteKeyMutation = (
  options?: Partial<Options<OidcDeleteKeyData>>,
): UseMutationOptions<
  OidcDeleteKeyResponse,
  DefaultError,
  Options<OidcDeleteKeyData>
> => {
  const mutationOptions: UseMutationOptions<
    OidcDeleteKeyResponse,
    DefaultError,
    Options<OidcDeleteKeyData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await oidcDeleteKey({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const oidcReadKeyQueryKey = (options: Options<OidcReadKeyData>) =>
  createQueryKey('oidcReadKey', options);

/**
 * CRUD operations for OIDC keys.
 */
export const oidcReadKeyOptions = (options: Options<OidcReadKeyData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await oidcReadKey({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: oidcReadKeyQueryKey(options),
  });
};

/**
 * CRUD operations for OIDC keys.
 */
export const oidcWriteKeyMutation = (
  options?: Partial<Options<OidcWriteKeyData>>,
): UseMutationOptions<unknown, DefaultError, Options<OidcWriteKeyData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<OidcWriteKeyData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await oidcWriteKey({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Rotate a named OIDC key.
 */
export const oidcRotateKeyMutation = (
  options?: Partial<Options<OidcRotateKeyData>>,
): UseMutationOptions<unknown, DefaultError, Options<OidcRotateKeyData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<OidcRotateKeyData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await oidcRotateKey({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const oidcListProvidersQueryKey = (
  options: Options<OidcListProvidersData>,
) => createQueryKey('oidcListProviders', options);

/**
 * List OIDC providers
 */
export const oidcListProvidersOptions = (
  options: Options<OidcListProvidersData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await oidcListProviders({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: oidcListProvidersQueryKey(options),
  });
};

/**
 * CRUD operations for OIDC providers.
 */
export const oidcDeleteProviderMutation = (
  options?: Partial<Options<OidcDeleteProviderData>>,
): UseMutationOptions<
  OidcDeleteProviderResponse,
  DefaultError,
  Options<OidcDeleteProviderData>
> => {
  const mutationOptions: UseMutationOptions<
    OidcDeleteProviderResponse,
    DefaultError,
    Options<OidcDeleteProviderData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await oidcDeleteProvider({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const oidcReadProviderQueryKey = (
  options: Options<OidcReadProviderData>,
) => createQueryKey('oidcReadProvider', options);

/**
 * CRUD operations for OIDC providers.
 */
export const oidcReadProviderOptions = (
  options: Options<OidcReadProviderData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await oidcReadProvider({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: oidcReadProviderQueryKey(options),
  });
};

/**
 * CRUD operations for OIDC providers.
 */
export const oidcWriteProviderMutation = (
  options?: Partial<Options<OidcWriteProviderData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<OidcWriteProviderData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<OidcWriteProviderData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await oidcWriteProvider({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const oidcReadProviderPublicKeysQueryKey = (
  options: Options<OidcReadProviderPublicKeysData>,
) => createQueryKey('oidcReadProviderPublicKeys', options);

/**
 * Retrieve public keys
 */
export const oidcReadProviderPublicKeysOptions = (
  options: Options<OidcReadProviderPublicKeysData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await oidcReadProviderPublicKeys({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: oidcReadProviderPublicKeysQueryKey(options),
  });
};

export const oidcReadProviderOpenIdConfigurationQueryKey = (
  options: Options<OidcReadProviderOpenIdConfigurationData>,
) => createQueryKey('oidcReadProviderOpenIdConfiguration', options);

/**
 * Query OIDC configurations
 */
export const oidcReadProviderOpenIdConfigurationOptions = (
  options: Options<OidcReadProviderOpenIdConfigurationData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await oidcReadProviderOpenIdConfiguration({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: oidcReadProviderOpenIdConfigurationQueryKey(options),
  });
};

export const oidcProviderAuthorizeQueryKey = (
  options: Options<OidcProviderAuthorizeData>,
) => createQueryKey('oidcProviderAuthorize', options);

/**
 * Provides the OIDC Authorization Endpoint.
 */
export const oidcProviderAuthorizeOptions = (
  options: Options<OidcProviderAuthorizeData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await oidcProviderAuthorize({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: oidcProviderAuthorizeQueryKey(options),
  });
};

/**
 * Provides the OIDC Authorization Endpoint.
 */
export const oidcProviderAuthorizeWithParametersMutation = (
  options?: Partial<Options<OidcProviderAuthorizeWithParametersData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<OidcProviderAuthorizeWithParametersData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<OidcProviderAuthorizeWithParametersData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await oidcProviderAuthorizeWithParameters({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Provides the OIDC Token Endpoint.
 */
export const oidcProviderTokenMutation = (
  options?: Partial<Options<OidcProviderTokenData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<OidcProviderTokenData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<OidcProviderTokenData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await oidcProviderToken({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const oidcProviderUserInfoQueryKey = (
  options: Options<OidcProviderUserInfoData>,
) => createQueryKey('oidcProviderUserInfo', options);

/**
 * Provides the OIDC UserInfo Endpoint.
 */
export const oidcProviderUserInfoOptions = (
  options: Options<OidcProviderUserInfoData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await oidcProviderUserInfo({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: oidcProviderUserInfoQueryKey(options),
  });
};

/**
 * Provides the OIDC UserInfo Endpoint.
 */
export const oidcProviderUserInfo2Mutation = (
  options?: Partial<Options<OidcProviderUserInfo2Data>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<OidcProviderUserInfo2Data>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<OidcProviderUserInfo2Data>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await oidcProviderUserInfo2({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const oidcListRolesQueryKey = (options: Options<OidcListRolesData>) =>
  createQueryKey('oidcListRoles', options);

/**
 * List configured OIDC roles
 */
export const oidcListRolesOptions = (options: Options<OidcListRolesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await oidcListRoles({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: oidcListRolesQueryKey(options),
  });
};

/**
 * CRUD operations on OIDC Roles
 */
export const oidcDeleteRoleMutation = (
  options?: Partial<Options<OidcDeleteRoleData>>,
): UseMutationOptions<
  OidcDeleteRoleResponse,
  DefaultError,
  Options<OidcDeleteRoleData>
> => {
  const mutationOptions: UseMutationOptions<
    OidcDeleteRoleResponse,
    DefaultError,
    Options<OidcDeleteRoleData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await oidcDeleteRole({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const oidcReadRoleQueryKey = (options: Options<OidcReadRoleData>) =>
  createQueryKey('oidcReadRole', options);

/**
 * CRUD operations on OIDC Roles
 */
export const oidcReadRoleOptions = (options: Options<OidcReadRoleData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await oidcReadRole({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: oidcReadRoleQueryKey(options),
  });
};

/**
 * CRUD operations on OIDC Roles
 */
export const oidcWriteRoleMutation = (
  options?: Partial<Options<OidcWriteRoleData>>,
): UseMutationOptions<unknown, DefaultError, Options<OidcWriteRoleData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<OidcWriteRoleData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await oidcWriteRole({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const oidcListScopesQueryKey = (options: Options<OidcListScopesData>) =>
  createQueryKey('oidcListScopes', options);

/**
 * List OIDC scopes
 */
export const oidcListScopesOptions = (options: Options<OidcListScopesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await oidcListScopes({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: oidcListScopesQueryKey(options),
  });
};

/**
 * CRUD operations for OIDC scopes.
 */
export const oidcDeleteScopeMutation = (
  options?: Partial<Options<OidcDeleteScopeData>>,
): UseMutationOptions<
  OidcDeleteScopeResponse,
  DefaultError,
  Options<OidcDeleteScopeData>
> => {
  const mutationOptions: UseMutationOptions<
    OidcDeleteScopeResponse,
    DefaultError,
    Options<OidcDeleteScopeData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await oidcDeleteScope({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const oidcReadScopeQueryKey = (options: Options<OidcReadScopeData>) =>
  createQueryKey('oidcReadScope', options);

/**
 * CRUD operations for OIDC scopes.
 */
export const oidcReadScopeOptions = (options: Options<OidcReadScopeData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await oidcReadScope({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: oidcReadScopeQueryKey(options),
  });
};

/**
 * CRUD operations for OIDC scopes.
 */
export const oidcWriteScopeMutation = (
  options?: Partial<Options<OidcWriteScopeData>>,
): UseMutationOptions<unknown, DefaultError, Options<OidcWriteScopeData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<OidcWriteScopeData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await oidcWriteScope({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const oidcGenerateTokenQueryKey = (
  options: Options<OidcGenerateTokenData>,
) => createQueryKey('oidcGenerateToken', options);

/**
 * Generate an OIDC token
 */
export const oidcGenerateTokenOptions = (
  options: Options<OidcGenerateTokenData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await oidcGenerateToken({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: oidcGenerateTokenQueryKey(options),
  });
};

/**
 * Create a new alias.
 */
export const personaCreateMutation = (
  options?: Partial<Options<PersonaCreateData>>,
): UseMutationOptions<unknown, DefaultError, Options<PersonaCreateData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<PersonaCreateData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await personaCreate({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const personaListByIdQueryKey = (
  options: Options<PersonaListByIdData>,
) => createQueryKey('personaListById', options);

/**
 * List all the alias IDs.
 */
export const personaListByIdOptions = (
  options: Options<PersonaListByIdData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await personaListById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: personaListByIdQueryKey(options),
  });
};

/**
 * Update, read or delete an alias ID.
 */
export const personaDeleteByIdMutation = (
  options?: Partial<Options<PersonaDeleteByIdData>>,
): UseMutationOptions<
  PersonaDeleteByIdResponse,
  DefaultError,
  Options<PersonaDeleteByIdData>
> => {
  const mutationOptions: UseMutationOptions<
    PersonaDeleteByIdResponse,
    DefaultError,
    Options<PersonaDeleteByIdData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await personaDeleteById({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const personaReadByIdQueryKey = (
  options: Options<PersonaReadByIdData>,
) => createQueryKey('personaReadById', options);

/**
 * Update, read or delete an alias ID.
 */
export const personaReadByIdOptions = (
  options: Options<PersonaReadByIdData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await personaReadById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: personaReadByIdQueryKey(options),
  });
};

/**
 * Update, read or delete an alias ID.
 */
export const personaUpdateByIdMutation = (
  options?: Partial<Options<PersonaUpdateByIdData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<PersonaUpdateByIdData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<PersonaUpdateByIdData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await personaUpdateById({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const auditingListEnabledDevicesQueryKey = (
  options?: Options<AuditingListEnabledDevicesData>,
) => createQueryKey('auditingListEnabledDevices', options);

/**
 * List the enabled audit devices.
 * List the currently enabled audit backends.
 */
export const auditingListEnabledDevicesOptions = (
  options?: Options<AuditingListEnabledDevicesData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await auditingListEnabledDevices({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: auditingListEnabledDevicesQueryKey(options),
  });
};

/**
 * The hash of the given string via the given audit backend
 */
export const auditingCalculateHashMutation = (
  options?: Partial<Options<AuditingCalculateHashData>>,
): UseMutationOptions<
  AuditingCalculateHashResponse2,
  DefaultError,
  Options<AuditingCalculateHashData>
> => {
  const mutationOptions: UseMutationOptions<
    AuditingCalculateHashResponse2,
    DefaultError,
    Options<AuditingCalculateHashData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await auditingCalculateHash({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Disable the audit device at the given path.
 * Enable or disable audit backends.
 */
export const auditingDisableDeviceMutation = (
  options?: Partial<Options<AuditingDisableDeviceData>>,
): UseMutationOptions<
  AuditingDisableDeviceResponse,
  DefaultError,
  Options<AuditingDisableDeviceData>
> => {
  const mutationOptions: UseMutationOptions<
    AuditingDisableDeviceResponse,
    DefaultError,
    Options<AuditingDisableDeviceData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await auditingDisableDevice({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Enable a new audit device at the supplied path.
 * Enable or disable audit backends.
 */
export const auditingEnableDeviceMutation = (
  options?: Partial<Options<AuditingEnableDeviceData>>,
): UseMutationOptions<
  AuditingEnableDeviceResponse,
  DefaultError,
  Options<AuditingEnableDeviceData>
> => {
  const mutationOptions: UseMutationOptions<
    AuditingEnableDeviceResponse,
    DefaultError,
    Options<AuditingEnableDeviceData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await auditingEnableDevice({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const authListEnabledMethodsQueryKey = (
  options?: Options<AuthListEnabledMethodsData>,
) => createQueryKey('authListEnabledMethods', options);

/**
 * List the currently enabled credential backends.
 */
export const authListEnabledMethodsOptions = (
  options?: Options<AuthListEnabledMethodsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await authListEnabledMethods({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: authListEnabledMethodsQueryKey(options),
  });
};

/**
 * Disable the auth method at the given auth path
 * Enable a new credential backend with a name.
 */
export const authDisableMethodMutation = (
  options?: Partial<Options<AuthDisableMethodData>>,
): UseMutationOptions<
  AuthDisableMethodResponse,
  DefaultError,
  Options<AuthDisableMethodData>
> => {
  const mutationOptions: UseMutationOptions<
    AuthDisableMethodResponse,
    DefaultError,
    Options<AuthDisableMethodData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await authDisableMethod({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const authReadConfigurationQueryKey = (
  options: Options<AuthReadConfigurationData>,
) => createQueryKey('authReadConfiguration', options);

/**
 * Read the configuration of the auth engine at the given path.
 * Enable a new credential backend with a name.
 */
export const authReadConfigurationOptions = (
  options: Options<AuthReadConfigurationData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await authReadConfiguration({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: authReadConfigurationQueryKey(options),
  });
};

/**
 * Enables a new auth method.
 * After enabling, the auth method can be accessed and configured via the auth path specified as part of the URL. This auth path will be nested under the auth prefix.
 *
 * For example, enable the "foo" auth method will make it accessible at /auth/foo.
 */
export const authEnableMethodMutation = (
  options?: Partial<Options<AuthEnableMethodData>>,
): UseMutationOptions<
  AuthEnableMethodResponse,
  DefaultError,
  Options<AuthEnableMethodData>
> => {
  const mutationOptions: UseMutationOptions<
    AuthEnableMethodResponse,
    DefaultError,
    Options<AuthEnableMethodData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await authEnableMethod({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const authReadTuningInformationQueryKey = (
  options: Options<AuthReadTuningInformationData>,
) => createQueryKey('authReadTuningInformation', options);

/**
 * Reads the given auth path's configuration.
 * This endpoint requires sudo capability on the final path, but the same functionality can be achieved without sudo via `sys/mounts/auth/[auth-path]/tune`.
 */
export const authReadTuningInformationOptions = (
  options: Options<AuthReadTuningInformationData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await authReadTuningInformation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: authReadTuningInformationQueryKey(options),
  });
};

/**
 * Tune configuration parameters for a given auth path.
 * This endpoint requires sudo capability on the final path, but the same functionality can be achieved without sudo via `sys/mounts/auth/[auth-path]/tune`.
 */
export const authTuneConfigurationParametersMutation = (
  options?: Partial<Options<AuthTuneConfigurationParametersData>>,
): UseMutationOptions<
  AuthTuneConfigurationParametersResponse,
  DefaultError,
  Options<AuthTuneConfigurationParametersData>
> => {
  const mutationOptions: UseMutationOptions<
    AuthTuneConfigurationParametersResponse,
    DefaultError,
    Options<AuthTuneConfigurationParametersData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await authTuneConfigurationParameters({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Fetches the capabilities of the given token on the given path.
 */
export const queryTokenCapabilitiesMutation = (
  options?: Partial<Options<QueryTokenCapabilitiesData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<QueryTokenCapabilitiesData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<QueryTokenCapabilitiesData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await queryTokenCapabilities({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Fetches the capabilities of the token associated with the given token, on the given path.
 */
export const queryTokenAccessorCapabilitiesMutation = (
  options?: Partial<Options<QueryTokenAccessorCapabilitiesData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<QueryTokenAccessorCapabilitiesData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<QueryTokenAccessorCapabilitiesData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await queryTokenAccessorCapabilities({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Fetches the capabilities of the given token on the given path.
 */
export const queryTokenSelfCapabilitiesMutation = (
  options?: Partial<Options<QueryTokenSelfCapabilitiesData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<QueryTokenSelfCapabilitiesData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<QueryTokenSelfCapabilitiesData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await queryTokenSelfCapabilities({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const auditingListRequestHeadersQueryKey = (
  options?: Options<AuditingListRequestHeadersData>,
) => createQueryKey('auditingListRequestHeaders', options);

/**
 * List the request headers that are configured to be audited.
 * Lists the headers configured to be audited.
 */
export const auditingListRequestHeadersOptions = (
  options?: Options<AuditingListRequestHeadersData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await auditingListRequestHeaders({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: auditingListRequestHeadersQueryKey(options),
  });
};

/**
 * Disable auditing of the given request header.
 * Configures the headers sent to the audit logs.
 */
export const auditingDisableRequestHeaderMutation = (
  options?: Partial<Options<AuditingDisableRequestHeaderData>>,
): UseMutationOptions<
  AuditingDisableRequestHeaderResponse,
  DefaultError,
  Options<AuditingDisableRequestHeaderData>
> => {
  const mutationOptions: UseMutationOptions<
    AuditingDisableRequestHeaderResponse,
    DefaultError,
    Options<AuditingDisableRequestHeaderData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await auditingDisableRequestHeader({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const auditingReadRequestHeaderInformationQueryKey = (
  options: Options<AuditingReadRequestHeaderInformationData>,
) => createQueryKey('auditingReadRequestHeaderInformation', options);

/**
 * List the information for the given request header.
 * Configures the headers sent to the audit logs.
 */
export const auditingReadRequestHeaderInformationOptions = (
  options: Options<AuditingReadRequestHeaderInformationData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await auditingReadRequestHeaderInformation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: auditingReadRequestHeaderInformationQueryKey(options),
  });
};

/**
 * Enable auditing of a header.
 * Configures the headers sent to the audit logs.
 */
export const auditingEnableRequestHeaderMutation = (
  options?: Partial<Options<AuditingEnableRequestHeaderData>>,
): UseMutationOptions<
  AuditingEnableRequestHeaderResponse,
  DefaultError,
  Options<AuditingEnableRequestHeaderData>
> => {
  const mutationOptions: UseMutationOptions<
    AuditingEnableRequestHeaderResponse,
    DefaultError,
    Options<AuditingEnableRequestHeaderData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await auditingEnableRequestHeader({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Remove any CORS settings.
 * This path responds to the following HTTP methods. GET / Returns the configuration of the CORS setting. POST / Sets the comma-separated list of origins that can make cross-origin requests. DELETE / Clears the CORS configuration and disables acceptance of CORS requests.
 */
export const corsDeleteConfigurationMutation = (
  options?: Partial<Options<CorsDeleteConfigurationData>>,
): UseMutationOptions<
  CorsDeleteConfigurationResponse,
  DefaultError,
  Options<CorsDeleteConfigurationData>
> => {
  const mutationOptions: UseMutationOptions<
    CorsDeleteConfigurationResponse,
    DefaultError,
    Options<CorsDeleteConfigurationData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await corsDeleteConfiguration({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const corsReadConfigurationQueryKey = (
  options?: Options<CorsReadConfigurationData>,
) => createQueryKey('corsReadConfiguration', options);

/**
 * Return the current CORS settings.
 * This path responds to the following HTTP methods. GET / Returns the configuration of the CORS setting. POST / Sets the comma-separated list of origins that can make cross-origin requests. DELETE / Clears the CORS configuration and disables acceptance of CORS requests.
 */
export const corsReadConfigurationOptions = (
  options?: Options<CorsReadConfigurationData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await corsReadConfiguration({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: corsReadConfigurationQueryKey(options),
  });
};

/**
 * Configure the CORS settings.
 * This path responds to the following HTTP methods. GET / Returns the configuration of the CORS setting. POST / Sets the comma-separated list of origins that can make cross-origin requests. DELETE / Clears the CORS configuration and disables acceptance of CORS requests.
 */
export const corsConfigureMutation = (
  options?: Partial<Options<CorsConfigureData>>,
): UseMutationOptions<
  CorsConfigureResponse,
  DefaultError,
  Options<CorsConfigureData>
> => {
  const mutationOptions: UseMutationOptions<
    CorsConfigureResponse,
    DefaultError,
    Options<CorsConfigureData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await corsConfigure({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Reload the given subsystem
 */
export const reloadSubsystemMutation = (
  options?: Partial<Options<ReloadSubsystemData>>,
): UseMutationOptions<
  ReloadSubsystemResponse,
  DefaultError,
  Options<ReloadSubsystemData>
> => {
  const mutationOptions: UseMutationOptions<
    ReloadSubsystemResponse,
    DefaultError,
    Options<ReloadSubsystemData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await reloadSubsystem({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const readSanitizedConfigurationStateQueryKey = (
  options?: Options<ReadSanitizedConfigurationStateData>,
) => createQueryKey('readSanitizedConfigurationState', options);

/**
 * Return a sanitized version of the OpenBao server configuration.
 * The sanitized output strips configuration values in the storage, HA storage, and seals stanzas, which may contain sensitive values such as API tokens. It also removes any token or secret fields in other stanzas, such as the circonus_api_token from telemetry.
 */
export const readSanitizedConfigurationStateOptions = (
  options?: Options<ReadSanitizedConfigurationStateData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await readSanitizedConfigurationState({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: readSanitizedConfigurationStateQueryKey(options),
  });
};

export const uiHeadersListQueryKey = (options: Options<UiHeadersListData>) =>
  createQueryKey('uiHeadersList', options);

/**
 * Return a list of configured UI headers.
 * This path responds to the following HTTP methods. GET /<header> Returns the header value. POST /<header> Sets the header value for the UI. DELETE /<header> Clears the header value for UI. LIST / List the headers configured for the UI.
 */
export const uiHeadersListOptions = (options: Options<UiHeadersListData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await uiHeadersList({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: uiHeadersListQueryKey(options),
  });
};

/**
 * Remove a UI header.
 * This path responds to the following HTTP methods. GET /<header> Returns the header value. POST /<header> Sets the header value for the UI. DELETE /<header> Clears the header value for UI. LIST / List the headers configured for the UI.
 */
export const uiHeadersDeleteConfigurationMutation = (
  options?: Partial<Options<UiHeadersDeleteConfigurationData>>,
): UseMutationOptions<
  UiHeadersDeleteConfigurationResponse,
  DefaultError,
  Options<UiHeadersDeleteConfigurationData>
> => {
  const mutationOptions: UseMutationOptions<
    UiHeadersDeleteConfigurationResponse,
    DefaultError,
    Options<UiHeadersDeleteConfigurationData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await uiHeadersDeleteConfiguration({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const uiHeadersReadConfigurationQueryKey = (
  options: Options<UiHeadersReadConfigurationData>,
) => createQueryKey('uiHeadersReadConfiguration', options);

/**
 * Return the given UI header's configuration
 * This path responds to the following HTTP methods. GET /<header> Returns the header value. POST /<header> Sets the header value for the UI. DELETE /<header> Clears the header value for UI. LIST / List the headers configured for the UI.
 */
export const uiHeadersReadConfigurationOptions = (
  options: Options<UiHeadersReadConfigurationData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await uiHeadersReadConfiguration({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: uiHeadersReadConfigurationQueryKey(options),
  });
};

/**
 * Configure the values to be returned for the UI header.
 * This path responds to the following HTTP methods. GET /<header> Returns the header value. POST /<header> Sets the header value for the UI. DELETE /<header> Clears the header value for UI. LIST / List the headers configured for the UI.
 */
export const uiHeadersConfigureMutation = (
  options?: Partial<Options<UiHeadersConfigureData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<UiHeadersConfigureData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<UiHeadersConfigureData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await uiHeadersConfigure({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Decodes the encoded token with the otp.
 */
export const decodeMutation = (
  options?: Partial<Options<DecodeData>>,
): UseMutationOptions<unknown, DefaultError, Options<DecodeData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<DecodeData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await decode({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Cancels any in-progress root generation attempt.
 * Reads, generates, or deletes a root token regeneration process.
 */
export const rootTokenGenerationCancel2Mutation = (
  options?: Partial<Options<RootTokenGenerationCancel2Data>>,
): UseMutationOptions<
  RootTokenGenerationCancel2Response,
  DefaultError,
  Options<RootTokenGenerationCancel2Data>
> => {
  const mutationOptions: UseMutationOptions<
    RootTokenGenerationCancel2Response,
    DefaultError,
    Options<RootTokenGenerationCancel2Data>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await rootTokenGenerationCancel2({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const rootTokenGenerationReadProgress2QueryKey = (
  options?: Options<RootTokenGenerationReadProgress2Data>,
) => createQueryKey('rootTokenGenerationReadProgress2', options);

/**
 * Read the configuration and progress of the current root generation attempt.
 * Reads, generates, or deletes a root token regeneration process.
 */
export const rootTokenGenerationReadProgress2Options = (
  options?: Options<RootTokenGenerationReadProgress2Data>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await rootTokenGenerationReadProgress2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: rootTokenGenerationReadProgress2QueryKey(options),
  });
};

/**
 * Initializes a new root generation attempt.
 * Only a single root generation attempt can take place at a time. One (and only one) of otp or pgp_key are required.
 */
export const rootTokenGenerationInitialize2Mutation = (
  options?: Partial<Options<RootTokenGenerationInitialize2Data>>,
): UseMutationOptions<
  RootTokenGenerationInitialize2Response2,
  DefaultError,
  Options<RootTokenGenerationInitialize2Data>
> => {
  const mutationOptions: UseMutationOptions<
    RootTokenGenerationInitialize2Response2,
    DefaultError,
    Options<RootTokenGenerationInitialize2Data>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await rootTokenGenerationInitialize2({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Cancels any in-progress root generation attempt.
 * Reads, generates, or deletes a root token regeneration process.
 */
export const rootTokenGenerationCancelMutation = (
  options?: Partial<Options<RootTokenGenerationCancelData>>,
): UseMutationOptions<
  RootTokenGenerationCancelResponse,
  DefaultError,
  Options<RootTokenGenerationCancelData>
> => {
  const mutationOptions: UseMutationOptions<
    RootTokenGenerationCancelResponse,
    DefaultError,
    Options<RootTokenGenerationCancelData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await rootTokenGenerationCancel({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const rootTokenGenerationReadProgressQueryKey = (
  options?: Options<RootTokenGenerationReadProgressData>,
) => createQueryKey('rootTokenGenerationReadProgress', options);

/**
 * Read the configuration and progress of the current root generation attempt.
 * Reads, generates, or deletes a root token regeneration process.
 */
export const rootTokenGenerationReadProgressOptions = (
  options?: Options<RootTokenGenerationReadProgressData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await rootTokenGenerationReadProgress({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: rootTokenGenerationReadProgressQueryKey(options),
  });
};

/**
 * Initializes a new root generation attempt.
 * Only a single root generation attempt can take place at a time. One (and only one) of otp or pgp_key are required.
 */
export const rootTokenGenerationInitializeMutation = (
  options?: Partial<Options<RootTokenGenerationInitializeData>>,
): UseMutationOptions<
  RootTokenGenerationInitializeResponse2,
  DefaultError,
  Options<RootTokenGenerationInitializeData>
> => {
  const mutationOptions: UseMutationOptions<
    RootTokenGenerationInitializeResponse2,
    DefaultError,
    Options<RootTokenGenerationInitializeData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await rootTokenGenerationInitialize({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Enter a single unseal key share to progress the root generation attempt.
 * If the threshold number of unseal key shares is reached, OpenBao will complete the root generation and issue the new token. Otherwise, this API must be called multiple times until that threshold is met. The attempt nonce must be provided with each call.
 */
export const rootTokenGenerationUpdateMutation = (
  options?: Partial<Options<RootTokenGenerationUpdateData>>,
): UseMutationOptions<
  RootTokenGenerationUpdateResponse2,
  DefaultError,
  Options<RootTokenGenerationUpdateData>
> => {
  const mutationOptions: UseMutationOptions<
    RootTokenGenerationUpdateResponse2,
    DefaultError,
    Options<RootTokenGenerationUpdateData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await rootTokenGenerationUpdate({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const haStatusQueryKey = (options?: Options<HaStatusData>) =>
  createQueryKey('haStatus', options);

/**
 * Check the HA status of an OpenBao cluster
 * Provides information about the nodes in an HA cluster.
 */
export const haStatusOptions = (options?: Options<HaStatusData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await haStatus({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: haStatusQueryKey(options),
  });
};

export const readHealthStatusQueryKey = (
  options?: Options<ReadHealthStatusData>,
) => createQueryKey('readHealthStatus', options);

/**
 * Returns the health status of OpenBao.
 * Checks the health status of OpenBao.
 */
export const readHealthStatusOptions = (
  options?: Options<ReadHealthStatusData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await readHealthStatus({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: readHealthStatusQueryKey(options),
  });
};

export const collectHostInformationQueryKey = (
  options?: Options<CollectHostInformationData>,
) => createQueryKey('collectHostInformation', options);

/**
 * Information about the host instance that this OpenBao server is running on.
 * Information about the host instance that this OpenBao server is running on.
 * The information that gets collected includes host hardware information, and CPU,
 * disk, and memory utilization
 */
export const collectHostInformationOptions = (
  options?: Options<CollectHostInformationData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await collectHostInformation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: collectHostInformationQueryKey(options),
  });
};

export const collectInFlightRequestInformationQueryKey = (
  options?: Options<CollectInFlightRequestInformationData>,
) => createQueryKey('collectInFlightRequestInformation', options);

/**
 * reports in-flight requests
 * This path responds to the following HTTP methods.
 * GET /
 * Returns a map of in-flight requests.
 */
export const collectInFlightRequestInformationOptions = (
  options?: Options<CollectInFlightRequestInformationData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await collectInFlightRequestInformation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: collectInFlightRequestInformationQueryKey(options),
  });
};

export const readInitializationStatusQueryKey = (
  options?: Options<ReadInitializationStatusData>,
) => createQueryKey('readInitializationStatus', options);

/**
 * Returns the initialization status of OpenBao.
 * Initializes or returns the initialization status of OpenBao.
 */
export const readInitializationStatusOptions = (
  options?: Options<ReadInitializationStatusData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await readInitializationStatus({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: readInitializationStatusQueryKey(options),
  });
};

/**
 * Initialize a new OpenBao instance.
 * The OpenBao instance must not have been previously initialized. The recovery options, as well as the stored shares option, are only available when using OpenBao HSM.
 */
export const initializeSystemMutation = (
  options?: Partial<Options<InitializeSystemData>>,
): UseMutationOptions<unknown, DefaultError, Options<InitializeSystemData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<InitializeSystemData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await initializeSystem({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const internalCountEntitiesQueryKey = (
  options?: Options<InternalCountEntitiesData>,
) => createQueryKey('internalCountEntities', options);

/**
 * Backwards compatibility is not guaranteed for this API
 * Count of active entities in this OpenBao cluster.
 */
export const internalCountEntitiesOptions = (
  options?: Options<InternalCountEntitiesData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await internalCountEntities({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: internalCountEntitiesQueryKey(options),
  });
};

export const internalCountRequestsQueryKey = (
  options?: Options<InternalCountRequestsData>,
) => createQueryKey('internalCountRequests', options);

/**
 * Backwards compatibility is not guaranteed for this API
 * Currently unsupported. Previously, count of requests seen by this OpenBao cluster over time.
 * @deprecated
 */
export const internalCountRequestsOptions = (
  options?: Options<InternalCountRequestsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await internalCountRequests({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: internalCountRequestsQueryKey(options),
  });
};

export const internalCountTokensQueryKey = (
  options?: Options<InternalCountTokensData>,
) => createQueryKey('internalCountTokens', options);

/**
 * Backwards compatibility is not guaranteed for this API
 * Count of active tokens in this OpenBao cluster.
 */
export const internalCountTokensOptions = (
  options?: Options<InternalCountTokensData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await internalCountTokens({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: internalCountTokensQueryKey(options),
  });
};

export const internalInspectRequestQueryKey = (
  options?: Options<InternalInspectRequestData>,
) => createQueryKey('internalInspectRequest', options);

/**
 * Expose all request information to the caller
 * Outputs information contained within a request to a plugin.
 */
export const internalInspectRequestOptions = (
  options?: Options<InternalInspectRequestData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await internalInspectRequest({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: internalInspectRequestQueryKey(options),
  });
};

export const internalInspectRouterQueryKey = (
  options: Options<InternalInspectRouterData>,
) => createQueryKey('internalInspectRouter', options);

/**
 * Expose the route entry and mount entry tables present in the router
 * Information on the entries in each of the trees in the router. Inspectable trees are uuid, accessor, storage, and root.
 */
export const internalInspectRouterOptions = (
  options: Options<InternalInspectRouterData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await internalInspectRouter({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: internalInspectRouterQueryKey(options),
  });
};

export const internalGenerateOpenApiDocumentQueryKey = (
  options?: Options<InternalGenerateOpenApiDocumentData>,
) => createQueryKey('internalGenerateOpenApiDocument', options);

/**
 * Generate an OpenAPI 3 document of all mounted paths.
 */
export const internalGenerateOpenApiDocumentOptions = (
  options?: Options<InternalGenerateOpenApiDocumentData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await internalGenerateOpenApiDocument({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: internalGenerateOpenApiDocumentQueryKey(options),
  });
};

/**
 * Generate an OpenAPI 3 document of all mounted paths.
 */
export const internalGenerateOpenApiDocumentWithParametersMutation = (
  options?: Partial<Options<InternalGenerateOpenApiDocumentWithParametersData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<InternalGenerateOpenApiDocumentWithParametersData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<InternalGenerateOpenApiDocumentWithParametersData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await internalGenerateOpenApiDocumentWithParameters({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const internalUiListEnabledFeatureFlagsQueryKey = (
  options?: Options<InternalUiListEnabledFeatureFlagsData>,
) => createQueryKey('internalUiListEnabledFeatureFlags', options);

/**
 * Lists enabled feature flags.
 * Enabled feature flags. Internal API; its location, inputs, and outputs may change.
 */
export const internalUiListEnabledFeatureFlagsOptions = (
  options?: Options<InternalUiListEnabledFeatureFlagsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await internalUiListEnabledFeatureFlags({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: internalUiListEnabledFeatureFlagsQueryKey(options),
  });
};

export const internalUiListEnabledVisibleMountsQueryKey = (
  options?: Options<InternalUiListEnabledVisibleMountsData>,
) => createQueryKey('internalUiListEnabledVisibleMounts', options);

/**
 * Lists all enabled and visible auth and secrets mounts.
 * Information about mounts returned according to their tuned visibility. Internal API; its location, inputs, and outputs may change.
 */
export const internalUiListEnabledVisibleMountsOptions = (
  options?: Options<InternalUiListEnabledVisibleMountsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await internalUiListEnabledVisibleMounts({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: internalUiListEnabledVisibleMountsQueryKey(options),
  });
};

export const internalUiReadMountInformationQueryKey = (
  options: Options<InternalUiReadMountInformationData>,
) => createQueryKey('internalUiReadMountInformation', options);

/**
 * Return information about the given mount.
 * Information about mounts returned according to their tuned visibility. Internal API; its location, inputs, and outputs may change.
 */
export const internalUiReadMountInformationOptions = (
  options: Options<InternalUiReadMountInformationData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await internalUiReadMountInformation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: internalUiReadMountInformationQueryKey(options),
  });
};

export const internalUiListNamespacesQueryKey = (
  options?: Options<InternalUiListNamespacesData>,
) => createQueryKey('internalUiListNamespaces', options);

/**
 * Backwards compatibility is not guaranteed for this API
 * Information about visible child namespaces. Internal API; its location, inputs, and outputs may change.
 */
export const internalUiListNamespacesOptions = (
  options?: Options<InternalUiListNamespacesData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await internalUiListNamespaces({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: internalUiListNamespacesQueryKey(options),
  });
};

export const internalUiReadResultantAclQueryKey = (
  options?: Options<InternalUiReadResultantAclData>,
) => createQueryKey('internalUiReadResultantAcl', options);

/**
 * Backwards compatibility is not guaranteed for this API
 * Information about a token's resultant ACL. Internal API; its location, inputs, and outputs may change.
 */
export const internalUiReadResultantAclOptions = (
  options?: Options<InternalUiReadResultantAclData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await internalUiReadResultantAcl({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: internalUiReadResultantAclQueryKey(options),
  });
};

export const encryptionKeyStatusQueryKey = (
  options?: Options<EncryptionKeyStatusData>,
) => createQueryKey('encryptionKeyStatus', options);

/**
 * Provides information about the backend encryption key.
 */
export const encryptionKeyStatusOptions = (
  options?: Options<EncryptionKeyStatusData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await encryptionKeyStatus({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: encryptionKeyStatusQueryKey(options),
  });
};

export const leaderStatusQueryKey = (options?: Options<LeaderStatusData>) =>
  createQueryKey('leaderStatus', options);

/**
 * Returns the high availability status and current leader instance of OpenBao.
 * Check the high availability status and current leader of OpenBao
 */
export const leaderStatusOptions = (options?: Options<LeaderStatusData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await leaderStatus({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: leaderStatusQueryKey(options),
  });
};

export const leasesListQueryKey = (options?: Options<LeasesListData>) =>
  createQueryKey('leasesList', options);

/**
 * List leases associated with this OpenBao cluster
 */
export const leasesListOptions = (options?: Options<LeasesListData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await leasesList({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: leasesListQueryKey(options),
  });
};

export const leasesCountQueryKey = (options?: Options<LeasesCountData>) =>
  createQueryKey('leasesCount', options);

/**
 * Count of leases associated with this OpenBao cluster
 */
export const leasesCountOptions = (options?: Options<LeasesCountData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await leasesCount({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: leasesCountQueryKey(options),
  });
};

/**
 * View or list lease metadata.
 */
export const leasesReadLeaseMutation = (
  options?: Partial<Options<LeasesReadLeaseData>>,
): UseMutationOptions<
  LeasesReadLeaseResponse2,
  DefaultError,
  Options<LeasesReadLeaseData>
> => {
  const mutationOptions: UseMutationOptions<
    LeasesReadLeaseResponse2,
    DefaultError,
    Options<LeasesReadLeaseData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await leasesReadLease({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const leasesLookUpQueryKey = (options: Options<LeasesLookUpData>) =>
  createQueryKey('leasesLookUp', options);

/**
 * View or list lease metadata.
 */
export const leasesLookUpOptions = (options: Options<LeasesLookUpData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await leasesLookUp({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: leasesLookUpQueryKey(options),
  });
};

export const leasesLookUpWithPrefixQueryKey = (
  options: Options<LeasesLookUpWithPrefixData>,
) => createQueryKey('leasesLookUpWithPrefix', options);

/**
 * View or list lease metadata.
 */
export const leasesLookUpWithPrefixOptions = (
  options: Options<LeasesLookUpWithPrefixData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await leasesLookUpWithPrefix({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: leasesLookUpWithPrefixQueryKey(options),
  });
};

/**
 * Renews a lease, requesting to extend the lease.
 * Renew a lease on a secret
 */
export const leasesRenewLeaseMutation = (
  options?: Partial<Options<LeasesRenewLeaseData>>,
): UseMutationOptions<
  LeasesRenewLeaseResponse,
  DefaultError,
  Options<LeasesRenewLeaseData>
> => {
  const mutationOptions: UseMutationOptions<
    LeasesRenewLeaseResponse,
    DefaultError,
    Options<LeasesRenewLeaseData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await leasesRenewLease({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Renews a lease, requesting to extend the lease.
 * Renew a lease on a secret
 */
export const leasesRenewLeaseWithIdMutation = (
  options?: Partial<Options<LeasesRenewLeaseWithIdData>>,
): UseMutationOptions<
  LeasesRenewLeaseWithIdResponse,
  DefaultError,
  Options<LeasesRenewLeaseWithIdData>
> => {
  const mutationOptions: UseMutationOptions<
    LeasesRenewLeaseWithIdResponse,
    DefaultError,
    Options<LeasesRenewLeaseWithIdData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await leasesRenewLeaseWithId({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Revokes a lease immediately.
 * Revoke a leased secret immediately
 */
export const leasesRevokeLeaseMutation = (
  options?: Partial<Options<LeasesRevokeLeaseData>>,
): UseMutationOptions<
  LeasesRevokeLeaseResponse,
  DefaultError,
  Options<LeasesRevokeLeaseData>
> => {
  const mutationOptions: UseMutationOptions<
    LeasesRevokeLeaseResponse,
    DefaultError,
    Options<LeasesRevokeLeaseData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await leasesRevokeLease({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Revokes all secrets or tokens generated under a given prefix immediately
 * Unlike `/sys/leases/revoke-prefix`, this path ignores backend errors encountered during revocation. This is potentially very dangerous and should only be used in specific emergency situations where errors in the backend or the connected backend service prevent normal revocation.
 *
 * By ignoring these errors, OpenBao abdicates responsibility for ensuring that the issued credentials or secrets are properly revoked and/or cleaned up. Access to this endpoint should be tightly controlled.
 */
export const leasesForceRevokeLeaseWithPrefixMutation = (
  options?: Partial<Options<LeasesForceRevokeLeaseWithPrefixData>>,
): UseMutationOptions<
  LeasesForceRevokeLeaseWithPrefixResponse,
  DefaultError,
  Options<LeasesForceRevokeLeaseWithPrefixData>
> => {
  const mutationOptions: UseMutationOptions<
    LeasesForceRevokeLeaseWithPrefixResponse,
    DefaultError,
    Options<LeasesForceRevokeLeaseWithPrefixData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await leasesForceRevokeLeaseWithPrefix({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Revokes all secrets (via a lease ID prefix) or tokens (via the tokens' path property) generated under a given prefix immediately.
 * Revoke all secrets generated in a given prefix
 */
export const leasesRevokeLeaseWithPrefixMutation = (
  options?: Partial<Options<LeasesRevokeLeaseWithPrefixData>>,
): UseMutationOptions<
  LeasesRevokeLeaseWithPrefixResponse,
  DefaultError,
  Options<LeasesRevokeLeaseWithPrefixData>
> => {
  const mutationOptions: UseMutationOptions<
    LeasesRevokeLeaseWithPrefixResponse,
    DefaultError,
    Options<LeasesRevokeLeaseWithPrefixData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await leasesRevokeLeaseWithPrefix({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Revokes a lease immediately.
 * Revoke a leased secret immediately
 */
export const leasesRevokeLeaseWithIdMutation = (
  options?: Partial<Options<LeasesRevokeLeaseWithIdData>>,
): UseMutationOptions<
  LeasesRevokeLeaseWithIdResponse,
  DefaultError,
  Options<LeasesRevokeLeaseWithIdData>
> => {
  const mutationOptions: UseMutationOptions<
    LeasesRevokeLeaseWithIdResponse,
    DefaultError,
    Options<LeasesRevokeLeaseWithIdData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await leasesRevokeLeaseWithId({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * This endpoint performs cleanup tasks that can be run if certain error conditions have occurred.
 */
export const leasesTidyMutation = (
  options?: Partial<Options<LeasesTidyData>>,
): UseMutationOptions<
  LeasesTidyResponse,
  DefaultError,
  Options<LeasesTidyData>
> => {
  const mutationOptions: UseMutationOptions<
    LeasesTidyResponse,
    DefaultError,
    Options<LeasesTidyData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await leasesTidy({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const lockedUsersListQueryKey = (
  options?: Options<LockedUsersListData>,
) => createQueryKey('lockedUsersList', options);

/**
 * Report the locked user count metrics, for this namespace and all child namespaces.
 * Report the locked user count metrics
 */
export const lockedUsersListOptions = (
  options?: Options<LockedUsersListData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await lockedUsersList({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: lockedUsersListQueryKey(options),
  });
};

/**
 * Unlocks the user with given mount_accessor and alias_identifier
 * Unlock the locked user with given mount_accessor and alias_identifier.
 */
export const lockedUsersUnlockMutation = (
  options?: Partial<Options<LockedUsersUnlockData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<LockedUsersUnlockData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<LockedUsersUnlockData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await lockedUsersUnlock({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Revert the all loggers to use log level provided in config.
 */
export const loggersRevertVerbosityLevelMutation = (
  options?: Partial<Options<LoggersRevertVerbosityLevelData>>,
): UseMutationOptions<
  LoggersRevertVerbosityLevelResponse,
  DefaultError,
  Options<LoggersRevertVerbosityLevelData>
> => {
  const mutationOptions: UseMutationOptions<
    LoggersRevertVerbosityLevelResponse,
    DefaultError,
    Options<LoggersRevertVerbosityLevelData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await loggersRevertVerbosityLevel({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const loggersReadVerbosityLevelQueryKey = (
  options?: Options<LoggersReadVerbosityLevelData>,
) => createQueryKey('loggersReadVerbosityLevel', options);

/**
 * Read the log level for all existing loggers.
 */
export const loggersReadVerbosityLevelOptions = (
  options?: Options<LoggersReadVerbosityLevelData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await loggersReadVerbosityLevel({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: loggersReadVerbosityLevelQueryKey(options),
  });
};

/**
 * Modify the log level for all existing loggers.
 */
export const loggersUpdateVerbosityLevelMutation = (
  options?: Partial<Options<LoggersUpdateVerbosityLevelData>>,
): UseMutationOptions<
  LoggersUpdateVerbosityLevelResponse,
  DefaultError,
  Options<LoggersUpdateVerbosityLevelData>
> => {
  const mutationOptions: UseMutationOptions<
    LoggersUpdateVerbosityLevelResponse,
    DefaultError,
    Options<LoggersUpdateVerbosityLevelData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await loggersUpdateVerbosityLevel({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Revert a single logger to use log level provided in config.
 */
export const loggersRevertVerbosityLevelForMutation = (
  options?: Partial<Options<LoggersRevertVerbosityLevelForData>>,
): UseMutationOptions<
  LoggersRevertVerbosityLevelForResponse,
  DefaultError,
  Options<LoggersRevertVerbosityLevelForData>
> => {
  const mutationOptions: UseMutationOptions<
    LoggersRevertVerbosityLevelForResponse,
    DefaultError,
    Options<LoggersRevertVerbosityLevelForData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await loggersRevertVerbosityLevelFor({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const loggersReadVerbosityLevelForQueryKey = (
  options: Options<LoggersReadVerbosityLevelForData>,
) => createQueryKey('loggersReadVerbosityLevelFor', options);

/**
 * Read the log level for a single logger.
 */
export const loggersReadVerbosityLevelForOptions = (
  options: Options<LoggersReadVerbosityLevelForData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await loggersReadVerbosityLevelFor({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: loggersReadVerbosityLevelForQueryKey(options),
  });
};

/**
 * Modify the log level of a single logger.
 */
export const loggersUpdateVerbosityLevelForMutation = (
  options?: Partial<Options<LoggersUpdateVerbosityLevelForData>>,
): UseMutationOptions<
  LoggersUpdateVerbosityLevelForResponse,
  DefaultError,
  Options<LoggersUpdateVerbosityLevelForData>
> => {
  const mutationOptions: UseMutationOptions<
    LoggersUpdateVerbosityLevelForResponse,
    DefaultError,
    Options<LoggersUpdateVerbosityLevelForData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await loggersUpdateVerbosityLevelFor({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const metricsQueryKey = (options?: Options<MetricsData>) =>
  createQueryKey('metrics', options);

/**
 * Export the metrics aggregated for telemetry purpose.
 */
export const metricsOptions = (options?: Options<MetricsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await metrics({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: metricsQueryKey(options),
  });
};

/**
 * Validates the login for the given MFA methods. Upon successful validation, it returns an auth response containing the client token
 */
export const mfaValidateMutation = (
  options?: Partial<Options<MfaValidateData>>,
): UseMutationOptions<unknown, DefaultError, Options<MfaValidateData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<MfaValidateData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await mfaValidate({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const monitorQueryKey = (options?: Options<MonitorData>) =>
  createQueryKey('monitor', options);

export const monitorOptions = (options?: Options<MonitorData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await monitor({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: monitorQueryKey(options),
  });
};

export const mountsListSecretsEnginesQueryKey = (
  options?: Options<MountsListSecretsEnginesData>,
) => createQueryKey('mountsListSecretsEngines', options);

/**
 * List the currently mounted backends.
 */
export const mountsListSecretsEnginesOptions = (
  options?: Options<MountsListSecretsEnginesData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await mountsListSecretsEngines({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: mountsListSecretsEnginesQueryKey(options),
  });
};

/**
 * Disable the mount point specified at the given path.
 * Mount a new backend at a new path.
 */
export const mountsDisableSecretsEngineMutation = (
  options?: Partial<Options<MountsDisableSecretsEngineData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<MountsDisableSecretsEngineData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<MountsDisableSecretsEngineData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await mountsDisableSecretsEngine({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const mountsReadConfigurationQueryKey = (
  options: Options<MountsReadConfigurationData>,
) => createQueryKey('mountsReadConfiguration', options);

/**
 * Read the configuration of the secret engine at the given path.
 * Mount a new backend at a new path.
 */
export const mountsReadConfigurationOptions = (
  options: Options<MountsReadConfigurationData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await mountsReadConfiguration({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: mountsReadConfigurationQueryKey(options),
  });
};

/**
 * Enable a new secrets engine at the given path.
 * Mount a new backend at a new path.
 */
export const mountsEnableSecretsEngineMutation = (
  options?: Partial<Options<MountsEnableSecretsEngineData>>,
): UseMutationOptions<
  MountsEnableSecretsEngineResponse,
  DefaultError,
  Options<MountsEnableSecretsEngineData>
> => {
  const mutationOptions: UseMutationOptions<
    MountsEnableSecretsEngineResponse,
    DefaultError,
    Options<MountsEnableSecretsEngineData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await mountsEnableSecretsEngine({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const mountsReadTuningInformationQueryKey = (
  options: Options<MountsReadTuningInformationData>,
) => createQueryKey('mountsReadTuningInformation', options);

/**
 * Tune backend configuration parameters for this mount.
 */
export const mountsReadTuningInformationOptions = (
  options: Options<MountsReadTuningInformationData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await mountsReadTuningInformation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: mountsReadTuningInformationQueryKey(options),
  });
};

/**
 * Tune backend configuration parameters for this mount.
 */
export const mountsTuneConfigurationParametersMutation = (
  options?: Partial<Options<MountsTuneConfigurationParametersData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<MountsTuneConfigurationParametersData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<MountsTuneConfigurationParametersData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await mountsTuneConfigurationParameters({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const namespacesListNamespacesQueryKey = (
  options: Options<NamespacesListNamespacesData>,
) => createQueryKey('namespacesListNamespaces', options);

/**
 * List namespaces.
 * List namespaces.
 */
export const namespacesListNamespacesOptions = (
  options: Options<NamespacesListNamespacesData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await namespacesListNamespaces({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: namespacesListNamespacesQueryKey(options),
  });
};

/**
 * Lock a namespace.
 * Lock a namespace.
 */
export const namespacesWriteNamespacesApiLockLockMutation = (
  options?: Partial<Options<NamespacesWriteNamespacesApiLockLockData>>,
): UseMutationOptions<
  NamespacesWriteNamespacesApiLockLockResponse2,
  DefaultError,
  Options<NamespacesWriteNamespacesApiLockLockData>
> => {
  const mutationOptions: UseMutationOptions<
    NamespacesWriteNamespacesApiLockLockResponse2,
    DefaultError,
    Options<NamespacesWriteNamespacesApiLockLockData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await namespacesWriteNamespacesApiLockLock({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Lock a namespace.
 * Lock a namespace.
 */
export const namespacesWriteNamespacesApiLockLockPathMutation = (
  options?: Partial<Options<NamespacesWriteNamespacesApiLockLockPathData>>,
): UseMutationOptions<
  NamespacesWriteNamespacesApiLockLockPathResponse2,
  DefaultError,
  Options<NamespacesWriteNamespacesApiLockLockPathData>
> => {
  const mutationOptions: UseMutationOptions<
    NamespacesWriteNamespacesApiLockLockPathResponse2,
    DefaultError,
    Options<NamespacesWriteNamespacesApiLockLockPathData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await namespacesWriteNamespacesApiLockLockPath({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Unlock a namespace.
 * Unlock a namespace.
 */
export const namespacesWriteNamespacesApiLockUnlockMutation = (
  options?: Partial<Options<NamespacesWriteNamespacesApiLockUnlockData>>,
): UseMutationOptions<
  NamespacesWriteNamespacesApiLockUnlockResponse,
  DefaultError,
  Options<NamespacesWriteNamespacesApiLockUnlockData>
> => {
  const mutationOptions: UseMutationOptions<
    NamespacesWriteNamespacesApiLockUnlockResponse,
    DefaultError,
    Options<NamespacesWriteNamespacesApiLockUnlockData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await namespacesWriteNamespacesApiLockUnlock({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Unlock a namespace.
 * Unlock a namespace.
 */
export const namespacesWriteNamespacesApiLockUnlockPathMutation = (
  options?: Partial<Options<NamespacesWriteNamespacesApiLockUnlockPathData>>,
): UseMutationOptions<
  NamespacesWriteNamespacesApiLockUnlockPathResponse,
  DefaultError,
  Options<NamespacesWriteNamespacesApiLockUnlockPathData>
> => {
  const mutationOptions: UseMutationOptions<
    NamespacesWriteNamespacesApiLockUnlockPathResponse,
    DefaultError,
    Options<NamespacesWriteNamespacesApiLockUnlockPathData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await namespacesWriteNamespacesApiLockUnlockPath({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete a namespace.
 * Create, read, update and delete namespaces.
 */
export const namespacesDeleteNamespacesPathMutation = (
  options?: Partial<Options<NamespacesDeleteNamespacesPathData>>,
): UseMutationOptions<
  NamespacesDeleteNamespacesPathResponse2,
  DefaultError,
  Options<NamespacesDeleteNamespacesPathData>
> => {
  const mutationOptions: UseMutationOptions<
    NamespacesDeleteNamespacesPathResponse2,
    DefaultError,
    Options<NamespacesDeleteNamespacesPathData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await namespacesDeleteNamespacesPath({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const namespacesReadNamespacesPathQueryKey = (
  options: Options<NamespacesReadNamespacesPathData>,
) => createQueryKey('namespacesReadNamespacesPath', options);

/**
 * Retrieve a namespace.
 * Create, read, update and delete namespaces.
 */
export const namespacesReadNamespacesPathOptions = (
  options: Options<NamespacesReadNamespacesPathData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await namespacesReadNamespacesPath({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: namespacesReadNamespacesPathQueryKey(options),
  });
};

/**
 * Create or update a namespace.
 * Create, read, update and delete namespaces.
 */
export const namespacesWriteNamespacesPathMutation = (
  options?: Partial<Options<NamespacesWriteNamespacesPathData>>,
): UseMutationOptions<
  NamespacesWriteNamespacesPathResponse2,
  DefaultError,
  Options<NamespacesWriteNamespacesPathData>
> => {
  const mutationOptions: UseMutationOptions<
    NamespacesWriteNamespacesPathResponse2,
    DefaultError,
    Options<NamespacesWriteNamespacesPathData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await namespacesWriteNamespacesPath({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const pluginsCatalogListPluginsQueryKey = (
  options?: Options<PluginsCatalogListPluginsData>,
) => createQueryKey('pluginsCatalogListPlugins', options);

/**
 * Lists all the plugins known to OpenBao
 */
export const pluginsCatalogListPluginsOptions = (
  options?: Options<PluginsCatalogListPluginsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await pluginsCatalogListPlugins({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: pluginsCatalogListPluginsQueryKey(options),
  });
};

/**
 * Remove the plugin with the given name.
 * Configures the plugins known to OpenBao
 */
export const pluginsCatalogRemovePluginMutation = (
  options?: Partial<Options<PluginsCatalogRemovePluginData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<PluginsCatalogRemovePluginData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<PluginsCatalogRemovePluginData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await pluginsCatalogRemovePlugin({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const pluginsCatalogReadPluginConfigurationQueryKey = (
  options: Options<PluginsCatalogReadPluginConfigurationData>,
) => createQueryKey('pluginsCatalogReadPluginConfiguration', options);

/**
 * Return the configuration data for the plugin with the given name.
 * Configures the plugins known to OpenBao
 */
export const pluginsCatalogReadPluginConfigurationOptions = (
  options: Options<PluginsCatalogReadPluginConfigurationData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await pluginsCatalogReadPluginConfiguration({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: pluginsCatalogReadPluginConfigurationQueryKey(options),
  });
};

/**
 * Register a new plugin, or updates an existing one with the supplied name.
 * Configures the plugins known to OpenBao
 */
export const pluginsCatalogRegisterPluginMutation = (
  options?: Partial<Options<PluginsCatalogRegisterPluginData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<PluginsCatalogRegisterPluginData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<PluginsCatalogRegisterPluginData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await pluginsCatalogRegisterPlugin({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const pluginsCatalogListPluginsWithTypeQueryKey = (
  options: Options<PluginsCatalogListPluginsWithTypeData>,
) => createQueryKey('pluginsCatalogListPluginsWithType', options);

/**
 * List the plugins in the catalog.
 * Configures the plugins known to OpenBao
 */
export const pluginsCatalogListPluginsWithTypeOptions = (
  options: Options<PluginsCatalogListPluginsWithTypeData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await pluginsCatalogListPluginsWithType({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: pluginsCatalogListPluginsWithTypeQueryKey(options),
  });
};

/**
 * Remove the plugin with the given name.
 * Configures the plugins known to OpenBao
 */
export const pluginsCatalogRemovePluginWithTypeMutation = (
  options?: Partial<Options<PluginsCatalogRemovePluginWithTypeData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<PluginsCatalogRemovePluginWithTypeData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<PluginsCatalogRemovePluginWithTypeData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await pluginsCatalogRemovePluginWithType({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const pluginsCatalogReadPluginConfigurationWithTypeQueryKey = (
  options: Options<PluginsCatalogReadPluginConfigurationWithTypeData>,
) => createQueryKey('pluginsCatalogReadPluginConfigurationWithType', options);

/**
 * Return the configuration data for the plugin with the given name.
 * Configures the plugins known to OpenBao
 */
export const pluginsCatalogReadPluginConfigurationWithTypeOptions = (
  options: Options<PluginsCatalogReadPluginConfigurationWithTypeData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await pluginsCatalogReadPluginConfigurationWithType({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: pluginsCatalogReadPluginConfigurationWithTypeQueryKey(options),
  });
};

/**
 * Register a new plugin, or updates an existing one with the supplied name.
 * Configures the plugins known to OpenBao
 */
export const pluginsCatalogRegisterPluginWithTypeMutation = (
  options?: Partial<Options<PluginsCatalogRegisterPluginWithTypeData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<PluginsCatalogRegisterPluginWithTypeData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<PluginsCatalogRegisterPluginWithTypeData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await pluginsCatalogRegisterPluginWithType({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Reload mounted plugin backends.
 * Either the plugin name (`plugin`) or the desired plugin backend mounts (`mounts`) must be provided, but not both. In the case that the plugin name is provided, all mounted paths that use that plugin backend will be reloaded.  If (`scope`) is provided and is (`global`), the plugin(s) are reloaded globally.
 */
export const pluginsReloadBackendsMutation = (
  options?: Partial<Options<PluginsReloadBackendsData>>,
): UseMutationOptions<
  PluginsReloadBackendsResponse2,
  DefaultError,
  Options<PluginsReloadBackendsData>
> => {
  const mutationOptions: UseMutationOptions<
    PluginsReloadBackendsResponse2,
    DefaultError,
    Options<PluginsReloadBackendsData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await pluginsReloadBackends({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const policiesListAclPoliciesQueryKey = (
  options: Options<PoliciesListAclPoliciesData>,
) => createQueryKey('policiesListAclPolicies', options);

/**
 * List the configured access control policies.
 */
export const policiesListAclPoliciesOptions = (
  options: Options<PoliciesListAclPoliciesData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await policiesListAclPolicies({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: policiesListAclPoliciesQueryKey(options),
  });
};

/**
 * Delete the ACL policy with the given name.
 * Read, Modify, or Delete an access control policy.
 */
export const policiesDeleteAclPolicyMutation = (
  options?: Partial<Options<PoliciesDeleteAclPolicyData>>,
): UseMutationOptions<
  PoliciesDeleteAclPolicyResponse,
  DefaultError,
  Options<PoliciesDeleteAclPolicyData>
> => {
  const mutationOptions: UseMutationOptions<
    PoliciesDeleteAclPolicyResponse,
    DefaultError,
    Options<PoliciesDeleteAclPolicyData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await policiesDeleteAclPolicy({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const policiesReadAclPolicyQueryKey = (
  options: Options<PoliciesReadAclPolicyData>,
) => createQueryKey('policiesReadAclPolicy', options);

/**
 * Retrieve information about the named ACL policy.
 * Read, Modify, or Delete an access control policy.
 */
export const policiesReadAclPolicyOptions = (
  options: Options<PoliciesReadAclPolicyData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await policiesReadAclPolicy({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: policiesReadAclPolicyQueryKey(options),
  });
};

/**
 * Add a new or update an existing ACL policy.
 * Read, Modify, or Delete an access control policy.
 */
export const policiesWriteAclPolicyMutation = (
  options?: Partial<Options<PoliciesWriteAclPolicyData>>,
): UseMutationOptions<
  PoliciesWriteAclPolicyResponse,
  DefaultError,
  Options<PoliciesWriteAclPolicyData>
> => {
  const mutationOptions: UseMutationOptions<
    PoliciesWriteAclPolicyResponse,
    DefaultError,
    Options<PoliciesWriteAclPolicyData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await policiesWriteAclPolicy({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const systemListPoliciesDetailedAclQueryKey = (
  options: Options<SystemListPoliciesDetailedAclData>,
) => createQueryKey('systemListPoliciesDetailedAcl', options);

/**
 * List ACL policies with detailed information.
 */
export const systemListPoliciesDetailedAclOptions = (
  options: Options<SystemListPoliciesDetailedAclData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await systemListPoliciesDetailedAcl({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: systemListPoliciesDetailedAclQueryKey(options),
  });
};

export const policiesListPasswordPoliciesQueryKey = (
  options: Options<PoliciesListPasswordPoliciesData>,
) => createQueryKey('policiesListPasswordPolicies', options);

/**
 * List the existing password policies.
 */
export const policiesListPasswordPoliciesOptions = (
  options: Options<PoliciesListPasswordPoliciesData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await policiesListPasswordPolicies({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: policiesListPasswordPoliciesQueryKey(options),
  });
};

/**
 * Delete a password policy.
 * Read, Modify, or Delete a password policy.
 */
export const policiesDeletePasswordPolicyMutation = (
  options?: Partial<Options<PoliciesDeletePasswordPolicyData>>,
): UseMutationOptions<
  PoliciesDeletePasswordPolicyResponse,
  DefaultError,
  Options<PoliciesDeletePasswordPolicyData>
> => {
  const mutationOptions: UseMutationOptions<
    PoliciesDeletePasswordPolicyResponse,
    DefaultError,
    Options<PoliciesDeletePasswordPolicyData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await policiesDeletePasswordPolicy({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const policiesReadPasswordPolicyQueryKey = (
  options: Options<PoliciesReadPasswordPolicyData>,
) => createQueryKey('policiesReadPasswordPolicy', options);

/**
 * Retrieve an existing password policy.
 * Read, Modify, or Delete a password policy.
 */
export const policiesReadPasswordPolicyOptions = (
  options: Options<PoliciesReadPasswordPolicyData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await policiesReadPasswordPolicy({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: policiesReadPasswordPolicyQueryKey(options),
  });
};

/**
 * Add a new or update an existing password policy.
 * Read, Modify, or Delete a password policy.
 */
export const policiesWritePasswordPolicyMutation = (
  options?: Partial<Options<PoliciesWritePasswordPolicyData>>,
): UseMutationOptions<
  PoliciesWritePasswordPolicyResponse,
  DefaultError,
  Options<PoliciesWritePasswordPolicyData>
> => {
  const mutationOptions: UseMutationOptions<
    PoliciesWritePasswordPolicyResponse,
    DefaultError,
    Options<PoliciesWritePasswordPolicyData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await policiesWritePasswordPolicy({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const policiesGeneratePasswordFromPasswordPolicyQueryKey = (
  options: Options<PoliciesGeneratePasswordFromPasswordPolicyData>,
) => createQueryKey('policiesGeneratePasswordFromPasswordPolicy', options);

/**
 * Generate a password from an existing password policy.
 * Generate a password from an existing password policy.
 */
export const policiesGeneratePasswordFromPasswordPolicyOptions = (
  options: Options<PoliciesGeneratePasswordFromPasswordPolicyData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await policiesGeneratePasswordFromPasswordPolicy({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: policiesGeneratePasswordFromPasswordPolicyQueryKey(options),
  });
};

export const policiesListQueryKey = (options?: Options<PoliciesListData>) =>
  createQueryKey('policiesList', options);

/**
 * List the configured access control policies.
 */
export const policiesListOptions = (options?: Options<PoliciesListData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await policiesList({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: policiesListQueryKey(options),
  });
};

/**
 * Delete the policy with the given name.
 * Read, Modify, or Delete an access control policy.
 */
export const policiesDeleteAclPolicy2Mutation = (
  options?: Partial<Options<PoliciesDeleteAclPolicy2Data>>,
): UseMutationOptions<
  PoliciesDeleteAclPolicy2Response,
  DefaultError,
  Options<PoliciesDeleteAclPolicy2Data>
> => {
  const mutationOptions: UseMutationOptions<
    PoliciesDeleteAclPolicy2Response,
    DefaultError,
    Options<PoliciesDeleteAclPolicy2Data>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await policiesDeleteAclPolicy2({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const policiesReadAclPolicy2QueryKey = (
  options: Options<PoliciesReadAclPolicy2Data>,
) => createQueryKey('policiesReadAclPolicy2', options);

/**
 * Retrieve the policy body for the named policy.
 * Read, Modify, or Delete an access control policy.
 */
export const policiesReadAclPolicy2Options = (
  options: Options<PoliciesReadAclPolicy2Data>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await policiesReadAclPolicy2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: policiesReadAclPolicy2QueryKey(options),
  });
};

/**
 * Add a new or update an existing policy.
 * Read, Modify, or Delete an access control policy.
 */
export const policiesWriteAclPolicy2Mutation = (
  options?: Partial<Options<PoliciesWriteAclPolicy2Data>>,
): UseMutationOptions<
  PoliciesWriteAclPolicy2Response,
  DefaultError,
  Options<PoliciesWriteAclPolicy2Data>
> => {
  const mutationOptions: UseMutationOptions<
    PoliciesWriteAclPolicy2Response,
    DefaultError,
    Options<PoliciesWriteAclPolicy2Data>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await policiesWriteAclPolicy2({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const pprofIndexQueryKey = (options?: Options<PprofIndexData>) =>
  createQueryKey('pprofIndex', options);

/**
 * Returns an HTML page listing the available profiles.
 * Returns an HTML page listing the available
 * profiles. This should be mainly accessed via browsers or applications that can
 * render pages.
 */
export const pprofIndexOptions = (options?: Options<PprofIndexData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await pprofIndex({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: pprofIndexQueryKey(options),
  });
};

export const pprofMemoryAllocationsQueryKey = (
  options?: Options<PprofMemoryAllocationsData>,
) => createQueryKey('pprofMemoryAllocations', options);

/**
 * Returns a sampling of all past memory allocations.
 * Returns a sampling of all past memory allocations.
 */
export const pprofMemoryAllocationsOptions = (
  options?: Options<PprofMemoryAllocationsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await pprofMemoryAllocations({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: pprofMemoryAllocationsQueryKey(options),
  });
};

export const pprofBlockingQueryKey = (options?: Options<PprofBlockingData>) =>
  createQueryKey('pprofBlocking', options);

/**
 * Returns stack traces that led to blocking on synchronization primitives
 * Returns stack traces that led to blocking on synchronization primitives
 */
export const pprofBlockingOptions = (options?: Options<PprofBlockingData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await pprofBlocking({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: pprofBlockingQueryKey(options),
  });
};

export const pprofCommandLineQueryKey = (
  options?: Options<PprofCommandLineData>,
) => createQueryKey('pprofCommandLine', options);

/**
 * Returns the running program's command line.
 * Returns the running program's command line, with arguments separated by NUL bytes.
 */
export const pprofCommandLineOptions = (
  options?: Options<PprofCommandLineData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await pprofCommandLine({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: pprofCommandLineQueryKey(options),
  });
};

export const pprofGoroutinesQueryKey = (
  options?: Options<PprofGoroutinesData>,
) => createQueryKey('pprofGoroutines', options);

/**
 * Returns stack traces of all current goroutines.
 * Returns stack traces of all current goroutines.
 */
export const pprofGoroutinesOptions = (
  options?: Options<PprofGoroutinesData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await pprofGoroutines({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: pprofGoroutinesQueryKey(options),
  });
};

export const pprofMemoryAllocationsLiveQueryKey = (
  options?: Options<PprofMemoryAllocationsLiveData>,
) => createQueryKey('pprofMemoryAllocationsLive', options);

/**
 * Returns a sampling of memory allocations of live object.
 * Returns a sampling of memory allocations of live object.
 */
export const pprofMemoryAllocationsLiveOptions = (
  options?: Options<PprofMemoryAllocationsLiveData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await pprofMemoryAllocationsLive({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: pprofMemoryAllocationsLiveQueryKey(options),
  });
};

export const pprofMutexesQueryKey = (options?: Options<PprofMutexesData>) =>
  createQueryKey('pprofMutexes', options);

/**
 * Returns stack traces of holders of contended mutexes
 * Returns stack traces of holders of contended mutexes
 */
export const pprofMutexesOptions = (options?: Options<PprofMutexesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await pprofMutexes({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: pprofMutexesQueryKey(options),
  });
};

export const pprofCpuProfileQueryKey = (
  options?: Options<PprofCpuProfileData>,
) => createQueryKey('pprofCpuProfile', options);

/**
 * Returns a pprof-formatted cpu profile payload.
 * Returns a pprof-formatted cpu profile payload. Profiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified.
 */
export const pprofCpuProfileOptions = (
  options?: Options<PprofCpuProfileData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await pprofCpuProfile({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: pprofCpuProfileQueryKey(options),
  });
};

export const pprofSymbolsQueryKey = (options?: Options<PprofSymbolsData>) =>
  createQueryKey('pprofSymbols', options);

/**
 * Returns the program counters listed in the request.
 * Returns the program counters listed in the request.
 */
export const pprofSymbolsOptions = (options?: Options<PprofSymbolsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await pprofSymbols({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: pprofSymbolsQueryKey(options),
  });
};

export const pprofThreadCreationsQueryKey = (
  options?: Options<PprofThreadCreationsData>,
) => createQueryKey('pprofThreadCreations', options);

/**
 * Returns stack traces that led to the creation of new OS threads
 * Returns stack traces that led to the creation of new OS threads
 */
export const pprofThreadCreationsOptions = (
  options?: Options<PprofThreadCreationsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await pprofThreadCreations({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: pprofThreadCreationsQueryKey(options),
  });
};

export const pprofExecutionTraceQueryKey = (
  options?: Options<PprofExecutionTraceData>,
) => createQueryKey('pprofExecutionTrace', options);

/**
 * Returns the execution trace in binary form.
 * Returns  the execution trace in binary form. Tracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified.
 */
export const pprofExecutionTraceOptions = (
  options?: Options<PprofExecutionTraceData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await pprofExecutionTrace({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: pprofExecutionTraceQueryKey(options),
  });
};

export const rateLimitQuotasReadConfigurationQueryKey = (
  options?: Options<RateLimitQuotasReadConfigurationData>,
) => createQueryKey('rateLimitQuotasReadConfiguration', options);

/**
 * Create, update and read the quota configuration.
 */
export const rateLimitQuotasReadConfigurationOptions = (
  options?: Options<RateLimitQuotasReadConfigurationData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await rateLimitQuotasReadConfiguration({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: rateLimitQuotasReadConfigurationQueryKey(options),
  });
};

/**
 * Create, update and read the quota configuration.
 */
export const rateLimitQuotasConfigureMutation = (
  options?: Partial<Options<RateLimitQuotasConfigureData>>,
): UseMutationOptions<
  RateLimitQuotasConfigureResponse,
  DefaultError,
  Options<RateLimitQuotasConfigureData>
> => {
  const mutationOptions: UseMutationOptions<
    RateLimitQuotasConfigureResponse,
    DefaultError,
    Options<RateLimitQuotasConfigureData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await rateLimitQuotasConfigure({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const rateLimitQuotasListQueryKey = (
  options: Options<RateLimitQuotasListData>,
) => createQueryKey('rateLimitQuotasList', options);

/**
 * Lists the names of all the rate limit quotas.
 */
export const rateLimitQuotasListOptions = (
  options: Options<RateLimitQuotasListData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await rateLimitQuotasList({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: rateLimitQuotasListQueryKey(options),
  });
};

/**
 * Get, create or update rate limit resource quota for an optional namespace or mount.
 */
export const rateLimitQuotasDeleteMutation = (
  options?: Partial<Options<RateLimitQuotasDeleteData>>,
): UseMutationOptions<
  RateLimitQuotasDeleteResponse,
  DefaultError,
  Options<RateLimitQuotasDeleteData>
> => {
  const mutationOptions: UseMutationOptions<
    RateLimitQuotasDeleteResponse,
    DefaultError,
    Options<RateLimitQuotasDeleteData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await rateLimitQuotasDelete({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const rateLimitQuotasReadQueryKey = (
  options: Options<RateLimitQuotasReadData>,
) => createQueryKey('rateLimitQuotasRead', options);

/**
 * Get, create or update rate limit resource quota for an optional namespace or mount.
 */
export const rateLimitQuotasReadOptions = (
  options: Options<RateLimitQuotasReadData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await rateLimitQuotasRead({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: rateLimitQuotasReadQueryKey(options),
  });
};

/**
 * Get, create or update rate limit resource quota for an optional namespace or mount.
 */
export const rateLimitQuotasWriteMutation = (
  options?: Partial<Options<RateLimitQuotasWriteData>>,
): UseMutationOptions<
  RateLimitQuotasWriteResponse,
  DefaultError,
  Options<RateLimitQuotasWriteData>
> => {
  const mutationOptions: UseMutationOptions<
    RateLimitQuotasWriteResponse,
    DefaultError,
    Options<RateLimitQuotasWriteData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await rateLimitQuotasWrite({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete the key with given path.
 * Write, Read, and Delete data directly in the Storage backend.
 */
export const rawDeleteMutation = (
  options?: Partial<Options<RawDeleteData>>,
): UseMutationOptions<
  RawDeleteResponse,
  DefaultError,
  Options<RawDeleteData>
> => {
  const mutationOptions: UseMutationOptions<
    RawDeleteResponse,
    DefaultError,
    Options<RawDeleteData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await rawDelete({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const rawReadQueryKey = (options?: Options<RawReadData>) =>
  createQueryKey('rawRead', options);

/**
 * Read the value of the key at the given path.
 * Write, Read, and Delete data directly in the Storage backend.
 */
export const rawReadOptions = (options?: Options<RawReadData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await rawRead({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: rawReadQueryKey(options),
  });
};

/**
 * Update the value of the key at the given path.
 * Write, Read, and Delete data directly in the Storage backend.
 */
export const rawWriteMutation = (
  options?: Partial<Options<RawWriteData>>,
): UseMutationOptions<unknown, DefaultError, Options<RawWriteData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<RawWriteData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await rawWrite({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete the key with given path.
 * Write, Read, and Delete data directly in the Storage backend.
 */
export const rawDeletePathMutation = (
  options?: Partial<Options<RawDeletePathData>>,
): UseMutationOptions<
  RawDeletePathResponse,
  DefaultError,
  Options<RawDeletePathData>
> => {
  const mutationOptions: UseMutationOptions<
    RawDeletePathResponse,
    DefaultError,
    Options<RawDeletePathData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await rawDeletePath({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const rawReadPathQueryKey = (options: Options<RawReadPathData>) =>
  createQueryKey('rawReadPath', options);

/**
 * Read the value of the key at the given path.
 * Write, Read, and Delete data directly in the Storage backend.
 */
export const rawReadPathOptions = (options: Options<RawReadPathData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await rawReadPath({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: rawReadPathQueryKey(options),
  });
};

/**
 * Update the value of the key at the given path.
 * Write, Read, and Delete data directly in the Storage backend.
 */
export const rawWritePathMutation = (
  options?: Partial<Options<RawWritePathData>>,
): UseMutationOptions<unknown, DefaultError, Options<RawWritePathData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<RawWritePathData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await rawWritePath({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete the backup copy of PGP-encrypted unseal keys.
 * Allows fetching or deleting the backup of the rotated unseal keys.
 */
export const rekeyDeleteBackupKeyMutation = (
  options?: Partial<Options<RekeyDeleteBackupKeyData>>,
): UseMutationOptions<
  RekeyDeleteBackupKeyResponse,
  DefaultError,
  Options<RekeyDeleteBackupKeyData>
> => {
  const mutationOptions: UseMutationOptions<
    RekeyDeleteBackupKeyResponse,
    DefaultError,
    Options<RekeyDeleteBackupKeyData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await rekeyDeleteBackupKey({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const rekeyReadBackupKeyQueryKey = (
  options?: Options<RekeyReadBackupKeyData>,
) => createQueryKey('rekeyReadBackupKey', options);

/**
 * Return the backup copy of PGP-encrypted unseal keys.
 * Allows fetching or deleting the backup of the rotated unseal keys.
 */
export const rekeyReadBackupKeyOptions = (
  options?: Options<RekeyReadBackupKeyData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await rekeyReadBackupKey({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: rekeyReadBackupKeyQueryKey(options),
  });
};

/**
 * Cancels any in-progress rekey.
 * This clears the rekey settings as well as any progress made. This must be called to change the parameters of the rekey. Note: verification is still a part of a rekey. If rekeying is canceled during the verification flow, the current unseal keys remain valid.
 */
export const rekeyAttemptCancelMutation = (
  options?: Partial<Options<RekeyAttemptCancelData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<RekeyAttemptCancelData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<RekeyAttemptCancelData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await rekeyAttemptCancel({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const rekeyAttemptReadProgressQueryKey = (
  options?: Options<RekeyAttemptReadProgressData>,
) => createQueryKey('rekeyAttemptReadProgress', options);

/**
 * Reads the configuration and progress of the current rekey attempt.
 */
export const rekeyAttemptReadProgressOptions = (
  options?: Options<RekeyAttemptReadProgressData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await rekeyAttemptReadProgress({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: rekeyAttemptReadProgressQueryKey(options),
  });
};

/**
 * Initializes a new rekey attempt.
 * Only a single rekey attempt can take place at a time, and changing the parameters of a rekey requires canceling and starting a new rekey, which will also provide a new nonce.
 */
export const rekeyAttemptInitializeMutation = (
  options?: Partial<Options<RekeyAttemptInitializeData>>,
): UseMutationOptions<
  RekeyAttemptInitializeResponse2,
  DefaultError,
  Options<RekeyAttemptInitializeData>
> => {
  const mutationOptions: UseMutationOptions<
    RekeyAttemptInitializeResponse2,
    DefaultError,
    Options<RekeyAttemptInitializeData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await rekeyAttemptInitialize({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Allows fetching or deleting the backup of the rotated unseal keys.
 */
export const rekeyDeleteBackupRecoveryKeyMutation = (
  options?: Partial<Options<RekeyDeleteBackupRecoveryKeyData>>,
): UseMutationOptions<
  RekeyDeleteBackupRecoveryKeyResponse,
  DefaultError,
  Options<RekeyDeleteBackupRecoveryKeyData>
> => {
  const mutationOptions: UseMutationOptions<
    RekeyDeleteBackupRecoveryKeyResponse,
    DefaultError,
    Options<RekeyDeleteBackupRecoveryKeyData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await rekeyDeleteBackupRecoveryKey({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const rekeyReadBackupRecoveryKeyQueryKey = (
  options?: Options<RekeyReadBackupRecoveryKeyData>,
) => createQueryKey('rekeyReadBackupRecoveryKey', options);

/**
 * Allows fetching or deleting the backup of the rotated unseal keys.
 */
export const rekeyReadBackupRecoveryKeyOptions = (
  options?: Options<RekeyReadBackupRecoveryKeyData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await rekeyReadBackupRecoveryKey({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: rekeyReadBackupRecoveryKeyQueryKey(options),
  });
};

/**
 * Enter a single unseal key share to progress the rekey of the OpenBao.
 */
export const rekeyAttemptUpdateMutation = (
  options?: Partial<Options<RekeyAttemptUpdateData>>,
): UseMutationOptions<
  RekeyAttemptUpdateResponse2,
  DefaultError,
  Options<RekeyAttemptUpdateData>
> => {
  const mutationOptions: UseMutationOptions<
    RekeyAttemptUpdateResponse2,
    DefaultError,
    Options<RekeyAttemptUpdateData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await rekeyAttemptUpdate({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Cancel any in-progress rekey verification operation.
 * This clears any progress made and resets the nonce. Unlike a `DELETE` against `sys/rekey/init`, this only resets the current verification operation, not the entire rekey atttempt.
 */
export const rekeyVerificationCancelMutation = (
  options?: Partial<Options<RekeyVerificationCancelData>>,
): UseMutationOptions<
  RekeyVerificationCancelResponse2,
  DefaultError,
  Options<RekeyVerificationCancelData>
> => {
  const mutationOptions: UseMutationOptions<
    RekeyVerificationCancelResponse2,
    DefaultError,
    Options<RekeyVerificationCancelData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await rekeyVerificationCancel({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const rekeyVerificationReadProgressQueryKey = (
  options?: Options<RekeyVerificationReadProgressData>,
) => createQueryKey('rekeyVerificationReadProgress', options);

/**
 * Read the configuration and progress of the current rekey verification attempt.
 */
export const rekeyVerificationReadProgressOptions = (
  options?: Options<RekeyVerificationReadProgressData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await rekeyVerificationReadProgress({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: rekeyVerificationReadProgressQueryKey(options),
  });
};

/**
 * Enter a single new key share to progress the rekey verification operation.
 */
export const rekeyVerificationUpdateMutation = (
  options?: Partial<Options<RekeyVerificationUpdateData>>,
): UseMutationOptions<
  RekeyVerificationUpdateResponse2,
  DefaultError,
  Options<RekeyVerificationUpdateData>
> => {
  const mutationOptions: UseMutationOptions<
    RekeyVerificationUpdateResponse2,
    DefaultError,
    Options<RekeyVerificationUpdateData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await rekeyVerificationUpdate({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Initiate a mount migration
 * Move the mount point of an already-mounted backend, within or across namespaces
 */
export const remountMutation = (
  options?: Partial<Options<RemountData>>,
): UseMutationOptions<RemountResponse2, DefaultError, Options<RemountData>> => {
  const mutationOptions: UseMutationOptions<
    RemountResponse2,
    DefaultError,
    Options<RemountData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await remount({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const remountStatusQueryKey = (options: Options<RemountStatusData>) =>
  createQueryKey('remountStatus', options);

/**
 * Check status of a mount migration
 * Check the status of a mount move operation
 */
export const remountStatusOptions = (options: Options<RemountStatusData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await remountStatus({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: remountStatusQueryKey(options),
  });
};

/**
 * Renews a lease, requesting to extend the lease.
 * Renew a lease on a secret
 */
export const leasesRenewLease2Mutation = (
  options?: Partial<Options<LeasesRenewLease2Data>>,
): UseMutationOptions<
  LeasesRenewLease2Response,
  DefaultError,
  Options<LeasesRenewLease2Data>
> => {
  const mutationOptions: UseMutationOptions<
    LeasesRenewLease2Response,
    DefaultError,
    Options<LeasesRenewLease2Data>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await leasesRenewLease2({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Renews a lease, requesting to extend the lease.
 * Renew a lease on a secret
 */
export const leasesRenewLeaseWithId2Mutation = (
  options?: Partial<Options<LeasesRenewLeaseWithId2Data>>,
): UseMutationOptions<
  LeasesRenewLeaseWithId2Response,
  DefaultError,
  Options<LeasesRenewLeaseWithId2Data>
> => {
  const mutationOptions: UseMutationOptions<
    LeasesRenewLeaseWithId2Response,
    DefaultError,
    Options<LeasesRenewLeaseWithId2Data>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await leasesRenewLeaseWithId2({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Revokes a lease immediately.
 * Revoke a leased secret immediately
 */
export const leasesRevokeLease2Mutation = (
  options?: Partial<Options<LeasesRevokeLease2Data>>,
): UseMutationOptions<
  LeasesRevokeLease2Response,
  DefaultError,
  Options<LeasesRevokeLease2Data>
> => {
  const mutationOptions: UseMutationOptions<
    LeasesRevokeLease2Response,
    DefaultError,
    Options<LeasesRevokeLease2Data>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await leasesRevokeLease2({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Revokes all secrets or tokens generated under a given prefix immediately
 * Unlike `/sys/leases/revoke-prefix`, this path ignores backend errors encountered during revocation. This is potentially very dangerous and should only be used in specific emergency situations where errors in the backend or the connected backend service prevent normal revocation.
 *
 * By ignoring these errors, OpenBao abdicates responsibility for ensuring that the issued credentials or secrets are properly revoked and/or cleaned up. Access to this endpoint should be tightly controlled.
 */
export const leasesForceRevokeLeaseWithPrefix2Mutation = (
  options?: Partial<Options<LeasesForceRevokeLeaseWithPrefix2Data>>,
): UseMutationOptions<
  LeasesForceRevokeLeaseWithPrefix2Response,
  DefaultError,
  Options<LeasesForceRevokeLeaseWithPrefix2Data>
> => {
  const mutationOptions: UseMutationOptions<
    LeasesForceRevokeLeaseWithPrefix2Response,
    DefaultError,
    Options<LeasesForceRevokeLeaseWithPrefix2Data>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await leasesForceRevokeLeaseWithPrefix2({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Revokes all secrets (via a lease ID prefix) or tokens (via the tokens' path property) generated under a given prefix immediately.
 * Revoke all secrets generated in a given prefix
 */
export const leasesRevokeLeaseWithPrefix2Mutation = (
  options?: Partial<Options<LeasesRevokeLeaseWithPrefix2Data>>,
): UseMutationOptions<
  LeasesRevokeLeaseWithPrefix2Response,
  DefaultError,
  Options<LeasesRevokeLeaseWithPrefix2Data>
> => {
  const mutationOptions: UseMutationOptions<
    LeasesRevokeLeaseWithPrefix2Response,
    DefaultError,
    Options<LeasesRevokeLeaseWithPrefix2Data>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await leasesRevokeLeaseWithPrefix2({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Revokes a lease immediately.
 * Revoke a leased secret immediately
 */
export const leasesRevokeLeaseWithId2Mutation = (
  options?: Partial<Options<LeasesRevokeLeaseWithId2Data>>,
): UseMutationOptions<
  LeasesRevokeLeaseWithId2Response,
  DefaultError,
  Options<LeasesRevokeLeaseWithId2Data>
> => {
  const mutationOptions: UseMutationOptions<
    LeasesRevokeLeaseWithId2Response,
    DefaultError,
    Options<LeasesRevokeLeaseWithId2Data>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await leasesRevokeLeaseWithId2({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Rotates the backend encryption key used to persist data.
 */
export const encryptionKeyRotateMutation = (
  options?: Partial<Options<EncryptionKeyRotateData>>,
): UseMutationOptions<
  EncryptionKeyRotateResponse,
  DefaultError,
  Options<EncryptionKeyRotateData>
> => {
  const mutationOptions: UseMutationOptions<
    EncryptionKeyRotateResponse,
    DefaultError,
    Options<EncryptionKeyRotateData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await encryptionKeyRotate({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const encryptionKeyReadRotationConfigurationQueryKey = (
  options?: Options<EncryptionKeyReadRotationConfigurationData>,
) => createQueryKey('encryptionKeyReadRotationConfiguration', options);

export const encryptionKeyReadRotationConfigurationOptions = (
  options?: Options<EncryptionKeyReadRotationConfigurationData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await encryptionKeyReadRotationConfiguration({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: encryptionKeyReadRotationConfigurationQueryKey(options),
  });
};

export const encryptionKeyConfigureRotationConfigurationMutation = (
  options?: Partial<Options<EncryptionKeyConfigureRotationConfigurationData>>,
): UseMutationOptions<
  EncryptionKeyConfigureRotationConfigurationResponse,
  DefaultError,
  Options<EncryptionKeyConfigureRotationConfigurationData>
> => {
  const mutationOptions: UseMutationOptions<
    EncryptionKeyConfigureRotationConfigurationResponse,
    DefaultError,
    Options<EncryptionKeyConfigureRotationConfigurationData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await encryptionKeyConfigureRotationConfiguration({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Rotates the backend encryption key used to persist data.
 */
export const encryptionKeyRotateRotateKeyringMutation = (
  options?: Partial<Options<EncryptionKeyRotateRotateKeyringData>>,
): UseMutationOptions<
  EncryptionKeyRotateRotateKeyringResponse,
  DefaultError,
  Options<EncryptionKeyRotateRotateKeyringData>
> => {
  const mutationOptions: UseMutationOptions<
    EncryptionKeyRotateRotateKeyringResponse,
    DefaultError,
    Options<EncryptionKeyRotateRotateKeyringData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await encryptionKeyRotateRotateKeyring({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const encryptionKeyReadRotateKeyringConfigQueryKey = (
  options?: Options<EncryptionKeyReadRotateKeyringConfigData>,
) => createQueryKey('encryptionKeyReadRotateKeyringConfig', options);

export const encryptionKeyReadRotateKeyringConfigOptions = (
  options?: Options<EncryptionKeyReadRotateKeyringConfigData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await encryptionKeyReadRotateKeyringConfig({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: encryptionKeyReadRotateKeyringConfigQueryKey(options),
  });
};

export const encryptionKeyConfigureRotateKeyringConfigMutation = (
  options?: Partial<Options<EncryptionKeyConfigureRotateKeyringConfigData>>,
): UseMutationOptions<
  EncryptionKeyConfigureRotateKeyringConfigResponse,
  DefaultError,
  Options<EncryptionKeyConfigureRotateKeyringConfigData>
> => {
  const mutationOptions: UseMutationOptions<
    EncryptionKeyConfigureRotateKeyringConfigResponse,
    DefaultError,
    Options<EncryptionKeyConfigureRotateKeyringConfigData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await encryptionKeyConfigureRotateKeyringConfig({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete the backup copy of PGP-encrypted unseal keys.
 * Allows fetching or deleting the backup of the rotated unseal keys.
 */
export const rotateDeleteRotateRecoveryBackupMutation = (
  options?: Partial<Options<RotateDeleteRotateRecoveryBackupData>>,
): UseMutationOptions<
  RotateDeleteRotateRecoveryBackupResponse,
  DefaultError,
  Options<RotateDeleteRotateRecoveryBackupData>
> => {
  const mutationOptions: UseMutationOptions<
    RotateDeleteRotateRecoveryBackupResponse,
    DefaultError,
    Options<RotateDeleteRotateRecoveryBackupData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await rotateDeleteRotateRecoveryBackup({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const rotateReadRotateRecoveryBackupQueryKey = (
  options?: Options<RotateReadRotateRecoveryBackupData>,
) => createQueryKey('rotateReadRotateRecoveryBackup', options);

/**
 * Return the backup copy of PGP-encrypted unseal keys.
 * Allows fetching or deleting the backup of the rotated unseal keys.
 */
export const rotateReadRotateRecoveryBackupOptions = (
  options?: Options<RotateReadRotateRecoveryBackupData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await rotateReadRotateRecoveryBackup({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: rotateReadRotateRecoveryBackupQueryKey(options),
  });
};

/**
 * Cancels any in-progress rotate root operation.
 * This clears the rotate settings as well as any progress made. This must be called to change the parameters of the rotate. Note: verification is still a part of a rotate. If rotating is canceled during the verification flow, the current unseal keys remain valid.
 */
export const rotateAttemptCancelRotateRecoveryInitMutation = (
  options?: Partial<Options<RotateAttemptCancelRotateRecoveryInitData>>,
): UseMutationOptions<
  RotateAttemptCancelRotateRecoveryInitResponse,
  DefaultError,
  Options<RotateAttemptCancelRotateRecoveryInitData>
> => {
  const mutationOptions: UseMutationOptions<
    RotateAttemptCancelRotateRecoveryInitResponse,
    DefaultError,
    Options<RotateAttemptCancelRotateRecoveryInitData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await rotateAttemptCancelRotateRecoveryInit({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const rotateAttemptReadRotateRecoveryInitQueryKey = (
  options?: Options<RotateAttemptReadRotateRecoveryInitData>,
) => createQueryKey('rotateAttemptReadRotateRecoveryInit', options);

/**
 * Reads the configuration and progress of the current root rotate attempt.
 * Initialize, read status or cancel the process of the rotation of the root or recovery key.
 */
export const rotateAttemptReadRotateRecoveryInitOptions = (
  options?: Options<RotateAttemptReadRotateRecoveryInitData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await rotateAttemptReadRotateRecoveryInit({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: rotateAttemptReadRotateRecoveryInitQueryKey(options),
  });
};

/**
 * Initializes a new root rotate attempt.
 * Only a single rotate attempt can take place at a time, and changing the parameters of a rotate requires canceling and starting a new rotation, which will also provide a new nonce.
 */
export const rotateAttemptInitializeRotateRecoveryInitMutation = (
  options?: Partial<Options<RotateAttemptInitializeRotateRecoveryInitData>>,
): UseMutationOptions<
  RotateAttemptInitializeRotateRecoveryInitResponse2,
  DefaultError,
  Options<RotateAttemptInitializeRotateRecoveryInitData>
> => {
  const mutationOptions: UseMutationOptions<
    RotateAttemptInitializeRotateRecoveryInitResponse2,
    DefaultError,
    Options<RotateAttemptInitializeRotateRecoveryInitData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await rotateAttemptInitializeRotateRecoveryInit({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Enter a single unseal key share to progress the rotation of the root key of OpenBao.
 * Progress the rotation process by providing a single key share.
 */
export const rotateAttemptUpdateRotateRecoveryUpdateMutation = (
  options?: Partial<Options<RotateAttemptUpdateRotateRecoveryUpdateData>>,
): UseMutationOptions<
  RotateAttemptUpdateRotateRecoveryUpdateResponse2,
  DefaultError,
  Options<RotateAttemptUpdateRotateRecoveryUpdateData>
> => {
  const mutationOptions: UseMutationOptions<
    RotateAttemptUpdateRotateRecoveryUpdateResponse2,
    DefaultError,
    Options<RotateAttemptUpdateRotateRecoveryUpdateData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await rotateAttemptUpdateRotateRecoveryUpdate({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Cancel any in-progress rotate verification operation.
 * This clears any progress made and resets the nonce. Unlike a `DELETE` against `sys/rotate/(root/recovery)/init`, this only resets the current verification operation, not the entire rotate atttempt.
 */
export const rotateVerificationCancelRotateRecoveryVerifyMutation = (
  options?: Partial<Options<RotateVerificationCancelRotateRecoveryVerifyData>>,
): UseMutationOptions<
  RotateVerificationCancelRotateRecoveryVerifyResponse2,
  DefaultError,
  Options<RotateVerificationCancelRotateRecoveryVerifyData>
> => {
  const mutationOptions: UseMutationOptions<
    RotateVerificationCancelRotateRecoveryVerifyResponse2,
    DefaultError,
    Options<RotateVerificationCancelRotateRecoveryVerifyData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await rotateVerificationCancelRotateRecoveryVerify({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const rotateVerificationReadRotateRecoveryVerifyQueryKey = (
  options?: Options<RotateVerificationReadRotateRecoveryVerifyData>,
) => createQueryKey('rotateVerificationReadRotateRecoveryVerify', options);

/**
 * Read the configuration and progress of the current rotate verification attempt.
 * Read status of, progress or cancel the verification process of the rotation attempt.
 */
export const rotateVerificationReadRotateRecoveryVerifyOptions = (
  options?: Options<RotateVerificationReadRotateRecoveryVerifyData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await rotateVerificationReadRotateRecoveryVerify({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: rotateVerificationReadRotateRecoveryVerifyQueryKey(options),
  });
};

/**
 * Enter a single new key share to progress the rotation verification operation.
 * Read status of, progress or cancel the verification process of the rotation attempt.
 */
export const rotateVerificationUpdateRotateRecoveryVerifyMutation = (
  options?: Partial<Options<RotateVerificationUpdateRotateRecoveryVerifyData>>,
): UseMutationOptions<
  RotateVerificationUpdateRotateRecoveryVerifyResponse2,
  DefaultError,
  Options<RotateVerificationUpdateRotateRecoveryVerifyData>
> => {
  const mutationOptions: UseMutationOptions<
    RotateVerificationUpdateRotateRecoveryVerifyResponse2,
    DefaultError,
    Options<RotateVerificationUpdateRotateRecoveryVerifyData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await rotateVerificationUpdateRotateRecoveryVerify({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Perform a root key rotation without requiring key shares to be provided.
 */
export const rootKeyRotateMutation = (
  options?: Partial<Options<RootKeyRotateData>>,
): UseMutationOptions<
  RootKeyRotateResponse,
  DefaultError,
  Options<RootKeyRotateData>
> => {
  const mutationOptions: UseMutationOptions<
    RootKeyRotateResponse,
    DefaultError,
    Options<RootKeyRotateData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await rootKeyRotate({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete the backup copy of PGP-encrypted unseal keys.
 * Allows fetching or deleting the backup of the rotated unseal keys.
 */
export const rotateDeleteBackupKeyMutation = (
  options?: Partial<Options<RotateDeleteBackupKeyData>>,
): UseMutationOptions<
  RotateDeleteBackupKeyResponse,
  DefaultError,
  Options<RotateDeleteBackupKeyData>
> => {
  const mutationOptions: UseMutationOptions<
    RotateDeleteBackupKeyResponse,
    DefaultError,
    Options<RotateDeleteBackupKeyData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await rotateDeleteBackupKey({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const rotateReadBackupKeyQueryKey = (
  options?: Options<RotateReadBackupKeyData>,
) => createQueryKey('rotateReadBackupKey', options);

/**
 * Return the backup copy of PGP-encrypted unseal keys.
 * Allows fetching or deleting the backup of the rotated unseal keys.
 */
export const rotateReadBackupKeyOptions = (
  options?: Options<RotateReadBackupKeyData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await rotateReadBackupKey({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: rotateReadBackupKeyQueryKey(options),
  });
};

/**
 * Cancels any in-progress rotate root operation.
 * This clears the rotate settings as well as any progress made. This must be called to change the parameters of the rotate. Note: verification is still a part of a rotate. If rotating is canceled during the verification flow, the current unseal keys remain valid.
 */
export const rotateAttemptCancelMutation = (
  options?: Partial<Options<RotateAttemptCancelData>>,
): UseMutationOptions<
  RotateAttemptCancelResponse,
  DefaultError,
  Options<RotateAttemptCancelData>
> => {
  const mutationOptions: UseMutationOptions<
    RotateAttemptCancelResponse,
    DefaultError,
    Options<RotateAttemptCancelData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await rotateAttemptCancel({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const rotateAttemptReadProgressQueryKey = (
  options?: Options<RotateAttemptReadProgressData>,
) => createQueryKey('rotateAttemptReadProgress', options);

/**
 * Reads the configuration and progress of the current root rotate attempt.
 * Initialize, read status or cancel the process of the rotation of the root or recovery key.
 */
export const rotateAttemptReadProgressOptions = (
  options?: Options<RotateAttemptReadProgressData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await rotateAttemptReadProgress({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: rotateAttemptReadProgressQueryKey(options),
  });
};

/**
 * Initializes a new root rotate attempt.
 * Only a single rotate attempt can take place at a time, and changing the parameters of a rotate requires canceling and starting a new rotation, which will also provide a new nonce.
 */
export const rotateAttemptInitializeMutation = (
  options?: Partial<Options<RotateAttemptInitializeData>>,
): UseMutationOptions<
  RotateAttemptInitializeResponse2,
  DefaultError,
  Options<RotateAttemptInitializeData>
> => {
  const mutationOptions: UseMutationOptions<
    RotateAttemptInitializeResponse2,
    DefaultError,
    Options<RotateAttemptInitializeData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await rotateAttemptInitialize({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Enter a single unseal key share to progress the rotation of the root key of OpenBao.
 * Progress the rotation process by providing a single key share.
 */
export const rotateAttemptUpdateMutation = (
  options?: Partial<Options<RotateAttemptUpdateData>>,
): UseMutationOptions<
  RotateAttemptUpdateResponse2,
  DefaultError,
  Options<RotateAttemptUpdateData>
> => {
  const mutationOptions: UseMutationOptions<
    RotateAttemptUpdateResponse2,
    DefaultError,
    Options<RotateAttemptUpdateData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await rotateAttemptUpdate({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Cancel any in-progress rotate verification operation.
 * This clears any progress made and resets the nonce. Unlike a `DELETE` against `sys/rotate/(root/recovery)/init`, this only resets the current verification operation, not the entire rotate atttempt.
 */
export const rotateVerificationCancelMutation = (
  options?: Partial<Options<RotateVerificationCancelData>>,
): UseMutationOptions<
  RotateVerificationCancelResponse2,
  DefaultError,
  Options<RotateVerificationCancelData>
> => {
  const mutationOptions: UseMutationOptions<
    RotateVerificationCancelResponse2,
    DefaultError,
    Options<RotateVerificationCancelData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await rotateVerificationCancel({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const rotateVerificationReadProgressQueryKey = (
  options?: Options<RotateVerificationReadProgressData>,
) => createQueryKey('rotateVerificationReadProgress', options);

/**
 * Read the configuration and progress of the current rotate verification attempt.
 * Read status of, progress or cancel the verification process of the rotation attempt.
 */
export const rotateVerificationReadProgressOptions = (
  options?: Options<RotateVerificationReadProgressData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await rotateVerificationReadProgress({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: rotateVerificationReadProgressQueryKey(options),
  });
};

/**
 * Enter a single new key share to progress the rotation verification operation.
 * Read status of, progress or cancel the verification process of the rotation attempt.
 */
export const rotateVerificationUpdateMutation = (
  options?: Partial<Options<RotateVerificationUpdateData>>,
): UseMutationOptions<
  RotateVerificationUpdateResponse2,
  DefaultError,
  Options<RotateVerificationUpdateData>
> => {
  const mutationOptions: UseMutationOptions<
    RotateVerificationUpdateResponse2,
    DefaultError,
    Options<RotateVerificationUpdateData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await rotateVerificationUpdate({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Seal the OpenBao instance.
 * Seals the OpenBao instance.
 */
export const sealMutation = (
  options?: Partial<Options<SealData>>,
): UseMutationOptions<SealResponse, DefaultError, Options<SealData>> => {
  const mutationOptions: UseMutationOptions<
    SealResponse,
    DefaultError,
    Options<SealData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await seal({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const sealStatusQueryKey = (options?: Options<SealStatusData>) =>
  createQueryKey('sealStatus', options);

/**
 * Check the seal status of an OpenBao instance.
 * Returns the seal status of the OpenBao instance.
 */
export const sealStatusOptions = (options?: Options<SealStatusData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await sealStatus({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: sealStatusQueryKey(options),
  });
};

/**
 * Cause the node to give up active status.
 * This endpoint forces the node to give up active status. If the node does not have active status, this endpoint does nothing. Note that the node will sleep for ten seconds before attempting to grab the active lock again, but if no standby nodes grab the active lock in the interim, the same node may become the active node again.
 */
export const stepDownLeaderMutation = (
  options?: Partial<Options<StepDownLeaderData>>,
): UseMutationOptions<
  StepDownLeaderResponse,
  DefaultError,
  Options<StepDownLeaderData>
> => {
  const mutationOptions: UseMutationOptions<
    StepDownLeaderResponse,
    DefaultError,
    Options<StepDownLeaderData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await stepDownLeader({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Generate a hash sum for input data
 */
export const generateHashMutation = (
  options?: Partial<Options<GenerateHashData>>,
): UseMutationOptions<
  GenerateHashResponse2,
  DefaultError,
  Options<GenerateHashData>
> => {
  const mutationOptions: UseMutationOptions<
    GenerateHashResponse2,
    DefaultError,
    Options<GenerateHashData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await generateHash({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Generate a hash sum for input data
 */
export const generateHashWithAlgorithmMutation = (
  options?: Partial<Options<GenerateHashWithAlgorithmData>>,
): UseMutationOptions<
  GenerateHashWithAlgorithmResponse2,
  DefaultError,
  Options<GenerateHashWithAlgorithmData>
> => {
  const mutationOptions: UseMutationOptions<
    GenerateHashWithAlgorithmResponse2,
    DefaultError,
    Options<GenerateHashWithAlgorithmData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await generateHashWithAlgorithm({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Generate random bytes
 */
export const generateRandomMutation = (
  options?: Partial<Options<GenerateRandomData>>,
): UseMutationOptions<
  GenerateRandomResponse2,
  DefaultError,
  Options<GenerateRandomData>
> => {
  const mutationOptions: UseMutationOptions<
    GenerateRandomResponse2,
    DefaultError,
    Options<GenerateRandomData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await generateRandom({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Generate random bytes
 */
export const generateRandomWithSourceMutation = (
  options?: Partial<Options<GenerateRandomWithSourceData>>,
): UseMutationOptions<
  GenerateRandomWithSourceResponse2,
  DefaultError,
  Options<GenerateRandomWithSourceData>
> => {
  const mutationOptions: UseMutationOptions<
    GenerateRandomWithSourceResponse2,
    DefaultError,
    Options<GenerateRandomWithSourceData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await generateRandomWithSource({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Generate random bytes
 */
export const generateRandomWithSourceAndBytesMutation = (
  options?: Partial<Options<GenerateRandomWithSourceAndBytesData>>,
): UseMutationOptions<
  GenerateRandomWithSourceAndBytesResponse2,
  DefaultError,
  Options<GenerateRandomWithSourceAndBytesData>
> => {
  const mutationOptions: UseMutationOptions<
    GenerateRandomWithSourceAndBytesResponse2,
    DefaultError,
    Options<GenerateRandomWithSourceAndBytesData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await generateRandomWithSourceAndBytes({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Generate random bytes
 */
export const generateRandomWithBytesMutation = (
  options?: Partial<Options<GenerateRandomWithBytesData>>,
): UseMutationOptions<
  GenerateRandomWithBytesResponse2,
  DefaultError,
  Options<GenerateRandomWithBytesData>
> => {
  const mutationOptions: UseMutationOptions<
    GenerateRandomWithBytesResponse2,
    DefaultError,
    Options<GenerateRandomWithBytesData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await generateRandomWithBytes({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Unseal the OpenBao instance.
 * Unseals the OpenBao instance.
 */
export const unsealMutation = (
  options?: Partial<Options<UnsealData>>,
): UseMutationOptions<UnsealResponse2, DefaultError, Options<UnsealData>> => {
  const mutationOptions: UseMutationOptions<
    UnsealResponse2,
    DefaultError,
    Options<UnsealData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await unseal({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const versionHistoryQueryKey = (options: Options<VersionHistoryData>) =>
  createQueryKey('versionHistory', options);

/**
 * Returns map of historical version change entries
 * List historical version changes sorted by installation time in ascending order.
 */
export const versionHistoryOptions = (options: Options<VersionHistoryData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await versionHistory({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: versionHistoryQueryKey(options),
  });
};

export const readWrappingProperties2QueryKey = (
  options?: Options<ReadWrappingProperties2Data>,
) => createQueryKey('readWrappingProperties2', options);

/**
 * Look up wrapping properties for the requester's token.
 * Looks up the properties of a response-wrapped token.
 */
export const readWrappingProperties2Options = (
  options?: Options<ReadWrappingProperties2Data>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await readWrappingProperties2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: readWrappingProperties2QueryKey(options),
  });
};

/**
 * Look up wrapping properties for the given token.
 * Looks up the properties of a response-wrapped token.
 */
export const readWrappingPropertiesMutation = (
  options?: Partial<Options<ReadWrappingPropertiesData>>,
): UseMutationOptions<
  ReadWrappingPropertiesResponse2,
  DefaultError,
  Options<ReadWrappingPropertiesData>
> => {
  const mutationOptions: UseMutationOptions<
    ReadWrappingPropertiesResponse2,
    DefaultError,
    Options<ReadWrappingPropertiesData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await readWrappingProperties({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Rotates a response-wrapped token.
 */
export const rewrapMutation = (
  options?: Partial<Options<RewrapData>>,
): UseMutationOptions<unknown, DefaultError, Options<RewrapData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<RewrapData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await rewrap({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Unwraps a response-wrapped token.
 */
export const unwrapMutation = (
  options?: Partial<Options<UnwrapData>>,
): UseMutationOptions<UnwrapResponse, DefaultError, Options<UnwrapData>> => {
  const mutationOptions: UseMutationOptions<
    UnwrapResponse,
    DefaultError,
    Options<UnwrapData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await unwrap({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Response-wraps an arbitrary JSON object.
 */
export const wrapMutation = (
  options?: Partial<Options<WrapData>>,
): UseMutationOptions<unknown, DefaultError, Options<WrapData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<WrapData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await wrap({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const kvReadConfigQueryKey = (options: Options<KvReadConfigData>) =>
  createQueryKey('kvReadConfig', options);

/**
 * Read the backend level settings.
 * Configures settings for the KV store
 */
export const kvReadConfigOptions = (options: Options<KvReadConfigData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await kvReadConfig({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: kvReadConfigQueryKey(options),
  });
};

/**
 * Configure backend level settings that are applied to every key in the key-value store.
 * Configures settings for the KV store
 */
export const kvWriteConfigMutation = (
  options?: Partial<Options<KvWriteConfigData>>,
): UseMutationOptions<unknown, DefaultError, Options<KvWriteConfigData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<KvWriteConfigData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await kvWriteConfig({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Write, Patch, Read, and Delete data in the Key-Value Store.
 */
export const kvDeleteDataPathMutation = (
  options?: Partial<Options<KvDeleteDataPathData>>,
): UseMutationOptions<
  KvDeleteDataPathResponse,
  DefaultError,
  Options<KvDeleteDataPathData>
> => {
  const mutationOptions: UseMutationOptions<
    KvDeleteDataPathResponse,
    DefaultError,
    Options<KvDeleteDataPathData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await kvDeleteDataPath({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const kvReadDataPathQueryKey = (options: Options<KvReadDataPathData>) =>
  createQueryKey('kvReadDataPath', options);

/**
 * Write, Patch, Read, and Delete data in the Key-Value Store.
 */
export const kvReadDataPathOptions = (options: Options<KvReadDataPathData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await kvReadDataPath({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: kvReadDataPathQueryKey(options),
  });
};

/**
 * Write, Patch, Read, and Delete data in the Key-Value Store.
 */
export const kvWriteDataPathMutation = (
  options?: Partial<Options<KvWriteDataPathData>>,
): UseMutationOptions<unknown, DefaultError, Options<KvWriteDataPathData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<KvWriteDataPathData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await kvWriteDataPath({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Marks one or more versions as deleted in the KV store.
 */
export const kvWriteDeletePathMutation = (
  options?: Partial<Options<KvWriteDeletePathData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<KvWriteDeletePathData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<KvWriteDeletePathData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await kvWriteDeletePath({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Permanently removes one or more versions in the KV store
 */
export const kvWriteDestroyPathMutation = (
  options?: Partial<Options<KvWriteDestroyPathData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<KvWriteDestroyPathData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<KvWriteDestroyPathData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await kvWriteDestroyPath({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const kvListDetailedMetadataPathQueryKey = (
  options: Options<KvListDetailedMetadataPathData>,
) => createQueryKey('kvListDetailedMetadataPath', options);

/**
 * Allows listing detailed information about key metadata in the KV store.
 */
export const kvListDetailedMetadataPathOptions = (
  options: Options<KvListDetailedMetadataPathData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await kvListDetailedMetadataPath({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: kvListDetailedMetadataPathQueryKey(options),
  });
};

/**
 * Allows interaction with key metadata and settings in the KV store.
 */
export const kvDeleteMetadataPathMutation = (
  options?: Partial<Options<KvDeleteMetadataPathData>>,
): UseMutationOptions<
  KvDeleteMetadataPathResponse,
  DefaultError,
  Options<KvDeleteMetadataPathData>
> => {
  const mutationOptions: UseMutationOptions<
    KvDeleteMetadataPathResponse,
    DefaultError,
    Options<KvDeleteMetadataPathData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await kvDeleteMetadataPath({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const kvReadMetadataPathQueryKey = (
  options: Options<KvReadMetadataPathData>,
) => createQueryKey('kvReadMetadataPath', options);

/**
 * Allows interaction with key metadata and settings in the KV store.
 */
export const kvReadMetadataPathOptions = (
  options: Options<KvReadMetadataPathData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await kvReadMetadataPath({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: kvReadMetadataPathQueryKey(options),
  });
};

/**
 * Allows interaction with key metadata and settings in the KV store.
 */
export const kvWriteMetadataPathMutation = (
  options?: Partial<Options<KvWriteMetadataPathData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<KvWriteMetadataPathData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<KvWriteMetadataPathData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await kvWriteMetadataPath({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const kvReadSubkeysPathQueryKey = (
  options: Options<KvReadSubkeysPathData>,
) => createQueryKey('kvReadSubkeysPath', options);

/**
 * Read the structure of a secret entry from the Key-Value store with the values removed.
 */
export const kvReadSubkeysPathOptions = (
  options: Options<KvReadSubkeysPathData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await kvReadSubkeysPath({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: kvReadSubkeysPathQueryKey(options),
  });
};

/**
 * Undeletes one or more versions from the KV store.
 */
export const kvWriteUndeletePathMutation = (
  options?: Partial<Options<KvWriteUndeletePathData>>,
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<KvWriteUndeletePathData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<KvWriteUndeletePathData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await kvWriteUndeletePath({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};
