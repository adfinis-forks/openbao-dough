// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: `${string}://${string}` | (string & {});
};

export type AliasCreateRequest = {
    /**
     * Entity ID to which this alias belongs to
     */
    canonical_id?: string;
    /**
     * Entity ID to which this alias belongs to. This field is deprecated in favor of 'canonical_id'.
     */
    entity_id?: string;
    /**
     * ID of the alias
     */
    id?: string;
    /**
     * Mount accessor to which this alias belongs to
     */
    mount_accessor?: string;
    /**
     * Name of the alias
     */
    name?: string;
};

export type AliasUpdateByIdRequest = {
    /**
     * Entity ID to which this alias should be tied to
     */
    canonical_id?: string;
    /**
     * Entity ID to which this alias should be tied to. This field is deprecated in favor of 'canonical_id'.
     */
    entity_id?: string;
    /**
     * Mount accessor to which this alias belongs to
     */
    mount_accessor?: string;
    /**
     * Name of the alias
     */
    name?: string;
};

export type AuditingCalculateHashRequest = {
    input?: string;
};

export type AuditingCalculateHashResponse = {
    hash?: string;
};

export type AuditingEnableDeviceRequest = {
    /**
     * User-friendly description for this audit backend.
     */
    description?: string;
    /**
     * Mark the mount as a local mount, which is not replicated and is unaffected by replication.
     */
    local?: boolean;
    /**
     * Configuration options for the audit backend.
     */
    options?: {
        [key: string]: unknown;
    };
    /**
     * The type of the backend. Example: "mysql"
     */
    type?: string;
};

export type AuditingEnableRequestHeaderRequest = {
    hmac?: boolean;
};

export type AuditingListRequestHeadersResponse = {
    headers?: {
        [key: string]: unknown;
    };
};

export type AuthEnableMethodRequest = {
    /**
     * Configuration for this mount, such as plugin_name.
     */
    config?: {
        [key: string]: unknown;
    };
    /**
     * User-friendly description for this credential backend.
     */
    description?: string;
    /**
     * Whether to give the mount access to OpenBao's external entropy.
     */
    external_entropy_access?: boolean;
    /**
     * Mark the mount as a local mount, which is not replicated and is unaffected by replication.
     */
    local?: boolean;
    /**
     * The options to pass into the backend. Should be a json object with string keys and values.
     */
    options?: {
        [key: string]: unknown;
    };
    /**
     * Name of the auth plugin to use based from the name in the plugin catalog.
     */
    plugin_name?: string;
    /**
     * The semantic version of the plugin to use.
     */
    plugin_version?: string;
    /**
     * Whether to turn on seal wrapping for the mount.
     */
    seal_wrap?: boolean;
    /**
     * The type of the backend. Example: "userpass"
     */
    type?: string;
};

export type AuthReadConfigurationResponse = {
    accessor?: string;
    config?: {
        [key: string]: unknown;
    };
    deprecation_status?: string;
    description?: string;
    external_entropy_access?: boolean;
    local?: boolean;
    options?: {
        [key: string]: unknown;
    };
    plugin_version?: string;
    running_plugin_version?: string;
    running_sha256?: string;
    seal_wrap?: boolean;
    type?: string;
    uuid?: string;
};

export type AuthReadTuningInformationResponse = {
    allowed_managed_keys?: Array<string>;
    allowed_response_headers?: Array<string>;
    audit_non_hmac_request_keys?: Array<string>;
    audit_non_hmac_response_keys?: Array<string>;
    default_lease_ttl?: number;
    description?: string;
    external_entropy_access?: boolean;
    force_no_cache?: boolean;
    listing_visibility?: string;
    max_lease_ttl?: number;
    options?: {
        [key: string]: unknown;
    };
    passthrough_request_headers?: Array<string>;
    plugin_version?: string;
    token_type?: string;
    user_lockout_counter_reset_duration?: number;
    user_lockout_disable?: boolean;
    user_lockout_duration?: number;
    user_lockout_threshold?: number;
};

export type AuthTuneConfigurationParametersRequest = {
    /**
     * A list of headers to whitelist and allow a plugin to set on responses.
     */
    allowed_response_headers?: Array<string>;
    /**
     * The list of keys in the request data object that will not be HMAC'ed by audit devices.
     */
    audit_non_hmac_request_keys?: Array<string>;
    /**
     * The list of keys in the response data object that will not be HMAC'ed by audit devices.
     */
    audit_non_hmac_response_keys?: Array<string>;
    /**
     * The default lease TTL for this mount.
     */
    default_lease_ttl?: string;
    /**
     * User-friendly description for this credential backend.
     */
    description?: string;
    /**
     * Determines the visibility of the mount in the UI-specific listing endpoint. Accepted value are 'unauth' and 'hidden', with the empty default ('') behaving like 'hidden'.
     */
    listing_visibility?: string;
    /**
     * The max lease TTL for this mount.
     */
    max_lease_ttl?: string;
    /**
     * The options to pass into the backend. Should be a json object with string keys and values.
     */
    options?: {
        [key: string]: unknown;
    };
    /**
     * A list of headers to whitelist and pass from the request to the plugin.
     */
    passthrough_request_headers?: Array<string>;
    /**
     * The semantic version of the plugin to use.
     */
    plugin_version?: string;
    /**
     * The type of token to issue (service or batch).
     */
    token_type?: string;
    /**
     * The user lockout configuration to pass into the backend. Should be a json object with string keys and values.
     */
    user_lockout_config?: {
        [key: string]: unknown;
    };
};

export type CollectHostInformationResponse = {
    cpu?: Array<{
        [key: string]: unknown;
    }>;
    cpu_times?: Array<{
        [key: string]: unknown;
    }>;
    disk?: Array<{
        [key: string]: unknown;
    }>;
    host?: {
        [key: string]: unknown;
    };
    memory?: {
        [key: string]: unknown;
    };
    timestamp?: string;
};

export type CorsConfigureRequest = {
    /**
     * A comma-separated string or array of strings indicating headers that are allowed on cross-origin requests.
     */
    allowed_headers?: Array<string>;
    /**
     * A comma-separated string or array of strings indicating origins that may make cross-origin requests.
     */
    allowed_origins?: Array<string>;
    /**
     * Enables or disables CORS headers on requests.
     */
    enable?: boolean;
};

export type CorsReadConfigurationResponse = {
    allowed_headers?: Array<string>;
    allowed_origins?: Array<string>;
    enabled?: boolean;
};

export type DecodeRequest = {
    /**
     * Specifies the encoded token (result from generate-root).
     */
    encoded_token?: string;
    /**
     * Specifies the otp code for decode.
     */
    otp?: string;
};

export type EncryptionKeyConfigureRotateKeyringConfigRequest = {
    /**
     * Whether automatic rotation is enabled.
     */
    enabled?: boolean;
    /**
     * How long after installation of an active key term that the key will be automatically rotated.
     */
    interval?: number;
    /**
     * The number of encryption operations performed before the barrier key is automatically rotated.
     */
    max_operations?: number;
};

export type EncryptionKeyConfigureRotationConfigurationRequest = {
    /**
     * Whether automatic rotation is enabled.
     */
    enabled?: boolean;
    /**
     * How long after installation of an active key term that the key will be automatically rotated.
     */
    interval?: number;
    /**
     * The number of encryption operations performed before the barrier key is automatically rotated.
     */
    max_operations?: number;
};

export type EncryptionKeyReadRotateKeyringConfigResponse = {
    /**
     * Whether automatic rotation is enabled.
     */
    enabled?: boolean;
    /**
     * How long after installation of an active key term that the key will be automatically rotated.
     */
    interval?: number;
    /**
     * The number of encryption operations performed before the barrier key is automatically rotated.
     */
    max_operations?: number;
};

export type EncryptionKeyReadRotationConfigurationResponse = {
    /**
     * Whether automatic rotation is enabled.
     */
    enabled?: boolean;
    /**
     * How long after installation of an active key term that the key will be automatically rotated.
     */
    interval?: number;
    /**
     * The number of encryption operations performed before the barrier key is automatically rotated.
     */
    max_operations?: number;
};

export type EntityBatchDeleteRequest = {
    /**
     * Entity IDs to delete
     */
    entity_ids?: Array<string>;
};

export type EntityCreateAliasRequest = {
    /**
     * Entity ID to which this alias belongs
     */
    canonical_id?: string;
    /**
     * User provided key-value pairs
     */
    custom_metadata?: {
        [key: string]: unknown;
    };
    /**
     * Entity ID to which this alias belongs. This field is deprecated, use canonical_id.
     */
    entity_id?: string;
    /**
     * ID of the entity alias. If set, updates the corresponding entity alias.
     */
    id?: string;
    /**
     * Mount accessor to which this alias belongs to; unused for a modify
     */
    mount_accessor?: string;
    /**
     * Name of the alias; unused for a modify
     */
    name?: string;
};

export type EntityCreateRequest = {
    /**
     * If set true, tokens tied to this identity will not be able to be used (but will not be revoked).
     */
    disabled?: boolean;
    /**
     * ID of the entity. If set, updates the corresponding existing entity.
     */
    id?: string;
    /**
     * Metadata to be associated with the entity. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: bao <command> <path> metadata=key1=value1 metadata=key2=value2
     */
    metadata?: {
        [key: string]: unknown;
    };
    /**
     * Name of the entity
     */
    name?: string;
    /**
     * Policies to be tied to the entity.
     */
    policies?: Array<string>;
};

export type EntityLookUpRequest = {
    /**
     * ID of the alias.
     */
    alias_id?: string;
    /**
     * Accessor of the mount to which the alias belongs to. This should be supplied in conjunction with 'alias_name'.
     */
    alias_mount_accessor?: string;
    /**
     * Name of the alias. This should be supplied in conjunction with 'alias_mount_accessor'.
     */
    alias_name?: string;
    /**
     * ID of the entity.
     */
    id?: string;
    /**
     * Name of the entity.
     */
    name?: string;
};

export type EntityMergeRequest = {
    /**
     * Alias IDs to keep in case of conflicting aliases. Ignored if no conflicting aliases found
     */
    conflicting_alias_ids_to_keep?: Array<string>;
    /**
     * Setting this will follow the 'mine' strategy for merging MFA secrets. If there are secrets of the same type both in entities that are merged from and in entity into which all others are getting merged, secrets in the destination will be unaltered. If not set, this API will throw an error containing all the conflicts.
     */
    force?: boolean;
    /**
     * Entity IDs which need to get merged
     */
    from_entity_ids?: Array<string>;
    /**
     * Entity ID into which all the other entities need to get merged
     */
    to_entity_id?: string;
};

export type EntityUpdateAliasByIdRequest = {
    /**
     * Entity ID to which this alias should be tied to
     */
    canonical_id?: string;
    /**
     * User provided key-value pairs
     */
    custom_metadata?: {
        [key: string]: unknown;
    };
    /**
     * Entity ID to which this alias belongs to. This field is deprecated, use canonical_id.
     */
    entity_id?: string;
    /**
     * (Unused)
     */
    mount_accessor?: string;
    /**
     * (Unused)
     */
    name?: string;
};

export type EntityUpdateByIdRequest = {
    /**
     * If set true, tokens tied to this identity will not be able to be used (but will not be revoked).
     */
    disabled?: boolean;
    /**
     * Metadata to be associated with the entity. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: bao <command> <path> metadata=key1=value1 metadata=key2=value2
     */
    metadata?: {
        [key: string]: unknown;
    };
    /**
     * Name of the entity
     */
    name?: string;
    /**
     * Policies to be tied to the entity.
     */
    policies?: Array<string>;
};

export type EntityUpdateByNameRequest = {
    /**
     * If set true, tokens tied to this identity will not be able to be used (but will not be revoked).
     */
    disabled?: boolean;
    /**
     * ID of the entity. If set, updates the corresponding existing entity.
     */
    id?: string;
    /**
     * Metadata to be associated with the entity. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: bao <command> <path> metadata=key1=value1 metadata=key2=value2
     */
    metadata?: {
        [key: string]: unknown;
    };
    /**
     * Policies to be tied to the entity.
     */
    policies?: Array<string>;
};

export type GenerateHashRequest = {
    /**
     * Algorithm to use (POST body parameter). Valid values are: * sha2-224 * sha2-256 * sha2-384 * sha2-512 Defaults to "sha2-256".
     */
    algorithm?: string;
    /**
     * Encoding format to use. Can be "hex" or "base64". Defaults to "hex".
     */
    format?: string;
    /**
     * The base64-encoded input data
     */
    input?: string;
    /**
     * Algorithm to use (POST URL parameter)
     */
    urlalgorithm?: string;
};

export type GenerateHashResponse = {
    sum?: string;
};

export type GenerateHashWithAlgorithmRequest = {
    /**
     * Algorithm to use (POST body parameter). Valid values are: * sha2-224 * sha2-256 * sha2-384 * sha2-512 Defaults to "sha2-256".
     */
    algorithm?: string;
    /**
     * Encoding format to use. Can be "hex" or "base64". Defaults to "hex".
     */
    format?: string;
    /**
     * The base64-encoded input data
     */
    input?: string;
};

export type GenerateHashWithAlgorithmResponse = {
    sum?: string;
};

export type GenerateRandomRequest = {
    /**
     * The number of bytes to generate (POST body parameter). Defaults to 32 (256 bits).
     */
    bytes?: number;
    /**
     * Encoding format to use. Can be "hex" or "base64". Defaults to "base64".
     */
    format?: string;
    /**
     * Which system to source random data from, ether "platform", "seal", or "all".
     */
    source?: string;
    /**
     * The number of bytes to generate (POST URL parameter)
     */
    urlbytes?: string;
};

export type GenerateRandomResponse = {
    random_bytes?: string;
};

export type GenerateRandomWithBytesRequest = {
    /**
     * The number of bytes to generate (POST body parameter). Defaults to 32 (256 bits).
     */
    bytes?: number;
    /**
     * Encoding format to use. Can be "hex" or "base64". Defaults to "base64".
     */
    format?: string;
    /**
     * Which system to source random data from, ether "platform", "seal", or "all".
     */
    source?: string;
};

export type GenerateRandomWithBytesResponse = {
    random_bytes?: string;
};

export type GenerateRandomWithSourceAndBytesRequest = {
    /**
     * The number of bytes to generate (POST body parameter). Defaults to 32 (256 bits).
     */
    bytes?: number;
    /**
     * Encoding format to use. Can be "hex" or "base64". Defaults to "base64".
     */
    format?: string;
};

export type GenerateRandomWithSourceAndBytesResponse = {
    random_bytes?: string;
};

export type GenerateRandomWithSourceRequest = {
    /**
     * The number of bytes to generate (POST body parameter). Defaults to 32 (256 bits).
     */
    bytes?: number;
    /**
     * Encoding format to use. Can be "hex" or "base64". Defaults to "base64".
     */
    format?: string;
    /**
     * The number of bytes to generate (POST URL parameter)
     */
    urlbytes?: string;
};

export type GenerateRandomWithSourceResponse = {
    random_bytes?: string;
};

export type GroupCreateAliasRequest = {
    /**
     * ID of the group to which this is an alias.
     */
    canonical_id?: string;
    /**
     * ID of the group alias.
     */
    id?: string;
    /**
     * Mount accessor to which this alias belongs to.
     */
    mount_accessor?: string;
    /**
     * Alias of the group.
     */
    name?: string;
};

export type GroupCreateRequest = {
    /**
     * ID of the group. If set, updates the corresponding existing group.
     */
    id?: string;
    /**
     * Entity IDs to be assigned as group members.
     */
    member_entity_ids?: Array<string>;
    /**
     * Group IDs to be assigned as group members.
     */
    member_group_ids?: Array<string>;
    /**
     * Metadata to be associated with the group. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: bao <command> <path> metadata=key1=value1 metadata=key2=value2
     */
    metadata?: {
        [key: string]: unknown;
    };
    /**
     * Name of the group.
     */
    name?: string;
    /**
     * Policies to be tied to the group.
     */
    policies?: Array<string>;
    /**
     * Type of the group, 'internal' or 'external'. Defaults to 'internal'
     */
    type?: string;
};

export type GroupLookUpRequest = {
    /**
     * ID of the alias.
     */
    alias_id?: string;
    /**
     * Accessor of the mount to which the alias belongs to. This should be supplied in conjunction with 'alias_name'.
     */
    alias_mount_accessor?: string;
    /**
     * Name of the alias. This should be supplied in conjunction with 'alias_mount_accessor'.
     */
    alias_name?: string;
    /**
     * ID of the group.
     */
    id?: string;
    /**
     * Name of the group.
     */
    name?: string;
};

export type GroupUpdateAliasByIdRequest = {
    /**
     * ID of the group to which this is an alias.
     */
    canonical_id?: string;
    /**
     * Mount accessor to which this alias belongs to.
     */
    mount_accessor?: string;
    /**
     * Alias of the group.
     */
    name?: string;
};

export type GroupUpdateByIdRequest = {
    /**
     * Entity IDs to be assigned as group members.
     */
    member_entity_ids?: Array<string>;
    /**
     * Group IDs to be assigned as group members.
     */
    member_group_ids?: Array<string>;
    /**
     * Metadata to be associated with the group. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: bao <command> <path> metadata=key1=value1 metadata=key2=value2
     */
    metadata?: {
        [key: string]: unknown;
    };
    /**
     * Name of the group.
     */
    name?: string;
    /**
     * Policies to be tied to the group.
     */
    policies?: Array<string>;
    /**
     * Type of the group, 'internal' or 'external'. Defaults to 'internal'
     */
    type?: string;
};

export type GroupUpdateByNameRequest = {
    /**
     * ID of the group. If set, updates the corresponding existing group.
     */
    id?: string;
    /**
     * Entity IDs to be assigned as group members.
     */
    member_entity_ids?: Array<string>;
    /**
     * Group IDs to be assigned as group members.
     */
    member_group_ids?: Array<string>;
    /**
     * Metadata to be associated with the group. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: bao <command> <path> metadata=key1=value1 metadata=key2=value2
     */
    metadata?: {
        [key: string]: unknown;
    };
    /**
     * Policies to be tied to the group.
     */
    policies?: Array<string>;
    /**
     * Type of the group, 'internal' or 'external'. Defaults to 'internal'
     */
    type?: string;
};

export type HaStatusResponse = {
    nodes?: Array<{
        [key: string]: unknown;
    }>;
};

export type InitializeSystemRequest = {
    /**
     * Specifies an array of PGP public keys used to encrypt the output unseal keys. Ordering is preserved. The keys must be base64-encoded from their original binary representation. The size of this array must be the same as `secret_shares`.
     */
    pgp_keys?: Array<string>;
    /**
     * Specifies an array of PGP public keys used to encrypt the output recovery keys. Ordering is preserved. The keys must be base64-encoded from their original binary representation. The size of this array must be the same as `recovery_shares`.
     */
    recovery_pgp_keys?: Array<string>;
    /**
     * Specifies the number of shares to split the recovery key into.
     */
    recovery_shares?: number;
    /**
     * Specifies the number of shares required to reconstruct the recovery key. This must be less than or equal to `recovery_shares`.
     */
    recovery_threshold?: number;
    /**
     * Specifies a PGP public key used to encrypt the initial root token. The key must be base64-encoded from its original binary representation.
     */
    root_token_pgp_key?: string;
    /**
     * Specifies the number of shares to split the unseal key into.
     */
    secret_shares?: number;
    /**
     * Specifies the number of shares required to reconstruct the unseal key. This must be less than or equal secret_shares. If using OpenBao HSM with auto-unsealing, this value must be the same as `secret_shares`.
     */
    secret_threshold?: number;
    /**
     * Specifies the number of shares that should be encrypted by the HSM and stored for auto-unsealing. Currently must be the same as `secret_shares`.
     */
    stored_shares?: number;
};

export type InternalCountEntitiesResponse = {
    counters?: {
        [key: string]: unknown;
    };
};

export type InternalCountTokensResponse = {
    counters?: {
        [key: string]: unknown;
    };
};

export type InternalGenerateOpenApiDocumentWithParametersRequest = {
    /**
     * Context string appended to every operationId
     */
    context?: string;
};

export type InternalUiListEnabledFeatureFlagsResponse = {
    feature_flags?: Array<string>;
};

export type InternalUiListEnabledVisibleMountsResponse = {
    /**
     * auth mounts
     */
    auth?: {
        [key: string]: unknown;
    };
    /**
     * secret mounts
     */
    secret?: {
        [key: string]: unknown;
    };
};

export type InternalUiListNamespacesResponse = {
    /**
     * field is only returned if there are one or more namespaces
     */
    keys?: Array<string>;
};

export type InternalUiReadMountInformationResponse = {
    accessor?: string;
    config?: {
        [key: string]: unknown;
    };
    deprecation_status?: string;
    description?: string;
    external_entropy_access?: boolean;
    local?: boolean;
    options?: {
        [key: string]: unknown;
    };
    path?: string;
    plugin_version?: string;
    running_plugin_version?: string;
    running_sha256?: string;
    seal_wrap?: boolean;
    type?: string;
    uuid?: string;
};

export type InternalUiReadResultantAclResponse = {
    exact_paths?: {
        [key: string]: unknown;
    };
    glob_paths?: {
        [key: string]: unknown;
    };
    root?: boolean;
};

export type KvWriteConfigRequest = {
    /**
     * If true, the backend will require the cas parameter to be set for each write
     */
    cas_required?: boolean;
    /**
     * If set, the length of time before a version is deleted. A negative duration disables the use of delete_version_after on all keys. A zero duration clears the current setting. Accepts a Go duration format string.
     */
    delete_version_after?: number;
    /**
     * The number of versions to keep for each key. Defaults to 10
     */
    max_versions?: number;
    /**
     * If true, the backend will require the metadata_cas parameter to be set for each metadata update
     */
    metadata_cas_required?: boolean;
};

export type KvWriteDataPathRequest = {
    /**
     * The contents of the data map will be stored and returned on read.
     */
    data?: {
        [key: string]: unknown;
    };
    /**
     * Options for writing a KV entry. Set the "cas" value to use a Check-And-Set operation. If not set the write will be allowed. If set to 0 a write will only be allowed if the key doesn’t exist. If the index is non-zero the write will only be allowed if the key’s current version matches the version specified in the cas parameter.
     */
    options?: {
        [key: string]: unknown;
    };
    /**
     * If provided during a read, the value at the version number will be returned
     */
    version?: number;
};

export type KvWriteDeletePathRequest = {
    /**
     * The versions to be archived. The versioned data will not be deleted, but it will no longer be returned in normal get requests.
     */
    versions?: Array<number>;
};

export type KvWriteDestroyPathRequest = {
    /**
     * The versions to destroy. Their data will be permanently deleted.
     */
    versions?: Array<number>;
};

export type KvWriteMetadataPathRequest = {
    /**
     * Optional entry to list begin listing after, not required to exist. Only used for listing.
     */
    after?: string;
    /**
     * If true the key will require the cas parameter to be set on all write requests. If false, the backend’s configuration will be used.
     */
    cas_required?: boolean;
    /**
     * User-provided key-value pairs that are used to describe arbitrary and version-agnostic information about a secret.
     */
    custom_metadata?: {
        [key: string]: unknown;
    };
    /**
     * The length of time before a version is deleted. If not set, the backend's configured delete_version_after is used. Cannot be greater than the backend's delete_version_after. A zero duration clears the current setting. A negative duration will cause an error.
     */
    delete_version_after?: number;
    /**
     * Optional number of entries to return; defaults to all entries. Only used for listing.
     */
    limit?: number;
    /**
     * The number of versions to keep. If not set, the backend’s configured max version is used.
     */
    max_versions?: number;
    /**
     * Check-and-set parameter for metadata updates. Must match the current metadata version for the update to succeed. Set to 0 for initial metadata creation.
     */
    metadata_cas?: number;
    /**
     * If true the key will require the cas parameter to be set on all metadata update requests. If false, the backend's configuration will be used.
     */
    metadata_cas_required?: boolean;
};

export type KvWriteUndeletePathRequest = {
    /**
     * The versions to unarchive. The versions will be restored and their data will be returned on normal get requests.
     */
    versions?: Array<number>;
};

export type LeaderStatusResponse = {
    active_time?: string;
    ha_enabled?: boolean;
    is_self?: boolean;
    last_wal?: number;
    leader_address?: string;
    leader_cluster_address?: string;
    performance_standby?: boolean;
    performance_standby_last_remote_wal?: number;
    raft_applied_index?: number;
    raft_committed_index?: number;
};

export type LeasesCountResponse = {
    /**
     * Number of matching leases per mount
     */
    counts?: number;
    /**
     * Number of matching leases
     */
    lease_count?: number;
};

export type LeasesListResponse = {
    /**
     * Number of matching leases per mount
     */
    counts?: number;
    /**
     * Number of matching leases
     */
    lease_count?: number;
};

export type LeasesLookUpResponse = {
    /**
     * A list of lease ids
     */
    keys?: Array<string>;
};

export type LeasesLookUpWithPrefixResponse = {
    /**
     * A list of lease ids
     */
    keys?: Array<string>;
};

export type LeasesReadLeaseRequest = {
    /**
     * The lease identifier to renew. This is included with a lease.
     */
    lease_id?: string;
};

export type LeasesReadLeaseResponse = {
    /**
     * Optional lease expiry time
     */
    expire_time?: string;
    /**
     * Lease id
     */
    id?: string;
    /**
     * Timestamp for the lease's issue time
     */
    issue_time?: string;
    /**
     * Optional Timestamp of the last time the lease was renewed
     */
    last_renewal?: string;
    /**
     * True if the lease is able to be renewed
     */
    renewable?: boolean;
    /**
     * Time to Live set for the lease, returns 0 if unset
     */
    ttl?: number;
};

export type LeasesRenewLease2Request = {
    /**
     * The desired increment in seconds to the lease
     */
    increment?: number;
    /**
     * The lease identifier to renew. This is included with a lease.
     */
    lease_id?: string;
    /**
     * The lease identifier to renew. This is included with a lease.
     */
    url_lease_id?: string;
};

export type LeasesRenewLeaseRequest = {
    /**
     * The desired increment in seconds to the lease
     */
    increment?: number;
    /**
     * The lease identifier to renew. This is included with a lease.
     */
    lease_id?: string;
    /**
     * The lease identifier to renew. This is included with a lease.
     */
    url_lease_id?: string;
};

export type LeasesRenewLeaseWithId2Request = {
    /**
     * The desired increment in seconds to the lease
     */
    increment?: number;
    /**
     * The lease identifier to renew. This is included with a lease.
     */
    lease_id?: string;
};

export type LeasesRenewLeaseWithIdRequest = {
    /**
     * The desired increment in seconds to the lease
     */
    increment?: number;
    /**
     * The lease identifier to renew. This is included with a lease.
     */
    lease_id?: string;
};

export type LeasesRevokeLease2Request = {
    /**
     * The lease identifier to renew. This is included with a lease.
     */
    lease_id?: string;
    /**
     * Whether or not to perform the revocation synchronously
     */
    sync?: boolean;
    /**
     * The lease identifier to renew. This is included with a lease.
     */
    url_lease_id?: string;
};

export type LeasesRevokeLeaseRequest = {
    /**
     * The lease identifier to renew. This is included with a lease.
     */
    lease_id?: string;
    /**
     * Whether or not to perform the revocation synchronously
     */
    sync?: boolean;
    /**
     * The lease identifier to renew. This is included with a lease.
     */
    url_lease_id?: string;
};

export type LeasesRevokeLeaseWithId2Request = {
    /**
     * The lease identifier to renew. This is included with a lease.
     */
    lease_id?: string;
    /**
     * Whether or not to perform the revocation synchronously
     */
    sync?: boolean;
};

export type LeasesRevokeLeaseWithIdRequest = {
    /**
     * The lease identifier to renew. This is included with a lease.
     */
    lease_id?: string;
    /**
     * Whether or not to perform the revocation synchronously
     */
    sync?: boolean;
};

export type LeasesRevokeLeaseWithPrefix2Request = {
    /**
     * Whether or not to perform the revocation synchronously
     */
    sync?: boolean;
};

export type LeasesRevokeLeaseWithPrefixRequest = {
    /**
     * Whether or not to perform the revocation synchronously
     */
    sync?: boolean;
};

export type LoggersUpdateVerbosityLevelForRequest = {
    /**
     * Log verbosity level. Supported values (in order of detail) are "trace", "debug", "info", "warn", and "error".
     */
    level?: string;
};

export type LoggersUpdateVerbosityLevelRequest = {
    /**
     * Log verbosity level. Supported values (in order of detail) are "trace", "debug", "info", "warn", and "error".
     */
    level?: string;
};

export type MfaAdminDestroyTotpSecretRequest = {
    /**
     * Identifier of the entity from which the MFA method secret needs to be removed.
     */
    entity_id: string;
    /**
     * The unique identifier for this MFA method.
     */
    method_id: string;
};

export type MfaAdminGenerateTotpSecretRequest = {
    /**
     * Entity ID on which the generated secret needs to get stored.
     */
    entity_id: string;
    /**
     * The unique identifier for this MFA method.
     */
    method_id: string;
};

export type MfaConfigureDuoMethodRequest = {
    /**
     * API host name for Duo.
     */
    api_hostname?: string;
    /**
     * Integration key for Duo.
     */
    integration_key?: string;
    /**
     * The unique name identifier for this MFA method.
     */
    method_name?: string;
    /**
     * Push information for Duo.
     */
    push_info?: string;
    /**
     * Secret key for Duo.
     */
    secret_key?: string;
    /**
     * If true, the user is reminded to use the passcode upon MFA validation. This option does not enforce using the passcode. Defaults to false.
     */
    use_passcode?: boolean;
    /**
     * A template string for mapping Identity names to MFA method names. Values to subtitute should be placed in {{}}. For example, "{{alias.name}}@example.com". Currently-supported mappings: alias.name: The name returned by the mount configured via the mount_accessor parameter If blank, the Alias's name field will be used as-is.
     */
    username_format?: string;
};

export type MfaConfigureOktaMethodRequest = {
    /**
     * Okta API key.
     */
    api_token?: string;
    /**
     * The base domain to use for the Okta API. When not specified in the configuration, "okta.com" is used.
     */
    base_url?: string;
    /**
     * The unique name identifier for this MFA method.
     */
    method_name?: string;
    /**
     * Name of the organization to be used in the Okta API.
     */
    org_name?: string;
    /**
     * If true, the username will only match the primary email for the account. Defaults to false.
     */
    primary_email?: boolean;
    /**
     * (DEPRECATED) Use base_url instead.
     */
    production?: boolean;
    /**
     * A template string for mapping Identity names to MFA method names. Values to substitute should be placed in {{}}. For example, "{{entity.name}}@example.com". If blank, the Entity's name field will be used as-is.
     */
    username_format?: string;
};

export type MfaConfigurePingIdMethodRequest = {
    /**
     * The unique name identifier for this MFA method.
     */
    method_name?: string;
    /**
     * The settings file provided by Ping, Base64-encoded. This must be a settings file suitable for third-party clients, not the PingID SDK or PingFederate.
     */
    settings_file_base64?: string;
    /**
     * A template string for mapping Identity names to MFA method names. Values to subtitute should be placed in {{}}. For example, "{{alias.name}}@example.com". Currently-supported mappings: alias.name: The name returned by the mount configured via the mount_accessor parameter If blank, the Alias's name field will be used as-is.
     */
    username_format?: string;
};

export type MfaConfigureTotpMethodRequest = {
    /**
     * The hashing algorithm used to generate the TOTP token. Options include SHA1, SHA256 and SHA512.
     */
    algorithm?: string;
    /**
     * The number of digits in the generated TOTP token. This value can either be 6 or 8.
     */
    digits?: number;
    /**
     * The name of the key's issuing organization.
     */
    issuer?: string;
    /**
     * Determines the size in bytes of the generated key.
     */
    key_size?: number;
    /**
     * Max number of allowed validation attempts.
     */
    max_validation_attempts?: number;
    /**
     * The unique name identifier for this MFA method.
     */
    method_name?: string;
    /**
     * The length of time used to generate a counter for the TOTP token calculation.
     */
    period?: number;
    /**
     * The pixel size of the generated square QR code.
     */
    qr_size?: number;
    /**
     * The number of delay periods that are allowed when validating a TOTP token. This value can either be 0 or 1.
     */
    skew?: number;
};

export type MfaGenerateTotpSecretRequest = {
    /**
     * The unique identifier for this MFA method.
     */
    method_id: string;
};

export type MfaValidateRequest = {
    /**
     * A map from MFA method ID to a slice of passcodes or an empty slice if the method does not use passcodes
     */
    mfa_payload: {
        [key: string]: unknown;
    };
    /**
     * ID for this MFA request
     */
    mfa_request_id: string;
};

export type MfaWriteLoginEnforcementRequest = {
    /**
     * Array of auth mount accessor IDs
     */
    auth_method_accessors?: Array<string>;
    /**
     * Array of auth mount types
     */
    auth_method_types?: Array<string>;
    /**
     * Array of identity entity IDs
     */
    identity_entity_ids?: Array<string>;
    /**
     * Array of identity group IDs
     */
    identity_group_ids?: Array<string>;
    /**
     * Array of Method IDs that determine what methods will be enforced
     */
    mfa_method_ids: Array<string>;
};

export type MountsEnableSecretsEngineRequest = {
    /**
     * Configuration for this mount, such as default_lease_ttl and max_lease_ttl.
     */
    config?: {
        [key: string]: unknown;
    };
    /**
     * User-friendly description for this mount.
     */
    description?: string;
    /**
     * Whether to give the mount access to OpenBao's external entropy.
     */
    external_entropy_access?: boolean;
    /**
     * Mark the mount as a local mount, which is not replicated and is unaffected by replication.
     */
    local?: boolean;
    /**
     * The options to pass into the backend. Should be a json object with string keys and values.
     */
    options?: {
        [key: string]: unknown;
    };
    /**
     * Name of the plugin to mount based from the name registered in the plugin catalog.
     */
    plugin_name?: string;
    /**
     * The semantic version of the plugin to use.
     */
    plugin_version?: string;
    /**
     * Whether to turn on seal wrapping for the mount.
     */
    seal_wrap?: boolean;
    /**
     * The type of the backend. Example: "passthrough"
     */
    type?: string;
};

export type MountsReadConfigurationResponse = {
    accessor?: string;
    /**
     * Configuration for this mount, such as default_lease_ttl and max_lease_ttl.
     */
    config?: {
        [key: string]: unknown;
    };
    deprecation_status?: string;
    /**
     * User-friendly description for this mount.
     */
    description?: string;
    external_entropy_access?: boolean;
    /**
     * Mark the mount as a local mount, which is not replicated and is unaffected by replication.
     */
    local?: boolean;
    /**
     * The options to pass into the backend. Should be a json object with string keys and values.
     */
    options?: {
        [key: string]: unknown;
    };
    /**
     * The semantic version of the plugin to use.
     */
    plugin_version?: string;
    running_plugin_version?: string;
    running_sha256?: string;
    /**
     * Whether to turn on seal wrapping for the mount.
     */
    seal_wrap?: boolean;
    /**
     * The type of the backend. Example: "passthrough"
     */
    type?: string;
    uuid?: string;
};

export type MountsReadTuningInformationResponse = {
    allowed_managed_keys?: Array<string>;
    /**
     * A list of headers to whitelist and allow a plugin to set on responses.
     */
    allowed_response_headers?: Array<string>;
    audit_non_hmac_request_keys?: Array<string>;
    audit_non_hmac_response_keys?: Array<string>;
    /**
     * The default lease TTL for this mount.
     */
    default_lease_ttl?: number;
    /**
     * User-friendly description for this credential backend.
     */
    description?: string;
    external_entropy_access?: boolean;
    force_no_cache?: boolean;
    listing_visibility?: string;
    /**
     * The max lease TTL for this mount.
     */
    max_lease_ttl?: number;
    /**
     * The options to pass into the backend. Should be a json object with string keys and values.
     */
    options?: {
        [key: string]: unknown;
    };
    passthrough_request_headers?: Array<string>;
    /**
     * The semantic version of the plugin to use.
     */
    plugin_version?: string;
    /**
     * The type of token to issue (service or batch).
     */
    token_type?: string;
    user_lockout_counter_reset_duration?: number;
    user_lockout_disable?: boolean;
    user_lockout_duration?: number;
    user_lockout_threshold?: number;
};

export type MountsTuneConfigurationParametersRequest = {
    allowed_managed_keys?: Array<string>;
    /**
     * A list of headers to whitelist and allow a plugin to set on responses.
     */
    allowed_response_headers?: Array<string>;
    /**
     * The list of keys in the request data object that will not be HMAC'ed by audit devices.
     */
    audit_non_hmac_request_keys?: Array<string>;
    /**
     * The list of keys in the response data object that will not be HMAC'ed by audit devices.
     */
    audit_non_hmac_response_keys?: Array<string>;
    /**
     * The default lease TTL for this mount.
     */
    default_lease_ttl?: string;
    /**
     * User-friendly description for this credential backend.
     */
    description?: string;
    /**
     * Determines the visibility of the mount in the UI-specific listing endpoint. Accepted value are 'unauth' and 'hidden', with the empty default ('') behaving like 'hidden'.
     */
    listing_visibility?: string;
    /**
     * The max lease TTL for this mount.
     */
    max_lease_ttl?: string;
    /**
     * The options to pass into the backend. Should be a json object with string keys and values.
     */
    options?: {
        [key: string]: unknown;
    };
    /**
     * A list of headers to whitelist and pass from the request to the plugin.
     */
    passthrough_request_headers?: Array<string>;
    /**
     * The semantic version of the plugin to use.
     */
    plugin_version?: string;
    /**
     * The type of token to issue (service or batch).
     */
    token_type?: string;
    /**
     * The user lockout configuration to pass into the backend. Should be a json object with string keys and values.
     */
    user_lockout_config?: {
        [key: string]: unknown;
    };
};

export type NamespacesDeleteNamespacesPathResponse = {
    /**
     * Status of the deletion operation.
     */
    status?: string;
};

export type NamespacesListNamespacesResponse = {
    /**
     * Map of namespace details by path.
     */
    key_info?: {
        [key: string]: unknown;
    };
    /**
     * List of namespace paths.
     */
    keys?: Array<string>;
};

export type NamespacesPatchNamespacesPathResponse = {
    /**
     * User provided key-value pairs.
     */
    custom_metadata?: {
        [key: string]: unknown;
    };
    /**
     * Accessor ID of the namespace.
     */
    id?: string;
    /**
     * Flag representing the lock status of the namespace.
     */
    locked?: boolean;
    /**
     * Path of the namespace.
     */
    path?: string;
    /**
     * Flag representing the taint status of the namespace.
     */
    tainted?: boolean;
    /**
     * Internal UUID of the namespace.
     */
    uuid?: string;
};

export type NamespacesReadNamespacesPathResponse = {
    /**
     * User provided key-value pairs.
     */
    custom_metadata?: {
        [key: string]: unknown;
    };
    /**
     * Accessor ID of the namespace.
     */
    id?: string;
    /**
     * Flag representing the lock status of the namespace.
     */
    locked?: boolean;
    /**
     * Path of the namespace.
     */
    path?: string;
    /**
     * Flag representing the taint status of the namespace.
     */
    tainted?: boolean;
    /**
     * Internal UUID of the namespace.
     */
    uuid?: string;
};

export type NamespacesScanNamespacesResponse = {
    /**
     * Map of namespace details by path.
     */
    key_info?: {
        [key: string]: unknown;
    };
    /**
     * List of namespace paths.
     */
    keys?: Array<string>;
};

export type NamespacesWriteNamespacesApiLockLockPathResponse = {
    /**
     * Unlock key required for unlocking the namespace.
     */
    unlock_key?: string;
};

export type NamespacesWriteNamespacesApiLockLockRequest = {
    /**
     * Path of the namespace.
     */
    path?: string;
};

export type NamespacesWriteNamespacesApiLockLockResponse = {
    /**
     * Unlock key required for unlocking the namespace.
     */
    unlock_key?: string;
};

export type NamespacesWriteNamespacesApiLockUnlockPathRequest = {
    /**
     * Unlock key required for unlocking the namespace
     */
    unlock_key: string;
};

export type NamespacesWriteNamespacesApiLockUnlockRequest = {
    /**
     * Path of the namespace.
     */
    path?: string;
    /**
     * Unlock key required for unlocking the namespace
     */
    unlock_key: string;
};

export type NamespacesWriteNamespacesPathRequest = {
    /**
     * User provided key-value pairs.
     */
    custom_metadata?: {
        [key: string]: unknown;
    };
};

export type NamespacesWriteNamespacesPathResponse = {
    /**
     * User provided key-value pairs.
     */
    custom_metadata?: {
        [key: string]: unknown;
    };
    /**
     * Accessor ID of the namespace.
     */
    id?: string;
    /**
     * Flag representing the lock status of the namespace.
     */
    locked?: boolean;
    /**
     * Path of the namespace.
     */
    path?: string;
    /**
     * Flag representing the taint status of the namespace.
     */
    tainted?: boolean;
    /**
     * Internal UUID of the namespace.
     */
    uuid?: string;
};

export type OidcConfigureRequest = {
    /**
     * Issuer URL to be used in the iss claim of the token. If not set, OpenBao's app_addr will be used.
     */
    issuer?: string;
};

export type OidcIntrospectRequest = {
    /**
     * Optional client_id to verify
     */
    client_id?: string;
    /**
     * Token to verify
     */
    token?: string;
};

export type OidcProviderAuthorizeWithParametersRequest = {
    /**
     * The ID of the requesting client.
     */
    client_id: string;
    /**
     * The code challenge derived from the code verifier.
     */
    code_challenge?: string;
    /**
     * The method that was used to derive the code challenge. The following methods are supported: 'S256', 'plain'. Defaults to 'plain'.
     */
    code_challenge_method?: string;
    /**
     * The allowable elapsed time in seconds since the last time the end-user was actively authenticated.
     */
    max_age?: number;
    /**
     * The value that will be returned in the ID token nonce claim after a token exchange.
     */
    nonce?: string;
    /**
     * The redirection URI to which the response will be sent.
     */
    redirect_uri: string;
    /**
     * The OIDC authentication flow to be used. The following response types are supported: 'code'
     */
    response_type: string;
    /**
     * A space-delimited, case-sensitive list of scopes to be requested. The 'openid' scope is required.
     */
    scope: string;
    /**
     * The value used to maintain state between the authentication request and client.
     */
    state?: string;
};

export type OidcProviderTokenRequest = {
    /**
     * The ID of the requesting client.
     */
    client_id?: string;
    /**
     * The secret of the requesting client.
     */
    client_secret?: string;
    /**
     * The authorization code received from the provider's authorization endpoint.
     */
    code: string;
    /**
     * The code verifier associated with the authorization code.
     */
    code_verifier?: string;
    /**
     * The authorization grant type. The following grant types are supported: 'authorization_code'.
     */
    grant_type: string;
    /**
     * The callback location where the authentication response was sent.
     */
    redirect_uri: string;
};

export type OidcRotateKeyRequest = {
    /**
     * Controls how long the public portion of a key will be available for verification after being rotated. Setting verification_ttl here will override the verification_ttl set on the key.
     */
    verification_ttl?: number;
};

export type OidcWriteAssignmentRequest = {
    /**
     * Comma separated string or array of identity entity IDs
     */
    entity_ids?: Array<string>;
    /**
     * Comma separated string or array of identity group IDs
     */
    group_ids?: Array<string>;
};

export type OidcWriteClientRequest = {
    /**
     * The time-to-live for access tokens obtained by the client.
     */
    access_token_ttl?: number;
    /**
     * Comma separated string or array of assignment resources.
     */
    assignments?: Array<string>;
    /**
     * The client type based on its ability to maintain confidentiality of credentials. The following client types are supported: 'confidential', 'public'. Defaults to 'confidential'.
     */
    client_type?: string;
    /**
     * The time-to-live for ID tokens obtained by the client.
     */
    id_token_ttl?: number;
    /**
     * A reference to a named key resource. Cannot be modified after creation. Defaults to the 'default' key.
     */
    key?: string;
    /**
     * Comma separated string or array of redirect URIs used by the client. One of these values must exactly match the redirect_uri parameter value used in each authentication request.
     */
    redirect_uris?: Array<string>;
};

export type OidcWriteKeyRequest = {
    /**
     * Signing algorithm to use. This will default to RS256.
     */
    algorithm?: string;
    /**
     * Comma separated string or array of role client ids allowed to use this key for signing. If empty no roles are allowed. If "*" all roles are allowed.
     */
    allowed_client_ids?: Array<string>;
    /**
     * How often to generate a new keypair.
     */
    rotation_period?: number;
    /**
     * Controls how long the public portion of a key will be available for verification after being rotated.
     */
    verification_ttl?: number;
};

export type OidcWriteProviderRequest = {
    /**
     * The client IDs that are permitted to use the provider
     */
    allowed_client_ids?: Array<string>;
    /**
     * Specifies what will be used for the iss claim of ID tokens.
     */
    issuer?: string;
    /**
     * The scopes supported for requesting on the provider
     */
    scopes_supported?: Array<string>;
};

export type OidcWriteRoleRequest = {
    /**
     * Optional client_id
     */
    client_id?: string;
    /**
     * The OIDC key to use for generating tokens. The specified key must already exist.
     */
    key: string;
    /**
     * The template string to use for generating tokens. This may be in string-ified JSON or base64 format.
     */
    template?: string;
    /**
     * TTL of the tokens generated against the role.
     */
    ttl?: number;
};

export type OidcWriteScopeRequest = {
    /**
     * The description of the scope
     */
    description?: string;
    /**
     * The template string to use for the scope. This may be in string-ified JSON or base64 format.
     */
    template?: string;
};

export type PersonaCreateRequest = {
    /**
     * Entity ID to which this persona belongs to
     */
    entity_id?: string;
    /**
     * ID of the persona
     */
    id?: string;
    /**
     * Metadata to be associated with the persona. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: bao <command> <path> metadata=key1=value1 metadata=key2=value2
     */
    metadata?: {
        [key: string]: unknown;
    };
    /**
     * Mount accessor to which this persona belongs to
     */
    mount_accessor?: string;
    /**
     * Name of the persona
     */
    name?: string;
};

export type PersonaUpdateByIdRequest = {
    /**
     * Entity ID to which this persona should be tied to
     */
    entity_id?: string;
    /**
     * Metadata to be associated with the persona. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: bao <command> <path> metadata=key1=value1 metadata=key2=value2
     */
    metadata?: {
        [key: string]: unknown;
    };
    /**
     * Mount accessor to which this persona belongs to
     */
    mount_accessor?: string;
    /**
     * Name of the persona
     */
    name?: string;
};

export type PluginsCatalogListPluginsResponse = {
    detailed?: {
        [key: string]: unknown;
    };
};

export type PluginsCatalogListPluginsWithTypeResponse = {
    /**
     * List of plugin names in the catalog
     */
    keys?: Array<string>;
};

export type PluginsCatalogReadPluginConfigurationResponse = {
    /**
     * The args passed to plugin command.
     */
    args?: Array<string>;
    builtin?: boolean;
    /**
     * The command used to start the plugin. The executable defined in this command must exist in OpenBao's plugin directory.
     */
    command?: string;
    deprecation_status?: string;
    /**
     * The name of the plugin
     */
    name?: string;
    /**
     * The SHA256 sum of the executable used in the command field. This should be HEX encoded.
     */
    sha256?: string;
    /**
     * The semantic version of the plugin to use.
     */
    version?: string;
};

export type PluginsCatalogReadPluginConfigurationWithTypeResponse = {
    /**
     * The args passed to plugin command.
     */
    args?: Array<string>;
    builtin?: boolean;
    /**
     * The command used to start the plugin. The executable defined in this command must exist in OpenBao's plugin directory.
     */
    command?: string;
    deprecation_status?: string;
    /**
     * The name of the plugin
     */
    name?: string;
    /**
     * The SHA256 sum of the executable used in the command field. This should be HEX encoded.
     */
    sha256?: string;
    /**
     * The semantic version of the plugin to use.
     */
    version?: string;
};

export type PluginsCatalogRegisterPluginRequest = {
    /**
     * The args passed to plugin command.
     */
    args?: Array<string>;
    /**
     * The command used to start the plugin. The executable defined in this command must exist in OpenBao's plugin directory.
     */
    command?: string;
    /**
     * The environment variables passed to plugin command. Each entry is of the form "key=value".
     */
    env?: Array<string>;
    /**
     * The SHA256 sum of the executable used in the command field. This should be HEX encoded.
     */
    sha256?: string;
    /**
     * The type of the plugin, may be auth, secret, or database
     */
    type?: string;
    /**
     * The semantic version of the plugin to use.
     */
    version?: string;
};

export type PluginsCatalogRegisterPluginWithTypeRequest = {
    /**
     * The args passed to plugin command.
     */
    args?: Array<string>;
    /**
     * The command used to start the plugin. The executable defined in this command must exist in OpenBao's plugin directory.
     */
    command?: string;
    /**
     * The environment variables passed to plugin command. Each entry is of the form "key=value".
     */
    env?: Array<string>;
    /**
     * The SHA256 sum of the executable used in the command field. This should be HEX encoded.
     */
    sha256?: string;
    /**
     * The semantic version of the plugin to use.
     */
    version?: string;
};

export type PluginsReloadBackendsRequest = {
    /**
     * The mount paths of the plugin backends to reload.
     */
    mounts?: Array<string>;
    /**
     * The name of the plugin to reload, as registered in the plugin catalog.
     */
    plugin?: string;
    scope?: string;
};

export type PluginsReloadBackendsResponse = {
    reload_id?: string;
};

export type PoliciesGeneratePasswordFromPasswordPolicyResponse = {
    password?: string;
};

export type PoliciesListAclPoliciesResponse = {
    keys?: Array<string>;
    policies?: Array<string>;
};

export type PoliciesListPasswordPoliciesResponse = {
    keys?: Array<string>;
};

export type PoliciesListResponse = {
    keys?: Array<string>;
    policies?: Array<string>;
};

export type PoliciesReadAclPolicy2Response = {
    cas_required?: boolean;
    expiration?: string;
    modified?: string;
    name?: string;
    policy?: string;
    rules?: string;
    version?: number;
};

export type PoliciesReadAclPolicyResponse = {
    cas_required?: boolean;
    expiration?: string;
    modified?: string;
    name?: string;
    policy?: string;
    rules?: string;
    version?: number;
};

export type PoliciesReadPasswordPolicyResponse = {
    policy?: string;
};

export type PoliciesWriteAclPolicy2Request = {
    /**
     * The rules of the policy.
     */
    cas?: number;
    /**
     * The rules of the policy.
     */
    cas_required?: boolean;
    /**
     * The rules of the policy.
     */
    expiration?: string;
    /**
     * The rules of the policy.
     */
    policy?: string;
    /**
     * The rules of the policy.
     * @deprecated
     */
    rules?: string;
    /**
     * The rules of the policy.
     */
    ttl?: number;
};

export type PoliciesWriteAclPolicyRequest = {
    /**
     * The rules of the policy.
     */
    cas?: number;
    /**
     * The rules of the policy.
     */
    cas_required?: boolean;
    /**
     * The rules of the policy.
     */
    expiration?: string;
    /**
     * The rules of the policy.
     */
    policy?: string;
    /**
     * The rules of the policy.
     */
    ttl?: number;
};

export type PoliciesWritePasswordPolicyRequest = {
    /**
     * The password policy
     */
    policy?: string;
};

export type QueryTokenAccessorCapabilitiesRequest = {
    /**
     * Accessor of the token for which capabilities are being queried.
     */
    accessor?: string;
    /**
     * Use 'paths' instead.
     * @deprecated
     */
    path?: Array<string>;
    /**
     * Paths on which capabilities are being queried.
     */
    paths?: Array<string>;
};

export type QueryTokenCapabilitiesRequest = {
    /**
     * Use 'paths' instead.
     * @deprecated
     */
    path?: Array<string>;
    /**
     * Paths on which capabilities are being queried.
     */
    paths?: Array<string>;
    /**
     * Token for which capabilities are being queried.
     */
    token?: string;
};

export type QueryTokenSelfCapabilitiesRequest = {
    /**
     * Use 'paths' instead.
     * @deprecated
     */
    path?: Array<string>;
    /**
     * Paths on which capabilities are being queried.
     */
    paths?: Array<string>;
    /**
     * Token for which capabilities are being queried.
     */
    token?: string;
};

export type RateLimitQuotasConfigureRequest = {
    /**
     * If set, starts audit logging of requests that get rejected due to rate limit quota rule violations.
     */
    enable_rate_limit_audit_logging?: boolean;
    /**
     * If set, additional rate limit quota HTTP headers will be added to responses.
     */
    enable_rate_limit_response_headers?: boolean;
    /**
     * Specifies the list of exempt paths from all rate limit quotas. If empty no paths will be exempt.
     */
    rate_limit_exempt_paths?: Array<string>;
};

export type RateLimitQuotasListResponse = {
    keys?: Array<string>;
};

export type RateLimitQuotasReadConfigurationResponse = {
    enable_rate_limit_audit_logging?: boolean;
    enable_rate_limit_response_headers?: boolean;
    rate_limit_exempt_paths?: Array<string>;
};

export type RateLimitQuotasReadResponse = {
    block_interval?: number;
    inheritable?: boolean;
    interval?: number;
    name?: string;
    path?: string;
    rate?: number;
    role?: string;
    type?: string;
};

export type RateLimitQuotasWriteRequest = {
    /**
     * If set, when a client reaches a rate limit threshold, the client will be prohibited from any further requests until after the 'block_interval' has elapsed.
     */
    block_interval?: number;
    /**
     * If set to true, child namespaces will use this quota, unless another more specific quota exists. Can only be set on namespace quotas. A quota on the root namespace will by default be inheritable.
     */
    inheritable?: boolean;
    /**
     * The duration to enforce rate limiting for (default '1s').
     */
    interval?: number;
    /**
     * Path of the mount or namespace to apply the quota. A blank path configures a global quota. For example namespace1/ adds a quota to a full namespace, namespace1/auth/userpass adds a quota to userpass in namespace1.
     */
    path?: string;
    /**
     * The maximum number of requests in a given interval to be allowed by the quota rule. The 'rate' must be positive.
     */
    rate?: number;
    /**
     * Login role to apply this quota to. Note that when set, path must be configured to a valid auth method with a concept of roles.
     */
    role?: string;
    /**
     * Type of the quota rule.
     */
    type?: string;
};

export type RawReadPathResponse = {
    value?: string;
};

export type RawReadResponse = {
    value?: string;
};

export type RawWritePathRequest = {
    /**
     * Optional entry to list begin listing after, not required to exist. Only used in list operations.
     */
    after?: string;
    compressed?: boolean;
    compression_type?: string;
    encoding?: string;
    /**
     * Optional number of entries to return; defaults to all entries. Only used in list operations.
     */
    limit?: number;
    value?: string;
};

export type RawWriteRequest = {
    /**
     * Optional entry to list begin listing after, not required to exist. Only used in list operations.
     */
    after?: string;
    compressed?: boolean;
    compression_type?: string;
    encoding?: string;
    /**
     * Optional number of entries to return; defaults to all entries. Only used in list operations.
     */
    limit?: number;
    path?: string;
    value?: string;
};

export type ReadWrappingProperties2Response = {
    creation_path?: string;
    creation_time?: string;
    creation_ttl?: number;
};

export type ReadWrappingPropertiesRequest = {
    token?: string;
};

export type ReadWrappingPropertiesResponse = {
    creation_path?: string;
    creation_time?: string;
    creation_ttl?: number;
};

export type RekeyAttemptInitializeRequest = {
    /**
     * Specifies if using PGP-encrypted keys, whether OpenBao should also store a plaintext backup of the PGP-encrypted keys.
     */
    backup?: boolean;
    /**
     * Specifies an array of PGP public keys used to encrypt the output unseal keys. Ordering is preserved. The keys must be base64-encoded from their original binary representation. The size of this array must be the same as secret_shares.
     */
    pgp_keys?: Array<string>;
    /**
     * Turns on verification functionality
     */
    require_verification?: boolean;
    /**
     * Specifies the number of shares to split the unseal key into.
     */
    secret_shares?: number;
    /**
     * Specifies the number of shares required to reconstruct the unseal key. This must be less than or equal secret_shares. If using OpenBao HSM with auto-unsealing, this value must be the same as secret_shares.
     */
    secret_threshold?: number;
};

export type RekeyAttemptInitializeResponse = {
    backup?: boolean;
    n?: number;
    nounce?: string;
    pgp_fingerprints?: Array<string>;
    progress?: number;
    required?: number;
    started?: string;
    t?: number;
    verification_nonce?: string;
    verification_required?: boolean;
};

export type RekeyAttemptReadProgressResponse = {
    backup?: boolean;
    n?: number;
    nounce?: string;
    pgp_fingerprints?: Array<string>;
    progress?: number;
    required?: number;
    started?: string;
    t?: number;
    verification_nonce?: string;
    verification_required?: boolean;
};

export type RekeyAttemptUpdateRequest = {
    /**
     * Specifies a single unseal key share.
     */
    key?: string;
    /**
     * Specifies the nonce of the rekey attempt.
     */
    nonce?: string;
};

export type RekeyAttemptUpdateResponse = {
    backup?: boolean;
    complete?: boolean;
    keys?: Array<string>;
    keys_base64?: Array<string>;
    n?: number;
    nounce?: string;
    pgp_fingerprints?: Array<string>;
    progress?: number;
    required?: number;
    started?: string;
    t?: number;
    verification_nonce?: string;
    verification_required?: boolean;
};

export type RekeyReadBackupKeyResponse = {
    keys?: {
        [key: string]: unknown;
    };
    keys_base64?: {
        [key: string]: unknown;
    };
    nonce?: string;
};

export type RekeyReadBackupRecoveryKeyResponse = {
    keys?: {
        [key: string]: unknown;
    };
    keys_base64?: {
        [key: string]: unknown;
    };
    nonce?: string;
};

export type RekeyVerificationCancelResponse = {
    n?: number;
    nounce?: string;
    progress?: number;
    started?: string;
    t?: number;
};

export type RekeyVerificationReadProgressResponse = {
    n?: number;
    nounce?: string;
    progress?: number;
    started?: string;
    t?: number;
};

export type RekeyVerificationUpdateRequest = {
    /**
     * Specifies a single unseal share key from the new set of shares.
     */
    key?: string;
    /**
     * Specifies the nonce of the rekey verification operation.
     */
    nonce?: string;
};

export type RekeyVerificationUpdateResponse = {
    complete?: boolean;
    nounce?: string;
};

export type RemountRequest = {
    /**
     * The previous mount point.
     */
    from?: string;
    /**
     * The new mount point.
     */
    to?: string;
};

export type RemountResponse = {
    migration_id?: string;
};

export type RemountStatusResponse = {
    migration_id?: string;
    migration_info?: {
        [key: string]: unknown;
    };
};

export type RewrapRequest = {
    token?: string;
};

export type RootTokenGenerationInitialize2Request = {
    /**
     * Specifies a base64-encoded PGP public key.
     */
    pgp_key?: string;
};

export type RootTokenGenerationInitialize2Response = {
    complete?: boolean;
    encoded_root_token?: string;
    encoded_token?: string;
    nonce?: string;
    otp?: string;
    otp_length?: number;
    pgp_fingerprint?: string;
    progress?: number;
    required?: number;
    started?: boolean;
};

export type RootTokenGenerationInitializeRequest = {
    /**
     * Specifies a base64-encoded PGP public key.
     */
    pgp_key?: string;
};

export type RootTokenGenerationInitializeResponse = {
    complete?: boolean;
    encoded_root_token?: string;
    encoded_token?: string;
    nonce?: string;
    otp?: string;
    otp_length?: number;
    pgp_fingerprint?: string;
    progress?: number;
    required?: number;
    started?: boolean;
};

export type RootTokenGenerationReadProgress2Response = {
    complete?: boolean;
    encoded_root_token?: string;
    encoded_token?: string;
    nonce?: string;
    otp?: string;
    otp_length?: number;
    pgp_fingerprint?: string;
    progress?: number;
    required?: number;
    started?: boolean;
};

export type RootTokenGenerationReadProgressResponse = {
    complete?: boolean;
    encoded_root_token?: string;
    encoded_token?: string;
    nonce?: string;
    otp?: string;
    otp_length?: number;
    pgp_fingerprint?: string;
    progress?: number;
    required?: number;
    started?: boolean;
};

export type RootTokenGenerationUpdateRequest = {
    /**
     * Specifies a single unseal key share.
     */
    key?: string;
    /**
     * Specifies the nonce of the attempt.
     */
    nonce?: string;
};

export type RootTokenGenerationUpdateResponse = {
    complete?: boolean;
    encoded_root_token?: string;
    encoded_token?: string;
    nonce?: string;
    otp?: string;
    otp_length?: number;
    pgp_fingerprint?: string;
    progress?: number;
    required?: number;
    started?: boolean;
};

export type RotateAttemptInitializeRequest = {
    /**
     * Specifies if using PGP-encrypted keys, whether OpenBao should also store a plaintext backup of the said keys.
     */
    backup?: boolean;
    /**
     * Specifies an array of PGP public keys used to encrypt the output unseal keys.
     */
    pgp_keys?: Array<string>;
    /**
     * Enables verification which after successful authorization with the current unseal keys, ensures the new unseal keys are returned but the root key is not actually rotated.
     */
    require_verification?: boolean;
    /**
     * Specifies the number of shares to split the root key into.
     */
    secret_shares: number;
    /**
     * Specifies the number of shares required to reconstruct the root key.
     */
    secret_threshold: number;
};

export type RotateAttemptInitializeResponse = {
    backup?: boolean;
    complete?: boolean;
    keys?: Array<string>;
    keys_base64?: Array<string>;
    n?: number;
    nonce?: string;
    pgp_fingerprints?: Array<string>;
    progress?: number;
    required?: number;
    started?: boolean;
    t?: number;
    verification_nonce?: string;
    verification_required?: boolean;
};

export type RotateAttemptInitializeRotateRecoveryInitRequest = {
    /**
     * Specifies if using PGP-encrypted keys, whether OpenBao should also store a plaintext backup of the said keys.
     */
    backup?: boolean;
    /**
     * Specifies an array of PGP public keys used to encrypt the output unseal keys.
     */
    pgp_keys?: Array<string>;
    /**
     * Enables verification which after successful authorization with the current unseal keys, ensures the new unseal keys are returned but the root key is not actually rotated.
     */
    require_verification?: boolean;
    /**
     * Specifies the number of shares to split the root key into.
     */
    secret_shares: number;
    /**
     * Specifies the number of shares required to reconstruct the root key.
     */
    secret_threshold: number;
};

export type RotateAttemptInitializeRotateRecoveryInitResponse = {
    backup?: boolean;
    complete?: boolean;
    keys?: Array<string>;
    keys_base64?: Array<string>;
    n?: number;
    nonce?: string;
    pgp_fingerprints?: Array<string>;
    progress?: number;
    required?: number;
    started?: boolean;
    t?: number;
    verification_nonce?: string;
    verification_required?: boolean;
};

export type RotateAttemptReadProgressResponse = {
    /**
     * Specifies if using PGP-encrypted keys, whether OpenBao should also store a plaintext backup of the said keys.
     */
    backup?: boolean;
    /**
     * Specifies an array of PGP public keys used to encrypt the output unseal keys.
     */
    pgp_keys?: Array<string>;
    /**
     * Enables verification which after successful authorization with the current unseal keys, ensures the new unseal keys are returned but the root key is not actually rotated.
     */
    require_verification?: boolean;
    /**
     * Specifies the number of shares to split the root key into.
     */
    secret_shares?: number;
    /**
     * Specifies the number of shares required to reconstruct the root key.
     */
    secret_threshold?: number;
};

export type RotateAttemptReadRotateRecoveryInitResponse = {
    /**
     * Specifies if using PGP-encrypted keys, whether OpenBao should also store a plaintext backup of the said keys.
     */
    backup?: boolean;
    /**
     * Specifies an array of PGP public keys used to encrypt the output unseal keys.
     */
    pgp_keys?: Array<string>;
    /**
     * Enables verification which after successful authorization with the current unseal keys, ensures the new unseal keys are returned but the root key is not actually rotated.
     */
    require_verification?: boolean;
    /**
     * Specifies the number of shares to split the root key into.
     */
    secret_shares?: number;
    /**
     * Specifies the number of shares required to reconstruct the root key.
     */
    secret_threshold?: number;
};

export type RotateAttemptUpdateRequest = {
    /**
     * Specifies a single unseal key share.
     */
    key?: string;
    /**
     * Specifies the nonce of the rotation attempt.
     */
    nonce?: string;
};

export type RotateAttemptUpdateResponse = {
    backup?: boolean;
    complete?: boolean;
    keys?: Array<string>;
    keys_base64?: Array<string>;
    n?: number;
    nonce?: string;
    pgp_fingerprints?: Array<string>;
    progress?: number;
    required?: number;
    started?: boolean;
    t?: number;
    verification_nonce?: string;
    verification_required?: boolean;
};

export type RotateAttemptUpdateRotateRecoveryUpdateRequest = {
    /**
     * Specifies a single unseal key share.
     */
    key?: string;
    /**
     * Specifies the nonce of the rotation attempt.
     */
    nonce?: string;
};

export type RotateAttemptUpdateRotateRecoveryUpdateResponse = {
    backup?: boolean;
    complete?: boolean;
    keys?: Array<string>;
    keys_base64?: Array<string>;
    n?: number;
    nonce?: string;
    pgp_fingerprints?: Array<string>;
    progress?: number;
    required?: number;
    started?: boolean;
    t?: number;
    verification_nonce?: string;
    verification_required?: boolean;
};

export type RotateReadBackupKeyResponse = {
    keys?: Array<string>;
    keys_base64?: Array<string>;
    nonce?: string;
};

export type RotateReadRotateRecoveryBackupResponse = {
    keys?: Array<string>;
    keys_base64?: Array<string>;
    nonce?: string;
};

export type RotateVerificationCancelResponse = {
    n?: number;
    nonce?: string;
    progress?: number;
    started?: boolean;
    t?: number;
};

export type RotateVerificationCancelRotateRecoveryVerifyResponse = {
    n?: number;
    nonce?: string;
    progress?: number;
    started?: boolean;
    t?: number;
};

export type RotateVerificationReadProgressResponse = {
    n?: number;
    nonce?: string;
    progress?: number;
    started?: boolean;
    t?: number;
};

export type RotateVerificationReadRotateRecoveryVerifyResponse = {
    n?: number;
    nonce?: string;
    progress?: number;
    started?: boolean;
    t?: number;
};

export type RotateVerificationUpdateRequest = {
    /**
     * Specifies a single unseal share key from the new set of shares.
     */
    key?: string;
    /**
     * Specifies the nonce of the rotation verification operation.
     */
    nonce?: string;
};

export type RotateVerificationUpdateResponse = {
    complete?: boolean;
    nonce?: string;
};

export type RotateVerificationUpdateRotateRecoveryVerifyRequest = {
    /**
     * Specifies a single unseal share key from the new set of shares.
     */
    key?: string;
    /**
     * Specifies the nonce of the rotation verification operation.
     */
    nonce?: string;
};

export type RotateVerificationUpdateRotateRecoveryVerifyResponse = {
    complete?: boolean;
    nonce?: string;
};

export type SealStatusResponse = {
    build_date?: string;
    cluster_id?: string;
    cluster_name?: string;
    initialized?: boolean;
    migration?: boolean;
    n?: number;
    nonce?: string;
    progress?: number;
    recovery_seal?: boolean;
    sealed?: boolean;
    storage_type?: string;
    t?: number;
    type?: string;
    version?: string;
};

export type TokenCreateAgainstRoleRequest = {
    /**
     * Name to associate with this token
     */
    display_name?: string;
    /**
     * Name of the entity alias to associate with this token
     */
    entity_alias?: string;
    /**
     * Explicit Max TTL of this token
     */
    explicit_max_ttl?: string;
    /**
     * Value for the token
     */
    id?: string;
    /**
     * Use 'ttl' instead
     * @deprecated
     */
    lease?: string;
    /**
     * Arbitrary key=value metadata to associate with the token
     */
    meta?: {
        [key: string]: unknown;
    };
    /**
     * Do not include default policy for this token
     */
    no_default_policy?: boolean;
    /**
     * Create the token with no parent
     */
    no_parent?: boolean;
    /**
     * Max number of uses for this token
     */
    num_uses?: number;
    /**
     * Renew period
     */
    period?: string;
    /**
     * List of policies for the token
     */
    policies?: Array<string>;
    /**
     * Allow token to be renewed past its initial TTL up to system/mount maximum TTL
     */
    renewable?: boolean;
    /**
     * Time to live for this token
     */
    ttl?: string;
    /**
     * Token type
     */
    type?: string;
};

export type TokenCreateOrphanRequest = {
    /**
     * Name to associate with this token
     */
    display_name?: string;
    /**
     * Name of the entity alias to associate with this token
     */
    entity_alias?: string;
    /**
     * Explicit Max TTL of this token
     */
    explicit_max_ttl?: string;
    /**
     * Value for the token
     */
    id?: string;
    /**
     * Use 'ttl' instead
     * @deprecated
     */
    lease?: string;
    /**
     * Arbitrary key=value metadata to associate with the token
     */
    meta?: {
        [key: string]: unknown;
    };
    /**
     * Do not include default policy for this token
     */
    no_default_policy?: boolean;
    /**
     * Create the token with no parent
     */
    no_parent?: boolean;
    /**
     * Max number of uses for this token
     */
    num_uses?: number;
    /**
     * Renew period
     */
    period?: string;
    /**
     * List of policies for the token
     */
    policies?: Array<string>;
    /**
     * Allow token to be renewed past its initial TTL up to system/mount maximum TTL
     */
    renewable?: boolean;
    /**
     * Time to live for this token
     */
    ttl?: string;
    /**
     * Token type
     */
    type?: string;
};

export type TokenCreateRequest = {
    /**
     * Name to associate with this token
     */
    display_name?: string;
    /**
     * Name of the entity alias to associate with this token
     */
    entity_alias?: string;
    /**
     * Explicit Max TTL of this token
     */
    explicit_max_ttl?: string;
    /**
     * Value for the token
     */
    id?: string;
    /**
     * Use 'ttl' instead
     * @deprecated
     */
    lease?: string;
    /**
     * Arbitrary key=value metadata to associate with the token
     */
    meta?: {
        [key: string]: unknown;
    };
    /**
     * Do not include default policy for this token
     */
    no_default_policy?: boolean;
    /**
     * Create the token with no parent
     */
    no_parent?: boolean;
    /**
     * Max number of uses for this token
     */
    num_uses?: number;
    /**
     * Renew period
     */
    period?: string;
    /**
     * List of policies for the token
     */
    policies?: Array<string>;
    /**
     * Allow token to be renewed past its initial TTL up to system/mount maximum TTL
     */
    renewable?: boolean;
    /**
     * Time to live for this token
     */
    ttl?: string;
    /**
     * Token type
     */
    type?: string;
};

export type TokenLookUpByAccessorRequest = {
    /**
     * Accessor of the token to look up (request body)
     */
    accessor?: string;
};

export type TokenLookUpPostRequest = {
    /**
     * Token to lookup (POST request body)
     */
    token?: string;
};

export type TokenLookUpSelfPostRequest = {
    /**
     * Token to look up (unused, does not need to be set)
     */
    token?: string;
};

export type TokenLookupResponse = {
    /**
     * Token accessor
     */
    accessor?: string;
    /**
     * List of CIDR blocks bound to the token
     */
    bound_cidrs?: Array<string>;
    /**
     * Token creation time (Unix timestamp)
     */
    creation_time?: number;
    /**
     * Token creation TTL in seconds
     */
    creation_ttl?: number;
    /**
     * Display name of the token
     */
    display_name?: string;
    /**
     * Entity ID associated with the token
     */
    entity_id?: string;
    /**
     * Token expiration time
     */
    expire_time?: string;
    /**
     * Token explicit maximum TTL in seconds
     */
    explicit_max_ttl?: number;
    /**
     * Derived identity policies for external namespaces (present only when applicable)
     */
    external_namespace_policies?: {
        [key: string]: unknown;
    };
    /**
     * Token ID (may be empty for self-lookup operations)
     */
    id?: string;
    /**
     * Identity policies associated with the token (present only when token has an entity and derived policies)
     */
    identity_policies?: Array<string>;
    /**
     * Token issue time
     */
    issue_time?: string;
    /**
     * Last renewal time
     */
    last_renewal?: string;
    /**
     * Last renewal time (Unix timestamp)
     */
    last_renewal_time?: number;
    /**
     * Token metadata
     */
    meta?: {
        [key: string]: unknown;
    };
    /**
     * Namespace path
     */
    namespace_path?: string;
    /**
     * Number of uses remaining
     */
    num_uses?: number;
    /**
     * Whether the token is an orphan
     */
    orphan?: boolean;
    /**
     * Path where the token was created
     */
    path?: string;
    /**
     * Token period in seconds
     */
    period?: number;
    /**
     * List of policies associated with the token
     */
    policies?: Array<string>;
    /**
     * Whether the token is renewable
     */
    renewable?: boolean;
    /**
     * Role name used to create the token
     */
    role?: string;
    /**
     * Token TTL in seconds
     */
    ttl?: number;
    /**
     * Token type
     */
    type?: string;
};

export type TokenRenewAccessorRequest = {
    /**
     * Accessor of the token to renew (request body)
     */
    accessor?: string;
    /**
     * The desired increment in seconds to the token expiration
     */
    increment?: number;
};

export type TokenRenewRequest = {
    /**
     * The desired increment in seconds to the token expiration
     */
    increment?: number;
    /**
     * Token to renew (request body)
     */
    token?: string;
};

export type TokenRenewSelfRequest = {
    /**
     * The desired increment in seconds to the token expiration
     */
    increment?: number;
    /**
     * Token to renew (unused, does not need to be set)
     */
    token?: string;
};

export type TokenRevokeAccessorRequest = {
    /**
     * Accessor of the token (request body)
     */
    accessor?: string;
};

export type TokenRevokeOrphanRequest = {
    /**
     * Token to revoke (request body)
     */
    token?: string;
};

export type TokenRevokeRequest = {
    /**
     * Token to revoke (request body)
     */
    token?: string;
};

export type TokenWriteRoleRequest = {
    /**
     * String or JSON list of allowed entity aliases. If set, specifies the entity aliases which are allowed to be used during token generation. This field supports globbing.
     */
    allowed_entity_aliases?: Array<string>;
    /**
     * If set, tokens can be created with any subset of the policies in this list, rather than the normal semantics of tokens being a subset of the calling token's policies. The parameter is a comma-delimited string of policy names.
     */
    allowed_policies?: Array<string>;
    /**
     * If set, tokens can be created with any subset of glob matched policies in this list, rather than the normal semantics of tokens being a subset of the calling token's policies. The parameter is a comma-delimited string of policy name globs.
     */
    allowed_policies_glob?: Array<string>;
    /**
     * Use 'token_bound_cidrs' instead.
     * @deprecated
     */
    bound_cidrs?: Array<string>;
    /**
     * If set, successful token creation via this role will require that no policies in the given list are requested. The parameter is a comma-delimited string of policy names.
     */
    disallowed_policies?: Array<string>;
    /**
     * If set, successful token creation via this role will require that no requested policies glob match any of policies in this list. The parameter is a comma-delimited string of policy name globs.
     */
    disallowed_policies_glob?: Array<string>;
    /**
     * Use 'token_explicit_max_ttl' instead.
     * @deprecated
     */
    explicit_max_ttl?: number;
    /**
     * If true, tokens created via this role will be orphan tokens (have no parent)
     */
    orphan?: boolean;
    /**
     * If set, tokens created via this role will contain the given suffix as a part of their path. This can be used to assist use of the 'revoke-prefix' endpoint later on. The given suffix must match the regular expression.\w[\w-.]+\w
     */
    path_suffix?: string;
    /**
     * Use 'token_period' instead.
     * @deprecated
     */
    period?: number;
    /**
     * Tokens created via this role will be renewable or not according to this value. Defaults to "true".
     */
    renewable?: boolean;
    /**
     * Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token.
     */
    token_bound_cidrs?: Array<string>;
    /**
     * If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.
     */
    token_explicit_max_ttl?: number;
    /**
     * If true, the 'default' policy will not automatically be added to generated tokens
     */
    token_no_default_policy?: boolean;
    /**
     * The maximum number of times a token may be used, a value of zero means unlimited
     */
    token_num_uses?: number;
    /**
     * If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. "24h").
     */
    token_period?: number;
    /**
     * The type of token to generate, service or batch
     */
    token_type?: string;
};

export type UiHeadersConfigureRequest = {
    /**
     * Returns multiple values if true
     */
    multivalue?: boolean;
    /**
     * The values to set the header.
     */
    values?: Array<string>;
};

export type UiHeadersListResponse = {
    /**
     * Lists of configured UI headers. Omitted if list is empty
     */
    keys?: Array<string>;
};

export type UiHeadersReadConfigurationResponse = {
    /**
     * returns the first header value when `multivalue` request parameter is false
     */
    value?: string;
    /**
     * returns all header values when `multivalue` request parameter is true
     */
    values?: Array<string>;
};

export type UnsealRequest = {
    /**
     * Specifies a single unseal key share. This is required unless reset is true.
     */
    key?: string;
    /**
     * Specifies if previously-provided unseal keys are discarded and the unseal process is reset.
     */
    reset?: boolean;
};

export type UnsealResponse = {
    build_date?: string;
    cluster_id?: string;
    cluster_name?: string;
    initialized?: boolean;
    migration?: boolean;
    n?: number;
    nonce?: string;
    progress?: number;
    recovery_seal?: boolean;
    sealed?: boolean;
    storage_type?: string;
    t?: number;
    type?: string;
    version?: string;
};

export type UnwrapRequest = {
    token?: string;
};

export type VersionHistoryResponse = {
    key_info?: {
        [key: string]: unknown;
    };
    keys?: Array<string>;
};

export type TokenListAccessorsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Must be set to `true`
         */
        list: 'true';
    };
    url: '/auth/token/accessors';
};

export type TokenListAccessorsResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type TokenCreateData = {
    body: TokenCreateRequest;
    path?: never;
    query?: never;
    url: '/auth/token/create';
};

export type TokenCreateResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type TokenCreateOrphanData = {
    body: TokenCreateOrphanRequest;
    path?: never;
    query?: never;
    url: '/auth/token/create-orphan';
};

export type TokenCreateOrphanResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type TokenCreateAgainstRoleData = {
    body: TokenCreateAgainstRoleRequest;
    path: {
        /**
         * Name of the role
         */
        role_name: string;
    };
    query?: never;
    url: '/auth/token/create/{role_name}';
};

export type TokenCreateAgainstRoleResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type TokenLookUpGetData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/auth/token/lookup';
};

export type TokenLookUpGetResponses = {
    /**
     * OK
     */
    200: TokenLookupResponse;
};

export type TokenLookUpGetResponse = TokenLookUpGetResponses[keyof TokenLookUpGetResponses];

export type TokenLookUpPostData = {
    body: TokenLookUpPostRequest;
    path?: never;
    query?: never;
    url: '/auth/token/lookup';
};

export type TokenLookUpPostResponses = {
    /**
     * OK
     */
    200: TokenLookupResponse;
};

export type TokenLookUpPostResponse = TokenLookUpPostResponses[keyof TokenLookUpPostResponses];

export type TokenLookUpByAccessorData = {
    body: TokenLookUpByAccessorRequest;
    path?: never;
    query?: never;
    url: '/auth/token/lookup-accessor';
};

export type TokenLookUpByAccessorResponses = {
    /**
     * OK
     */
    200: TokenLookupResponse;
};

export type TokenLookUpByAccessorResponse = TokenLookUpByAccessorResponses[keyof TokenLookUpByAccessorResponses];

export type TokenLookUpSelfGetData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/auth/token/lookup-self';
};

export type TokenLookUpSelfGetResponses = {
    /**
     * OK
     */
    200: TokenLookupResponse;
};

export type TokenLookUpSelfGetResponse = TokenLookUpSelfGetResponses[keyof TokenLookUpSelfGetResponses];

export type TokenLookUpSelfPostData = {
    body: TokenLookUpSelfPostRequest;
    path?: never;
    query?: never;
    url: '/auth/token/lookup-self';
};

export type TokenLookUpSelfPostResponses = {
    /**
     * OK
     */
    200: TokenLookupResponse;
};

export type TokenLookUpSelfPostResponse = TokenLookUpSelfPostResponses[keyof TokenLookUpSelfPostResponses];

export type TokenRenewData = {
    body: TokenRenewRequest;
    path?: never;
    query?: never;
    url: '/auth/token/renew';
};

export type TokenRenewResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type TokenRenewAccessorData = {
    body: TokenRenewAccessorRequest;
    path?: never;
    query?: never;
    url: '/auth/token/renew-accessor';
};

export type TokenRenewAccessorResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type TokenRenewSelfData = {
    body: TokenRenewSelfRequest;
    path?: never;
    query?: never;
    url: '/auth/token/renew-self';
};

export type TokenRenewSelfResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type TokenRevokeData = {
    body: TokenRevokeRequest;
    path?: never;
    query?: never;
    url: '/auth/token/revoke';
};

export type TokenRevokeResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type TokenRevokeAccessorData = {
    body: TokenRevokeAccessorRequest;
    path?: never;
    query?: never;
    url: '/auth/token/revoke-accessor';
};

export type TokenRevokeAccessorResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type TokenRevokeOrphanData = {
    body: TokenRevokeOrphanRequest;
    path?: never;
    query?: never;
    url: '/auth/token/revoke-orphan';
};

export type TokenRevokeOrphanResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type TokenRevokeSelfData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/auth/token/revoke-self';
};

export type TokenRevokeSelfResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type TokenListRolesData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Must be set to `true`
         */
        list: 'true';
    };
    url: '/auth/token/roles';
};

export type TokenListRolesResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type TokenDeleteRoleData = {
    body?: never;
    path: {
        /**
         * Name of the role
         */
        role_name: string;
    };
    query?: never;
    url: '/auth/token/roles/{role_name}';
};

export type TokenDeleteRoleResponses = {
    /**
     * empty body
     */
    204: void;
};

export type TokenDeleteRoleResponse = TokenDeleteRoleResponses[keyof TokenDeleteRoleResponses];

export type TokenReadRoleData = {
    body?: never;
    path: {
        /**
         * Name of the role
         */
        role_name: string;
    };
    query?: never;
    url: '/auth/token/roles/{role_name}';
};

export type TokenReadRoleResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type TokenWriteRoleData = {
    body: TokenWriteRoleRequest;
    path: {
        /**
         * Name of the role
         */
        role_name: string;
    };
    query?: never;
    url: '/auth/token/roles/{role_name}';
};

export type TokenWriteRoleResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type TokenTidyData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/auth/token/tidy';
};

export type TokenTidyResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type CubbyholeDeleteData = {
    body?: never;
    path: {
        /**
         * Specifies the path of the secret.
         */
        path: string;
    };
    query?: never;
    url: '/cubbyhole/{path}';
};

export type CubbyholeDeleteResponses = {
    /**
     * empty body
     */
    204: void;
};

export type CubbyholeDeleteResponse = CubbyholeDeleteResponses[keyof CubbyholeDeleteResponses];

export type CubbyholeReadData = {
    body?: never;
    path: {
        /**
         * Specifies the path of the secret.
         */
        path: string;
    };
    query?: {
        /**
         * Return a list if `true`
         */
        list?: string;
    };
    url: '/cubbyhole/{path}';
};

export type CubbyholeReadResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type CubbyholeWriteData = {
    body?: never;
    path: {
        /**
         * Specifies the path of the secret.
         */
        path: string;
    };
    query?: never;
    url: '/cubbyhole/{path}';
};

export type CubbyholeWriteResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type AliasCreateData = {
    body: AliasCreateRequest;
    path?: never;
    query?: never;
    url: '/identity/alias';
};

export type AliasCreateResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type AliasListByIdData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Must be set to `true`
         */
        list: 'true';
    };
    url: '/identity/alias/id';
};

export type AliasListByIdResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type AliasDeleteByIdData = {
    body?: never;
    path: {
        /**
         * ID of the alias
         */
        id: string;
    };
    query?: never;
    url: '/identity/alias/id/{id}';
};

export type AliasDeleteByIdResponses = {
    /**
     * empty body
     */
    204: void;
};

export type AliasDeleteByIdResponse = AliasDeleteByIdResponses[keyof AliasDeleteByIdResponses];

export type AliasReadByIdData = {
    body?: never;
    path: {
        /**
         * ID of the alias
         */
        id: string;
    };
    query?: never;
    url: '/identity/alias/id/{id}';
};

export type AliasReadByIdResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type AliasUpdateByIdData = {
    body: AliasUpdateByIdRequest;
    path: {
        /**
         * ID of the alias
         */
        id: string;
    };
    query?: never;
    url: '/identity/alias/id/{id}';
};

export type AliasUpdateByIdResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type EntityCreateData = {
    body: EntityCreateRequest;
    path?: never;
    query?: never;
    url: '/identity/entity';
};

export type EntityCreateResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type EntityCreateAliasData = {
    body: EntityCreateAliasRequest;
    path?: never;
    query?: never;
    url: '/identity/entity-alias';
};

export type EntityCreateAliasResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type EntityListAliasesByIdData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Must be set to `true`
         */
        list: 'true';
    };
    url: '/identity/entity-alias/id';
};

export type EntityListAliasesByIdResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type EntityDeleteAliasByIdData = {
    body?: never;
    path: {
        /**
         * ID of the alias
         */
        id: string;
    };
    query?: never;
    url: '/identity/entity-alias/id/{id}';
};

export type EntityDeleteAliasByIdResponses = {
    /**
     * empty body
     */
    204: void;
};

export type EntityDeleteAliasByIdResponse = EntityDeleteAliasByIdResponses[keyof EntityDeleteAliasByIdResponses];

export type EntityReadAliasByIdData = {
    body?: never;
    path: {
        /**
         * ID of the alias
         */
        id: string;
    };
    query?: never;
    url: '/identity/entity-alias/id/{id}';
};

export type EntityReadAliasByIdResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type EntityUpdateAliasByIdData = {
    body: EntityUpdateAliasByIdRequest;
    path: {
        /**
         * ID of the alias
         */
        id: string;
    };
    query?: never;
    url: '/identity/entity-alias/id/{id}';
};

export type EntityUpdateAliasByIdResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type EntityBatchDeleteData = {
    body: EntityBatchDeleteRequest;
    path?: never;
    query?: never;
    url: '/identity/entity/batch-delete';
};

export type EntityBatchDeleteResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type EntityListByIdData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Must be set to `true`
         */
        list: 'true';
    };
    url: '/identity/entity/id';
};

export type EntityListByIdResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type EntityDeleteByIdData = {
    body?: never;
    path: {
        /**
         * ID of the entity. If set, updates the corresponding existing entity.
         */
        id: string;
    };
    query?: never;
    url: '/identity/entity/id/{id}';
};

export type EntityDeleteByIdResponses = {
    /**
     * empty body
     */
    204: void;
};

export type EntityDeleteByIdResponse = EntityDeleteByIdResponses[keyof EntityDeleteByIdResponses];

export type EntityReadByIdData = {
    body?: never;
    path: {
        /**
         * ID of the entity. If set, updates the corresponding existing entity.
         */
        id: string;
    };
    query?: never;
    url: '/identity/entity/id/{id}';
};

export type EntityReadByIdResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type EntityUpdateByIdData = {
    body: EntityUpdateByIdRequest;
    path: {
        /**
         * ID of the entity. If set, updates the corresponding existing entity.
         */
        id: string;
    };
    query?: never;
    url: '/identity/entity/id/{id}';
};

export type EntityUpdateByIdResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type EntityMergeData = {
    body: EntityMergeRequest;
    path?: never;
    query?: never;
    url: '/identity/entity/merge';
};

export type EntityMergeResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type EntityListByNameData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Must be set to `true`
         */
        list: 'true';
    };
    url: '/identity/entity/name';
};

export type EntityListByNameResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type EntityDeleteByNameData = {
    body?: never;
    path: {
        /**
         * Name of the entity
         */
        name: string;
    };
    query?: never;
    url: '/identity/entity/name/{name}';
};

export type EntityDeleteByNameResponses = {
    /**
     * empty body
     */
    204: void;
};

export type EntityDeleteByNameResponse = EntityDeleteByNameResponses[keyof EntityDeleteByNameResponses];

export type EntityReadByNameData = {
    body?: never;
    path: {
        /**
         * Name of the entity
         */
        name: string;
    };
    query?: never;
    url: '/identity/entity/name/{name}';
};

export type EntityReadByNameResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type EntityUpdateByNameData = {
    body: EntityUpdateByNameRequest;
    path: {
        /**
         * Name of the entity
         */
        name: string;
    };
    query?: never;
    url: '/identity/entity/name/{name}';
};

export type EntityUpdateByNameResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GroupCreateData = {
    body: GroupCreateRequest;
    path?: never;
    query?: never;
    url: '/identity/group';
};

export type GroupCreateResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GroupCreateAliasData = {
    body: GroupCreateAliasRequest;
    path?: never;
    query?: never;
    url: '/identity/group-alias';
};

export type GroupCreateAliasResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GroupListAliasesByIdData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Must be set to `true`
         */
        list: 'true';
    };
    url: '/identity/group-alias/id';
};

export type GroupListAliasesByIdResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GroupDeleteAliasByIdData = {
    body?: never;
    path: {
        /**
         * ID of the group alias.
         */
        id: string;
    };
    query?: never;
    url: '/identity/group-alias/id/{id}';
};

export type GroupDeleteAliasByIdResponses = {
    /**
     * empty body
     */
    204: void;
};

export type GroupDeleteAliasByIdResponse = GroupDeleteAliasByIdResponses[keyof GroupDeleteAliasByIdResponses];

export type GroupReadAliasByIdData = {
    body?: never;
    path: {
        /**
         * ID of the group alias.
         */
        id: string;
    };
    query?: never;
    url: '/identity/group-alias/id/{id}';
};

export type GroupReadAliasByIdResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GroupUpdateAliasByIdData = {
    body: GroupUpdateAliasByIdRequest;
    path: {
        /**
         * ID of the group alias.
         */
        id: string;
    };
    query?: never;
    url: '/identity/group-alias/id/{id}';
};

export type GroupUpdateAliasByIdResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GroupListByIdData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Must be set to `true`
         */
        list: 'true';
    };
    url: '/identity/group/id';
};

export type GroupListByIdResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GroupDeleteByIdData = {
    body?: never;
    path: {
        /**
         * ID of the group. If set, updates the corresponding existing group.
         */
        id: string;
    };
    query?: never;
    url: '/identity/group/id/{id}';
};

export type GroupDeleteByIdResponses = {
    /**
     * empty body
     */
    204: void;
};

export type GroupDeleteByIdResponse = GroupDeleteByIdResponses[keyof GroupDeleteByIdResponses];

export type GroupReadByIdData = {
    body?: never;
    path: {
        /**
         * ID of the group. If set, updates the corresponding existing group.
         */
        id: string;
    };
    query?: never;
    url: '/identity/group/id/{id}';
};

export type GroupReadByIdResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GroupUpdateByIdData = {
    body: GroupUpdateByIdRequest;
    path: {
        /**
         * ID of the group. If set, updates the corresponding existing group.
         */
        id: string;
    };
    query?: never;
    url: '/identity/group/id/{id}';
};

export type GroupUpdateByIdResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GroupListByNameData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Must be set to `true`
         */
        list: 'true';
    };
    url: '/identity/group/name';
};

export type GroupListByNameResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GroupDeleteByNameData = {
    body?: never;
    path: {
        /**
         * Name of the group.
         */
        name: string;
    };
    query?: never;
    url: '/identity/group/name/{name}';
};

export type GroupDeleteByNameResponses = {
    /**
     * empty body
     */
    204: void;
};

export type GroupDeleteByNameResponse = GroupDeleteByNameResponses[keyof GroupDeleteByNameResponses];

export type GroupReadByNameData = {
    body?: never;
    path: {
        /**
         * Name of the group.
         */
        name: string;
    };
    query?: never;
    url: '/identity/group/name/{name}';
};

export type GroupReadByNameResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GroupUpdateByNameData = {
    body: GroupUpdateByNameRequest;
    path: {
        /**
         * Name of the group.
         */
        name: string;
    };
    query?: never;
    url: '/identity/group/name/{name}';
};

export type GroupUpdateByNameResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type EntityLookUpData = {
    body: EntityLookUpRequest;
    path?: never;
    query?: never;
    url: '/identity/lookup/entity';
};

export type EntityLookUpResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GroupLookUpData = {
    body: GroupLookUpRequest;
    path?: never;
    query?: never;
    url: '/identity/lookup/group';
};

export type GroupLookUpResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type MfaListLoginEnforcementsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Must be set to `true`
         */
        list: 'true';
    };
    url: '/identity/mfa/login-enforcement';
};

export type MfaListLoginEnforcementsResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type MfaDeleteLoginEnforcementData = {
    body?: never;
    path: {
        /**
         * Name for this login enforcement configuration
         */
        name: string;
    };
    query?: never;
    url: '/identity/mfa/login-enforcement/{name}';
};

export type MfaDeleteLoginEnforcementResponses = {
    /**
     * empty body
     */
    204: void;
};

export type MfaDeleteLoginEnforcementResponse = MfaDeleteLoginEnforcementResponses[keyof MfaDeleteLoginEnforcementResponses];

export type MfaReadLoginEnforcementData = {
    body?: never;
    path: {
        /**
         * Name for this login enforcement configuration
         */
        name: string;
    };
    query?: never;
    url: '/identity/mfa/login-enforcement/{name}';
};

export type MfaReadLoginEnforcementResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type MfaWriteLoginEnforcementData = {
    body: MfaWriteLoginEnforcementRequest;
    path: {
        /**
         * Name for this login enforcement configuration
         */
        name: string;
    };
    query?: never;
    url: '/identity/mfa/login-enforcement/{name}';
};

export type MfaWriteLoginEnforcementResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type MfaListMethodsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Must be set to `true`
         */
        list: 'true';
    };
    url: '/identity/mfa/method';
};

export type MfaListMethodsResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type MfaListDuoMethodsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Must be set to `true`
         */
        list: 'true';
    };
    url: '/identity/mfa/method/duo';
};

export type MfaListDuoMethodsResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type MfaDeleteDuoMethodData = {
    body?: never;
    path: {
        /**
         * The unique identifier for this MFA method.
         */
        method_id: string;
    };
    query?: never;
    url: '/identity/mfa/method/duo/{method_id}';
};

export type MfaDeleteDuoMethodResponses = {
    /**
     * empty body
     */
    204: void;
};

export type MfaDeleteDuoMethodResponse = MfaDeleteDuoMethodResponses[keyof MfaDeleteDuoMethodResponses];

export type MfaReadDuoMethodConfigurationData = {
    body?: never;
    path: {
        /**
         * The unique identifier for this MFA method.
         */
        method_id: string;
    };
    query?: never;
    url: '/identity/mfa/method/duo/{method_id}';
};

export type MfaReadDuoMethodConfigurationResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type MfaConfigureDuoMethodData = {
    body: MfaConfigureDuoMethodRequest;
    path: {
        /**
         * The unique identifier for this MFA method.
         */
        method_id: string;
    };
    query?: never;
    url: '/identity/mfa/method/duo/{method_id}';
};

export type MfaConfigureDuoMethodResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type MfaListOktaMethodsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Must be set to `true`
         */
        list: 'true';
    };
    url: '/identity/mfa/method/okta';
};

export type MfaListOktaMethodsResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type MfaDeleteOktaMethodData = {
    body?: never;
    path: {
        /**
         * The unique identifier for this MFA method.
         */
        method_id: string;
    };
    query?: never;
    url: '/identity/mfa/method/okta/{method_id}';
};

export type MfaDeleteOktaMethodResponses = {
    /**
     * empty body
     */
    204: void;
};

export type MfaDeleteOktaMethodResponse = MfaDeleteOktaMethodResponses[keyof MfaDeleteOktaMethodResponses];

export type MfaReadOktaMethodConfigurationData = {
    body?: never;
    path: {
        /**
         * The unique identifier for this MFA method.
         */
        method_id: string;
    };
    query?: never;
    url: '/identity/mfa/method/okta/{method_id}';
};

export type MfaReadOktaMethodConfigurationResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type MfaConfigureOktaMethodData = {
    body: MfaConfigureOktaMethodRequest;
    path: {
        /**
         * The unique identifier for this MFA method.
         */
        method_id: string;
    };
    query?: never;
    url: '/identity/mfa/method/okta/{method_id}';
};

export type MfaConfigureOktaMethodResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type MfaListPingIdMethodsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Must be set to `true`
         */
        list: 'true';
    };
    url: '/identity/mfa/method/pingid';
};

export type MfaListPingIdMethodsResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type MfaDeletePingIdMethodData = {
    body?: never;
    path: {
        /**
         * The unique identifier for this MFA method.
         */
        method_id: string;
    };
    query?: never;
    url: '/identity/mfa/method/pingid/{method_id}';
};

export type MfaDeletePingIdMethodResponses = {
    /**
     * empty body
     */
    204: void;
};

export type MfaDeletePingIdMethodResponse = MfaDeletePingIdMethodResponses[keyof MfaDeletePingIdMethodResponses];

export type MfaReadPingIdMethodConfigurationData = {
    body?: never;
    path: {
        /**
         * The unique identifier for this MFA method.
         */
        method_id: string;
    };
    query?: never;
    url: '/identity/mfa/method/pingid/{method_id}';
};

export type MfaReadPingIdMethodConfigurationResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type MfaConfigurePingIdMethodData = {
    body: MfaConfigurePingIdMethodRequest;
    path: {
        /**
         * The unique identifier for this MFA method.
         */
        method_id: string;
    };
    query?: never;
    url: '/identity/mfa/method/pingid/{method_id}';
};

export type MfaConfigurePingIdMethodResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type MfaListTotpMethodsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Must be set to `true`
         */
        list: 'true';
    };
    url: '/identity/mfa/method/totp';
};

export type MfaListTotpMethodsResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type MfaAdminDestroyTotpSecretData = {
    body: MfaAdminDestroyTotpSecretRequest;
    path?: never;
    query?: never;
    url: '/identity/mfa/method/totp/admin-destroy';
};

export type MfaAdminDestroyTotpSecretResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type MfaAdminGenerateTotpSecretData = {
    body: MfaAdminGenerateTotpSecretRequest;
    path?: never;
    query?: never;
    url: '/identity/mfa/method/totp/admin-generate';
};

export type MfaAdminGenerateTotpSecretResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type MfaGenerateTotpSecretData = {
    body: MfaGenerateTotpSecretRequest;
    path?: never;
    query?: never;
    url: '/identity/mfa/method/totp/generate';
};

export type MfaGenerateTotpSecretResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type MfaDeleteTotpMethodData = {
    body?: never;
    path: {
        /**
         * The unique identifier for this MFA method.
         */
        method_id: string;
    };
    query?: never;
    url: '/identity/mfa/method/totp/{method_id}';
};

export type MfaDeleteTotpMethodResponses = {
    /**
     * empty body
     */
    204: void;
};

export type MfaDeleteTotpMethodResponse = MfaDeleteTotpMethodResponses[keyof MfaDeleteTotpMethodResponses];

export type MfaReadTotpMethodConfigurationData = {
    body?: never;
    path: {
        /**
         * The unique identifier for this MFA method.
         */
        method_id: string;
    };
    query?: never;
    url: '/identity/mfa/method/totp/{method_id}';
};

export type MfaReadTotpMethodConfigurationResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type MfaConfigureTotpMethodData = {
    body: MfaConfigureTotpMethodRequest;
    path: {
        /**
         * The unique identifier for this MFA method.
         */
        method_id: string;
    };
    query?: never;
    url: '/identity/mfa/method/totp/{method_id}';
};

export type MfaConfigureTotpMethodResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type MfaReadMethodConfigurationData = {
    body?: never;
    path: {
        /**
         * The unique identifier for this MFA method.
         */
        method_id: string;
    };
    query?: never;
    url: '/identity/mfa/method/{method_id}';
};

export type MfaReadMethodConfigurationResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type OidcReadPublicKeysData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/identity/oidc/.well-known/keys';
};

export type OidcReadPublicKeysResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type OidcReadOpenIdConfigurationData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/identity/oidc/.well-known/openid-configuration';
};

export type OidcReadOpenIdConfigurationResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type OidcListAssignmentsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Must be set to `true`
         */
        list: 'true';
    };
    url: '/identity/oidc/assignment';
};

export type OidcListAssignmentsResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type OidcDeleteAssignmentData = {
    body?: never;
    path: {
        /**
         * Name of the assignment
         */
        name: string;
    };
    query?: never;
    url: '/identity/oidc/assignment/{name}';
};

export type OidcDeleteAssignmentResponses = {
    /**
     * empty body
     */
    204: void;
};

export type OidcDeleteAssignmentResponse = OidcDeleteAssignmentResponses[keyof OidcDeleteAssignmentResponses];

export type OidcReadAssignmentData = {
    body?: never;
    path: {
        /**
         * Name of the assignment
         */
        name: string;
    };
    query?: never;
    url: '/identity/oidc/assignment/{name}';
};

export type OidcReadAssignmentResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type OidcWriteAssignmentData = {
    body: OidcWriteAssignmentRequest;
    path: {
        /**
         * Name of the assignment
         */
        name: string;
    };
    query?: never;
    url: '/identity/oidc/assignment/{name}';
};

export type OidcWriteAssignmentResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type OidcListClientsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Must be set to `true`
         */
        list: 'true';
    };
    url: '/identity/oidc/client';
};

export type OidcListClientsResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type OidcDeleteClientData = {
    body?: never;
    path: {
        /**
         * Name of the client.
         */
        name: string;
    };
    query?: never;
    url: '/identity/oidc/client/{name}';
};

export type OidcDeleteClientResponses = {
    /**
     * empty body
     */
    204: void;
};

export type OidcDeleteClientResponse = OidcDeleteClientResponses[keyof OidcDeleteClientResponses];

export type OidcReadClientData = {
    body?: never;
    path: {
        /**
         * Name of the client.
         */
        name: string;
    };
    query?: never;
    url: '/identity/oidc/client/{name}';
};

export type OidcReadClientResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type OidcWriteClientData = {
    body: OidcWriteClientRequest;
    path: {
        /**
         * Name of the client.
         */
        name: string;
    };
    query?: never;
    url: '/identity/oidc/client/{name}';
};

export type OidcWriteClientResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type OidcReadConfigurationData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/identity/oidc/config';
};

export type OidcReadConfigurationResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type OidcConfigureData = {
    body: OidcConfigureRequest;
    path?: never;
    query?: never;
    url: '/identity/oidc/config';
};

export type OidcConfigureResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type OidcIntrospectData = {
    body: OidcIntrospectRequest;
    path?: never;
    query?: never;
    url: '/identity/oidc/introspect';
};

export type OidcIntrospectResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type OidcListKeysData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Must be set to `true`
         */
        list: 'true';
    };
    url: '/identity/oidc/key';
};

export type OidcListKeysResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type OidcDeleteKeyData = {
    body?: never;
    path: {
        /**
         * Name of the key
         */
        name: string;
    };
    query?: never;
    url: '/identity/oidc/key/{name}';
};

export type OidcDeleteKeyResponses = {
    /**
     * empty body
     */
    204: void;
};

export type OidcDeleteKeyResponse = OidcDeleteKeyResponses[keyof OidcDeleteKeyResponses];

export type OidcReadKeyData = {
    body?: never;
    path: {
        /**
         * Name of the key
         */
        name: string;
    };
    query?: never;
    url: '/identity/oidc/key/{name}';
};

export type OidcReadKeyResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type OidcWriteKeyData = {
    body: OidcWriteKeyRequest;
    path: {
        /**
         * Name of the key
         */
        name: string;
    };
    query?: never;
    url: '/identity/oidc/key/{name}';
};

export type OidcWriteKeyResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type OidcRotateKeyData = {
    body: OidcRotateKeyRequest;
    path: {
        /**
         * Name of the key
         */
        name: string;
    };
    query?: never;
    url: '/identity/oidc/key/{name}/rotate';
};

export type OidcRotateKeyResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type OidcListProvidersData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Filters the list of OIDC providers to those that allow the given client ID in their set of allowed_client_ids.
         */
        allowed_client_id?: string;
        /**
         * Must be set to `true`
         */
        list: 'true';
    };
    url: '/identity/oidc/provider';
};

export type OidcListProvidersResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type OidcDeleteProviderData = {
    body?: never;
    path: {
        /**
         * Name of the provider
         */
        name: string;
    };
    query?: never;
    url: '/identity/oidc/provider/{name}';
};

export type OidcDeleteProviderResponses = {
    /**
     * empty body
     */
    204: void;
};

export type OidcDeleteProviderResponse = OidcDeleteProviderResponses[keyof OidcDeleteProviderResponses];

export type OidcReadProviderData = {
    body?: never;
    path: {
        /**
         * Name of the provider
         */
        name: string;
    };
    query?: never;
    url: '/identity/oidc/provider/{name}';
};

export type OidcReadProviderResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type OidcWriteProviderData = {
    body: OidcWriteProviderRequest;
    path: {
        /**
         * Name of the provider
         */
        name: string;
    };
    query?: never;
    url: '/identity/oidc/provider/{name}';
};

export type OidcWriteProviderResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type OidcReadProviderPublicKeysData = {
    body?: never;
    path: {
        /**
         * Name of the provider
         */
        name: string;
    };
    query?: never;
    url: '/identity/oidc/provider/{name}/.well-known/keys';
};

export type OidcReadProviderPublicKeysResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type OidcReadProviderOpenIdConfigurationData = {
    body?: never;
    path: {
        /**
         * Name of the provider
         */
        name: string;
    };
    query?: never;
    url: '/identity/oidc/provider/{name}/.well-known/openid-configuration';
};

export type OidcReadProviderOpenIdConfigurationResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type OidcProviderAuthorizeData = {
    body?: never;
    path: {
        /**
         * Name of the provider
         */
        name: string;
    };
    query?: never;
    url: '/identity/oidc/provider/{name}/authorize';
};

export type OidcProviderAuthorizeResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type OidcProviderAuthorizeWithParametersData = {
    body: OidcProviderAuthorizeWithParametersRequest;
    path: {
        /**
         * Name of the provider
         */
        name: string;
    };
    query?: never;
    url: '/identity/oidc/provider/{name}/authorize';
};

export type OidcProviderAuthorizeWithParametersResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type OidcProviderTokenData = {
    body: OidcProviderTokenRequest;
    path: {
        /**
         * Name of the provider
         */
        name: string;
    };
    query?: never;
    url: '/identity/oidc/provider/{name}/token';
};

export type OidcProviderTokenResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type OidcProviderUserInfoData = {
    body?: never;
    path: {
        /**
         * Name of the provider
         */
        name: string;
    };
    query?: never;
    url: '/identity/oidc/provider/{name}/userinfo';
};

export type OidcProviderUserInfoResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type OidcProviderUserInfo2Data = {
    body?: never;
    path: {
        /**
         * Name of the provider
         */
        name: string;
    };
    query?: never;
    url: '/identity/oidc/provider/{name}/userinfo';
};

export type OidcProviderUserInfo2Responses = {
    /**
     * OK
     */
    200: unknown;
};

export type OidcListRolesData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Must be set to `true`
         */
        list: 'true';
    };
    url: '/identity/oidc/role';
};

export type OidcListRolesResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type OidcDeleteRoleData = {
    body?: never;
    path: {
        /**
         * Name of the role
         */
        name: string;
    };
    query?: never;
    url: '/identity/oidc/role/{name}';
};

export type OidcDeleteRoleResponses = {
    /**
     * empty body
     */
    204: void;
};

export type OidcDeleteRoleResponse = OidcDeleteRoleResponses[keyof OidcDeleteRoleResponses];

export type OidcReadRoleData = {
    body?: never;
    path: {
        /**
         * Name of the role
         */
        name: string;
    };
    query?: never;
    url: '/identity/oidc/role/{name}';
};

export type OidcReadRoleResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type OidcWriteRoleData = {
    body: OidcWriteRoleRequest;
    path: {
        /**
         * Name of the role
         */
        name: string;
    };
    query?: never;
    url: '/identity/oidc/role/{name}';
};

export type OidcWriteRoleResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type OidcListScopesData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Must be set to `true`
         */
        list: 'true';
    };
    url: '/identity/oidc/scope';
};

export type OidcListScopesResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type OidcDeleteScopeData = {
    body?: never;
    path: {
        /**
         * Name of the scope
         */
        name: string;
    };
    query?: never;
    url: '/identity/oidc/scope/{name}';
};

export type OidcDeleteScopeResponses = {
    /**
     * empty body
     */
    204: void;
};

export type OidcDeleteScopeResponse = OidcDeleteScopeResponses[keyof OidcDeleteScopeResponses];

export type OidcReadScopeData = {
    body?: never;
    path: {
        /**
         * Name of the scope
         */
        name: string;
    };
    query?: never;
    url: '/identity/oidc/scope/{name}';
};

export type OidcReadScopeResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type OidcWriteScopeData = {
    body: OidcWriteScopeRequest;
    path: {
        /**
         * Name of the scope
         */
        name: string;
    };
    query?: never;
    url: '/identity/oidc/scope/{name}';
};

export type OidcWriteScopeResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type OidcGenerateTokenData = {
    body?: never;
    path: {
        /**
         * Name of the role
         */
        name: string;
    };
    query?: never;
    url: '/identity/oidc/token/{name}';
};

export type OidcGenerateTokenResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type PersonaCreateData = {
    body: PersonaCreateRequest;
    path?: never;
    query?: never;
    url: '/identity/persona';
};

export type PersonaCreateResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type PersonaListByIdData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Must be set to `true`
         */
        list: 'true';
    };
    url: '/identity/persona/id';
};

export type PersonaListByIdResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type PersonaDeleteByIdData = {
    body?: never;
    path: {
        /**
         * ID of the persona
         */
        id: string;
    };
    query?: never;
    url: '/identity/persona/id/{id}';
};

export type PersonaDeleteByIdResponses = {
    /**
     * empty body
     */
    204: void;
};

export type PersonaDeleteByIdResponse = PersonaDeleteByIdResponses[keyof PersonaDeleteByIdResponses];

export type PersonaReadByIdData = {
    body?: never;
    path: {
        /**
         * ID of the persona
         */
        id: string;
    };
    query?: never;
    url: '/identity/persona/id/{id}';
};

export type PersonaReadByIdResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type PersonaUpdateByIdData = {
    body: PersonaUpdateByIdRequest;
    path: {
        /**
         * ID of the persona
         */
        id: string;
    };
    query?: never;
    url: '/identity/persona/id/{id}';
};

export type PersonaUpdateByIdResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type AuditingListEnabledDevicesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/audit';
};

export type AuditingListEnabledDevicesResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type AuditingCalculateHashData = {
    body: AuditingCalculateHashRequest;
    path: {
        /**
         * The name of the backend. Cannot be delimited. Example: "mysql"
         */
        path: string;
    };
    query?: never;
    url: '/sys/audit-hash/{path}';
};

export type AuditingCalculateHashResponses = {
    /**
     * OK
     */
    200: AuditingCalculateHashResponse;
};

export type AuditingCalculateHashResponse2 = AuditingCalculateHashResponses[keyof AuditingCalculateHashResponses];

export type AuditingDisableDeviceData = {
    body?: never;
    path: {
        /**
         * The name of the backend. Cannot be delimited. Example: "mysql"
         */
        path: string;
    };
    query?: never;
    url: '/sys/audit/{path}';
};

export type AuditingDisableDeviceResponses = {
    /**
     * OK
     */
    204: void;
};

export type AuditingDisableDeviceResponse = AuditingDisableDeviceResponses[keyof AuditingDisableDeviceResponses];

export type AuditingEnableDeviceData = {
    body: AuditingEnableDeviceRequest;
    path: {
        /**
         * The name of the backend. Cannot be delimited. Example: "mysql"
         */
        path: string;
    };
    query?: never;
    url: '/sys/audit/{path}';
};

export type AuditingEnableDeviceResponses = {
    /**
     * OK
     */
    204: void;
};

export type AuditingEnableDeviceResponse = AuditingEnableDeviceResponses[keyof AuditingEnableDeviceResponses];

export type AuthListEnabledMethodsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/auth';
};

export type AuthListEnabledMethodsResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type AuthDisableMethodData = {
    body?: never;
    path: {
        /**
         * The path to mount to. Cannot be delimited. Example: "user"
         */
        path: string;
    };
    query?: never;
    url: '/sys/auth/{path}';
};

export type AuthDisableMethodResponses = {
    /**
     * OK
     */
    204: void;
};

export type AuthDisableMethodResponse = AuthDisableMethodResponses[keyof AuthDisableMethodResponses];

export type AuthReadConfigurationData = {
    body?: never;
    path: {
        /**
         * The path to mount to. Cannot be delimited. Example: "user"
         */
        path: string;
    };
    query?: never;
    url: '/sys/auth/{path}';
};

export type AuthReadConfigurationResponses = {
    /**
     * OK
     */
    200: AuthReadConfigurationResponse;
};

export type AuthReadConfigurationResponse2 = AuthReadConfigurationResponses[keyof AuthReadConfigurationResponses];

export type AuthEnableMethodData = {
    body: AuthEnableMethodRequest;
    path: {
        /**
         * The path to mount to. Cannot be delimited. Example: "user"
         */
        path: string;
    };
    query?: never;
    url: '/sys/auth/{path}';
};

export type AuthEnableMethodResponses = {
    /**
     * OK
     */
    204: void;
};

export type AuthEnableMethodResponse = AuthEnableMethodResponses[keyof AuthEnableMethodResponses];

export type AuthReadTuningInformationData = {
    body?: never;
    path: {
        /**
         * Tune the configuration parameters for an auth path.
         */
        path: string;
    };
    query?: never;
    url: '/sys/auth/{path}/tune';
};

export type AuthReadTuningInformationResponses = {
    /**
     * OK
     */
    200: AuthReadTuningInformationResponse;
};

export type AuthReadTuningInformationResponse2 = AuthReadTuningInformationResponses[keyof AuthReadTuningInformationResponses];

export type AuthTuneConfigurationParametersData = {
    body: AuthTuneConfigurationParametersRequest;
    path: {
        /**
         * Tune the configuration parameters for an auth path.
         */
        path: string;
    };
    query?: never;
    url: '/sys/auth/{path}/tune';
};

export type AuthTuneConfigurationParametersResponses = {
    /**
     * OK
     */
    204: void;
};

export type AuthTuneConfigurationParametersResponse = AuthTuneConfigurationParametersResponses[keyof AuthTuneConfigurationParametersResponses];

export type QueryTokenCapabilitiesData = {
    body: QueryTokenCapabilitiesRequest;
    path?: never;
    query?: never;
    url: '/sys/capabilities';
};

export type QueryTokenCapabilitiesResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type QueryTokenAccessorCapabilitiesData = {
    body: QueryTokenAccessorCapabilitiesRequest;
    path?: never;
    query?: never;
    url: '/sys/capabilities-accessor';
};

export type QueryTokenAccessorCapabilitiesResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type QueryTokenSelfCapabilitiesData = {
    body: QueryTokenSelfCapabilitiesRequest;
    path?: never;
    query?: never;
    url: '/sys/capabilities-self';
};

export type QueryTokenSelfCapabilitiesResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type AuditingListRequestHeadersData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/config/auditing/request-headers';
};

export type AuditingListRequestHeadersResponses = {
    /**
     * OK
     */
    200: AuditingListRequestHeadersResponse;
};

export type AuditingListRequestHeadersResponse2 = AuditingListRequestHeadersResponses[keyof AuditingListRequestHeadersResponses];

export type AuditingDisableRequestHeaderData = {
    body?: never;
    path: {
        header: string;
    };
    query?: never;
    url: '/sys/config/auditing/request-headers/{header}';
};

export type AuditingDisableRequestHeaderResponses = {
    /**
     * OK
     */
    204: void;
};

export type AuditingDisableRequestHeaderResponse = AuditingDisableRequestHeaderResponses[keyof AuditingDisableRequestHeaderResponses];

export type AuditingReadRequestHeaderInformationData = {
    body?: never;
    path: {
        header: string;
    };
    query?: never;
    url: '/sys/config/auditing/request-headers/{header}';
};

export type AuditingReadRequestHeaderInformationResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type AuditingEnableRequestHeaderData = {
    body: AuditingEnableRequestHeaderRequest;
    path: {
        header: string;
    };
    query?: never;
    url: '/sys/config/auditing/request-headers/{header}';
};

export type AuditingEnableRequestHeaderResponses = {
    /**
     * OK
     */
    204: void;
};

export type AuditingEnableRequestHeaderResponse = AuditingEnableRequestHeaderResponses[keyof AuditingEnableRequestHeaderResponses];

export type CorsDeleteConfigurationData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/config/cors';
};

export type CorsDeleteConfigurationResponses = {
    /**
     * OK
     */
    204: void;
};

export type CorsDeleteConfigurationResponse = CorsDeleteConfigurationResponses[keyof CorsDeleteConfigurationResponses];

export type CorsReadConfigurationData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/config/cors';
};

export type CorsReadConfigurationResponses = {
    /**
     * OK
     */
    200: CorsReadConfigurationResponse;
};

export type CorsReadConfigurationResponse2 = CorsReadConfigurationResponses[keyof CorsReadConfigurationResponses];

export type CorsConfigureData = {
    body: CorsConfigureRequest;
    path?: never;
    query?: never;
    url: '/sys/config/cors';
};

export type CorsConfigureResponses = {
    /**
     * OK
     */
    204: void;
};

export type CorsConfigureResponse = CorsConfigureResponses[keyof CorsConfigureResponses];

export type ReloadSubsystemData = {
    body?: never;
    path: {
        subsystem: string;
    };
    query?: never;
    url: '/sys/config/reload/{subsystem}';
};

export type ReloadSubsystemResponses = {
    /**
     * OK
     */
    204: void;
};

export type ReloadSubsystemResponse = ReloadSubsystemResponses[keyof ReloadSubsystemResponses];

export type ReadSanitizedConfigurationStateData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/config/state/sanitized';
};

export type ReadSanitizedConfigurationStateResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type UiHeadersListData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Must be set to `true`
         */
        list: 'true';
    };
    url: '/sys/config/ui/headers';
};

export type UiHeadersListResponses = {
    200: UiHeadersListResponse;
};

export type UiHeadersListResponse2 = UiHeadersListResponses[keyof UiHeadersListResponses];

export type UiHeadersDeleteConfigurationData = {
    body?: never;
    path: {
        /**
         * The name of the header.
         */
        header: string;
    };
    query?: never;
    url: '/sys/config/ui/headers/{header}';
};

export type UiHeadersDeleteConfigurationResponses = {
    /**
     * OK
     */
    204: void;
};

export type UiHeadersDeleteConfigurationResponse = UiHeadersDeleteConfigurationResponses[keyof UiHeadersDeleteConfigurationResponses];

export type UiHeadersReadConfigurationData = {
    body?: never;
    path: {
        /**
         * The name of the header.
         */
        header: string;
    };
    query?: never;
    url: '/sys/config/ui/headers/{header}';
};

export type UiHeadersReadConfigurationResponses = {
    /**
     * OK
     */
    200: UiHeadersReadConfigurationResponse;
};

export type UiHeadersReadConfigurationResponse2 = UiHeadersReadConfigurationResponses[keyof UiHeadersReadConfigurationResponses];

export type UiHeadersConfigureData = {
    body: UiHeadersConfigureRequest;
    path: {
        /**
         * The name of the header.
         */
        header: string;
    };
    query?: never;
    url: '/sys/config/ui/headers/{header}';
};

export type UiHeadersConfigureResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type DecodeData = {
    body: DecodeRequest;
    path?: never;
    query?: never;
    url: '/sys/decode-token';
};

export type DecodeResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type RootTokenGenerationCancel2Data = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/generate-root';
};

export type RootTokenGenerationCancel2Responses = {
    /**
     * OK
     */
    204: void;
};

export type RootTokenGenerationCancel2Response = RootTokenGenerationCancel2Responses[keyof RootTokenGenerationCancel2Responses];

export type RootTokenGenerationReadProgress2Data = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/generate-root';
};

export type RootTokenGenerationReadProgress2Responses = {
    /**
     * OK
     */
    200: RootTokenGenerationReadProgress2Response;
};

export type RootTokenGenerationReadProgress2Response2 = RootTokenGenerationReadProgress2Responses[keyof RootTokenGenerationReadProgress2Responses];

export type RootTokenGenerationInitialize2Data = {
    body: RootTokenGenerationInitialize2Request;
    path?: never;
    query?: never;
    url: '/sys/generate-root';
};

export type RootTokenGenerationInitialize2Responses = {
    /**
     * OK
     */
    200: RootTokenGenerationInitialize2Response;
};

export type RootTokenGenerationInitialize2Response2 = RootTokenGenerationInitialize2Responses[keyof RootTokenGenerationInitialize2Responses];

export type RootTokenGenerationCancelData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/generate-root/attempt';
};

export type RootTokenGenerationCancelResponses = {
    /**
     * OK
     */
    204: void;
};

export type RootTokenGenerationCancelResponse = RootTokenGenerationCancelResponses[keyof RootTokenGenerationCancelResponses];

export type RootTokenGenerationReadProgressData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/generate-root/attempt';
};

export type RootTokenGenerationReadProgressResponses = {
    /**
     * OK
     */
    200: RootTokenGenerationReadProgressResponse;
};

export type RootTokenGenerationReadProgressResponse2 = RootTokenGenerationReadProgressResponses[keyof RootTokenGenerationReadProgressResponses];

export type RootTokenGenerationInitializeData = {
    body: RootTokenGenerationInitializeRequest;
    path?: never;
    query?: never;
    url: '/sys/generate-root/attempt';
};

export type RootTokenGenerationInitializeResponses = {
    /**
     * OK
     */
    200: RootTokenGenerationInitializeResponse;
};

export type RootTokenGenerationInitializeResponse2 = RootTokenGenerationInitializeResponses[keyof RootTokenGenerationInitializeResponses];

export type RootTokenGenerationUpdateData = {
    body: RootTokenGenerationUpdateRequest;
    path?: never;
    query?: never;
    url: '/sys/generate-root/update';
};

export type RootTokenGenerationUpdateResponses = {
    /**
     * OK
     */
    200: RootTokenGenerationUpdateResponse;
};

export type RootTokenGenerationUpdateResponse2 = RootTokenGenerationUpdateResponses[keyof RootTokenGenerationUpdateResponses];

export type HaStatusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/ha-status';
};

export type HaStatusResponses = {
    /**
     * OK
     */
    200: HaStatusResponse;
};

export type HaStatusResponse2 = HaStatusResponses[keyof HaStatusResponses];

export type ReadHealthStatusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/health';
};

export type ReadHealthStatusErrors = {
    /**
     * unsealed and standby
     */
    429: unknown;
    /**
     * data recovery mode replication secondary and active
     */
    472: unknown;
    /**
     * not initialized
     */
    501: unknown;
    /**
     * sealed
     */
    503: unknown;
};

export type ReadHealthStatusResponses = {
    /**
     * initialized, unsealed, and active
     */
    200: unknown;
};

export type CollectHostInformationData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/host-info';
};

export type CollectHostInformationResponses = {
    /**
     * OK
     */
    200: CollectHostInformationResponse;
};

export type CollectHostInformationResponse2 = CollectHostInformationResponses[keyof CollectHostInformationResponses];

export type CollectInFlightRequestInformationData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/in-flight-req';
};

export type CollectInFlightRequestInformationResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type ReadInitializationStatusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/init';
};

export type ReadInitializationStatusResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type InitializeSystemData = {
    body: InitializeSystemRequest;
    path?: never;
    query?: never;
    url: '/sys/init';
};

export type InitializeSystemResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type InternalCountEntitiesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/internal/counters/entities';
};

export type InternalCountEntitiesResponses = {
    /**
     * OK
     */
    200: InternalCountEntitiesResponse;
};

export type InternalCountEntitiesResponse2 = InternalCountEntitiesResponses[keyof InternalCountEntitiesResponses];

export type InternalCountRequestsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/internal/counters/requests';
};

export type InternalCountRequestsResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type InternalCountTokensData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/internal/counters/tokens';
};

export type InternalCountTokensResponses = {
    /**
     * OK
     */
    200: InternalCountTokensResponse;
};

export type InternalCountTokensResponse2 = InternalCountTokensResponses[keyof InternalCountTokensResponses];

export type InternalInspectRequestData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/internal/inspect/request';
};

export type InternalInspectRequestResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type InternalInspectRouterData = {
    body?: never;
    path: {
        /**
         * Name of subtree being observed
         */
        tag: string;
    };
    query?: never;
    url: '/sys/internal/inspect/router/{tag}';
};

export type InternalInspectRouterResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type InternalGenerateOpenApiDocumentData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Use generic mount paths
         */
        generic_mount_paths?: boolean;
    };
    url: '/sys/internal/specs/openapi';
};

export type InternalGenerateOpenApiDocumentResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type InternalGenerateOpenApiDocumentWithParametersData = {
    body: InternalGenerateOpenApiDocumentWithParametersRequest;
    path?: never;
    query?: {
        /**
         * Use generic mount paths
         */
        generic_mount_paths?: boolean;
    };
    url: '/sys/internal/specs/openapi';
};

export type InternalGenerateOpenApiDocumentWithParametersResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type InternalUiListEnabledFeatureFlagsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/internal/ui/feature-flags';
};

export type InternalUiListEnabledFeatureFlagsResponses = {
    /**
     * OK
     */
    200: InternalUiListEnabledFeatureFlagsResponse;
};

export type InternalUiListEnabledFeatureFlagsResponse2 = InternalUiListEnabledFeatureFlagsResponses[keyof InternalUiListEnabledFeatureFlagsResponses];

export type InternalUiListEnabledVisibleMountsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/internal/ui/mounts';
};

export type InternalUiListEnabledVisibleMountsResponses = {
    /**
     * OK
     */
    200: InternalUiListEnabledVisibleMountsResponse;
};

export type InternalUiListEnabledVisibleMountsResponse2 = InternalUiListEnabledVisibleMountsResponses[keyof InternalUiListEnabledVisibleMountsResponses];

export type InternalUiReadMountInformationData = {
    body?: never;
    path: {
        /**
         * The path of the mount.
         */
        path: string;
    };
    query?: never;
    url: '/sys/internal/ui/mounts/{path}';
};

export type InternalUiReadMountInformationResponses = {
    /**
     * OK
     */
    200: InternalUiReadMountInformationResponse;
};

export type InternalUiReadMountInformationResponse2 = InternalUiReadMountInformationResponses[keyof InternalUiReadMountInformationResponses];

export type InternalUiListNamespacesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/internal/ui/namespaces';
};

export type InternalUiListNamespacesResponses = {
    /**
     * OK
     */
    200: InternalUiListNamespacesResponse;
};

export type InternalUiListNamespacesResponse2 = InternalUiListNamespacesResponses[keyof InternalUiListNamespacesResponses];

export type InternalUiReadResultantAclData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/internal/ui/resultant-acl';
};

export type InternalUiReadResultantAclResponses = {
    /**
     * OK
     */
    200: InternalUiReadResultantAclResponse;
    /**
     * empty response returned if no client token
     */
    204: void;
};

export type InternalUiReadResultantAclResponse2 = InternalUiReadResultantAclResponses[keyof InternalUiReadResultantAclResponses];

export type EncryptionKeyStatusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/key-status';
};

export type EncryptionKeyStatusResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type LeaderStatusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/leader';
};

export type LeaderStatusResponses = {
    /**
     * OK
     */
    200: LeaderStatusResponse;
};

export type LeaderStatusResponse2 = LeaderStatusResponses[keyof LeaderStatusResponses];

export type LeasesListData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/leases';
};

export type LeasesListResponses = {
    /**
     * OK
     */
    200: LeasesListResponse;
};

export type LeasesListResponse2 = LeasesListResponses[keyof LeasesListResponses];

export type LeasesCountData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/leases/count';
};

export type LeasesCountResponses = {
    /**
     * OK
     */
    200: LeasesCountResponse;
};

export type LeasesCountResponse2 = LeasesCountResponses[keyof LeasesCountResponses];

export type LeasesReadLeaseData = {
    body: LeasesReadLeaseRequest;
    path?: never;
    query?: never;
    url: '/sys/leases/lookup';
};

export type LeasesReadLeaseResponses = {
    /**
     * OK
     */
    200: LeasesReadLeaseResponse;
};

export type LeasesReadLeaseResponse2 = LeasesReadLeaseResponses[keyof LeasesReadLeaseResponses];

export type LeasesLookUpData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Must be set to `true`
         */
        list: 'true';
    };
    url: '/sys/leases/lookup/';
};

export type LeasesLookUpResponses = {
    /**
     * OK
     */
    200: LeasesLookUpResponse;
};

export type LeasesLookUpResponse2 = LeasesLookUpResponses[keyof LeasesLookUpResponses];

export type LeasesLookUpWithPrefixData = {
    body?: never;
    path: {
        /**
         * The path to list leases under. Example: "aws/creds/deploy"
         */
        prefix: string;
    };
    query: {
        /**
         * Must be set to `true`
         */
        list: 'true';
    };
    url: '/sys/leases/lookup/{prefix}';
};

export type LeasesLookUpWithPrefixResponses = {
    /**
     * OK
     */
    200: LeasesLookUpWithPrefixResponse;
};

export type LeasesLookUpWithPrefixResponse2 = LeasesLookUpWithPrefixResponses[keyof LeasesLookUpWithPrefixResponses];

export type LeasesRenewLeaseData = {
    body: LeasesRenewLeaseRequest;
    path?: never;
    query?: never;
    url: '/sys/leases/renew';
};

export type LeasesRenewLeaseResponses = {
    /**
     * OK
     */
    204: void;
};

export type LeasesRenewLeaseResponse = LeasesRenewLeaseResponses[keyof LeasesRenewLeaseResponses];

export type LeasesRenewLeaseWithIdData = {
    body: LeasesRenewLeaseWithIdRequest;
    path: {
        /**
         * The lease identifier to renew. This is included with a lease.
         */
        url_lease_id: string;
    };
    query?: never;
    url: '/sys/leases/renew/{url_lease_id}';
};

export type LeasesRenewLeaseWithIdResponses = {
    /**
     * OK
     */
    204: void;
};

export type LeasesRenewLeaseWithIdResponse = LeasesRenewLeaseWithIdResponses[keyof LeasesRenewLeaseWithIdResponses];

export type LeasesRevokeLeaseData = {
    body: LeasesRevokeLeaseRequest;
    path?: never;
    query?: never;
    url: '/sys/leases/revoke';
};

export type LeasesRevokeLeaseResponses = {
    /**
     * OK
     */
    204: void;
};

export type LeasesRevokeLeaseResponse = LeasesRevokeLeaseResponses[keyof LeasesRevokeLeaseResponses];

export type LeasesForceRevokeLeaseWithPrefixData = {
    body?: never;
    path: {
        /**
         * The path to revoke keys under. Example: "prod/aws/ops"
         */
        prefix: string;
    };
    query?: never;
    url: '/sys/leases/revoke-force/{prefix}';
};

export type LeasesForceRevokeLeaseWithPrefixResponses = {
    /**
     * OK
     */
    204: void;
};

export type LeasesForceRevokeLeaseWithPrefixResponse = LeasesForceRevokeLeaseWithPrefixResponses[keyof LeasesForceRevokeLeaseWithPrefixResponses];

export type LeasesRevokeLeaseWithPrefixData = {
    body: LeasesRevokeLeaseWithPrefixRequest;
    path: {
        /**
         * The path to revoke keys under. Example: "prod/aws/ops"
         */
        prefix: string;
    };
    query?: never;
    url: '/sys/leases/revoke-prefix/{prefix}';
};

export type LeasesRevokeLeaseWithPrefixResponses = {
    /**
     * OK
     */
    204: void;
};

export type LeasesRevokeLeaseWithPrefixResponse = LeasesRevokeLeaseWithPrefixResponses[keyof LeasesRevokeLeaseWithPrefixResponses];

export type LeasesRevokeLeaseWithIdData = {
    body: LeasesRevokeLeaseWithIdRequest;
    path: {
        /**
         * The lease identifier to renew. This is included with a lease.
         */
        url_lease_id: string;
    };
    query?: never;
    url: '/sys/leases/revoke/{url_lease_id}';
};

export type LeasesRevokeLeaseWithIdResponses = {
    /**
     * OK
     */
    204: void;
};

export type LeasesRevokeLeaseWithIdResponse = LeasesRevokeLeaseWithIdResponses[keyof LeasesRevokeLeaseWithIdResponses];

export type LeasesTidyData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/leases/tidy';
};

export type LeasesTidyResponses = {
    /**
     * OK
     */
    204: void;
};

export type LeasesTidyResponse = LeasesTidyResponses[keyof LeasesTidyResponses];

export type LockedUsersListData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/locked-users';
};

export type LockedUsersListResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type LockedUsersUnlockData = {
    body?: never;
    path: {
        /**
         * It is the name of the alias (user). For example, if the alias belongs to userpass backend, the name should be a valid username within userpass auth method. If the alias belongs to an approle auth method, the name should be a valid RoleID
         */
        alias_identifier: string;
        /**
         * MountAccessor is the identifier of the mount entry to which the user belongs
         */
        mount_accessor: string;
    };
    query?: never;
    url: '/sys/locked-users/{mount_accessor}/unlock/{alias_identifier}';
};

export type LockedUsersUnlockResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type LoggersRevertVerbosityLevelData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/loggers';
};

export type LoggersRevertVerbosityLevelResponses = {
    /**
     * OK
     */
    204: void;
};

export type LoggersRevertVerbosityLevelResponse = LoggersRevertVerbosityLevelResponses[keyof LoggersRevertVerbosityLevelResponses];

export type LoggersReadVerbosityLevelData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/loggers';
};

export type LoggersReadVerbosityLevelResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type LoggersUpdateVerbosityLevelData = {
    body: LoggersUpdateVerbosityLevelRequest;
    path?: never;
    query?: never;
    url: '/sys/loggers';
};

export type LoggersUpdateVerbosityLevelResponses = {
    /**
     * OK
     */
    204: void;
};

export type LoggersUpdateVerbosityLevelResponse = LoggersUpdateVerbosityLevelResponses[keyof LoggersUpdateVerbosityLevelResponses];

export type LoggersRevertVerbosityLevelForData = {
    body?: never;
    path: {
        /**
         * The name of the logger to be modified.
         */
        name: string;
    };
    query?: never;
    url: '/sys/loggers/{name}';
};

export type LoggersRevertVerbosityLevelForResponses = {
    /**
     * OK
     */
    204: void;
};

export type LoggersRevertVerbosityLevelForResponse = LoggersRevertVerbosityLevelForResponses[keyof LoggersRevertVerbosityLevelForResponses];

export type LoggersReadVerbosityLevelForData = {
    body?: never;
    path: {
        /**
         * The name of the logger to be modified.
         */
        name: string;
    };
    query?: never;
    url: '/sys/loggers/{name}';
};

export type LoggersReadVerbosityLevelForResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type LoggersUpdateVerbosityLevelForData = {
    body: LoggersUpdateVerbosityLevelForRequest;
    path: {
        /**
         * The name of the logger to be modified.
         */
        name: string;
    };
    query?: never;
    url: '/sys/loggers/{name}';
};

export type LoggersUpdateVerbosityLevelForResponses = {
    /**
     * OK
     */
    204: void;
};

export type LoggersUpdateVerbosityLevelForResponse = LoggersUpdateVerbosityLevelForResponses[keyof LoggersUpdateVerbosityLevelForResponses];

export type MetricsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Format to export metrics into. Currently accepts only "prometheus".
         */
        format?: string;
    };
    url: '/sys/metrics';
};

export type MetricsResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type MfaValidateData = {
    body: MfaValidateRequest;
    path?: never;
    query?: never;
    url: '/sys/mfa/validate';
};

export type MfaValidateResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type MonitorData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Output format of logs. Supported values are "standard" and "json". The default is "standard".
         */
        log_format?: string;
        /**
         * Log level to view system logs at. Currently supported values are "trace", "debug", "info", "warn", "error".
         */
        log_level?: string;
    };
    url: '/sys/monitor';
};

export type MonitorResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type MountsListSecretsEnginesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/mounts';
};

export type MountsListSecretsEnginesResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type MountsDisableSecretsEngineData = {
    body?: never;
    path: {
        /**
         * The path to mount to. Example: "aws/east"
         */
        path: string;
    };
    query?: never;
    url: '/sys/mounts/{path}';
};

export type MountsDisableSecretsEngineResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type MountsReadConfigurationData = {
    body?: never;
    path: {
        /**
         * The path to mount to. Example: "aws/east"
         */
        path: string;
    };
    query?: never;
    url: '/sys/mounts/{path}';
};

export type MountsReadConfigurationResponses = {
    /**
     * OK
     */
    200: MountsReadConfigurationResponse;
};

export type MountsReadConfigurationResponse2 = MountsReadConfigurationResponses[keyof MountsReadConfigurationResponses];

export type MountsEnableSecretsEngineData = {
    body: MountsEnableSecretsEngineRequest;
    path: {
        /**
         * The path to mount to. Example: "aws/east"
         */
        path: string;
    };
    query?: never;
    url: '/sys/mounts/{path}';
};

export type MountsEnableSecretsEngineResponses = {
    /**
     * OK
     */
    204: void;
};

export type MountsEnableSecretsEngineResponse = MountsEnableSecretsEngineResponses[keyof MountsEnableSecretsEngineResponses];

export type MountsReadTuningInformationData = {
    body?: never;
    path: {
        /**
         * The path to mount to. Example: "aws/east"
         */
        path: string;
    };
    query?: never;
    url: '/sys/mounts/{path}/tune';
};

export type MountsReadTuningInformationResponses = {
    /**
     * OK
     */
    200: MountsReadTuningInformationResponse;
};

export type MountsReadTuningInformationResponse2 = MountsReadTuningInformationResponses[keyof MountsReadTuningInformationResponses];

export type MountsTuneConfigurationParametersData = {
    body: MountsTuneConfigurationParametersRequest;
    path: {
        /**
         * The path to mount to. Example: "aws/east"
         */
        path: string;
    };
    query?: never;
    url: '/sys/mounts/{path}/tune';
};

export type MountsTuneConfigurationParametersResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type NamespacesListNamespacesData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Must be set to `true`
         */
        list: 'true';
    };
    url: '/sys/namespaces';
};

export type NamespacesListNamespacesResponses = {
    /**
     * OK
     */
    200: NamespacesListNamespacesResponse;
};

export type NamespacesListNamespacesResponse2 = NamespacesListNamespacesResponses[keyof NamespacesListNamespacesResponses];

export type NamespacesWriteNamespacesApiLockLockData = {
    body: NamespacesWriteNamespacesApiLockLockRequest;
    path?: never;
    query?: never;
    url: '/sys/namespaces/api-lock/lock';
};

export type NamespacesWriteNamespacesApiLockLockResponses = {
    /**
     * OK
     */
    200: NamespacesWriteNamespacesApiLockLockResponse;
};

export type NamespacesWriteNamespacesApiLockLockResponse2 = NamespacesWriteNamespacesApiLockLockResponses[keyof NamespacesWriteNamespacesApiLockLockResponses];

export type NamespacesWriteNamespacesApiLockLockPathData = {
    body?: never;
    path: {
        /**
         * Path of the namespace.
         */
        path: string;
    };
    query?: never;
    url: '/sys/namespaces/api-lock/lock/{path}';
};

export type NamespacesWriteNamespacesApiLockLockPathResponses = {
    /**
     * OK
     */
    200: NamespacesWriteNamespacesApiLockLockPathResponse;
};

export type NamespacesWriteNamespacesApiLockLockPathResponse2 = NamespacesWriteNamespacesApiLockLockPathResponses[keyof NamespacesWriteNamespacesApiLockLockPathResponses];

export type NamespacesWriteNamespacesApiLockUnlockData = {
    body: NamespacesWriteNamespacesApiLockUnlockRequest;
    path?: never;
    query?: never;
    url: '/sys/namespaces/api-lock/unlock';
};

export type NamespacesWriteNamespacesApiLockUnlockResponses = {
    /**
     * No Content
     */
    204: void;
};

export type NamespacesWriteNamespacesApiLockUnlockResponse = NamespacesWriteNamespacesApiLockUnlockResponses[keyof NamespacesWriteNamespacesApiLockUnlockResponses];

export type NamespacesWriteNamespacesApiLockUnlockPathData = {
    body: NamespacesWriteNamespacesApiLockUnlockPathRequest;
    path: {
        /**
         * Path of the namespace.
         */
        path: string;
    };
    query?: never;
    url: '/sys/namespaces/api-lock/unlock/{path}';
};

export type NamespacesWriteNamespacesApiLockUnlockPathResponses = {
    /**
     * No Content
     */
    204: void;
};

export type NamespacesWriteNamespacesApiLockUnlockPathResponse = NamespacesWriteNamespacesApiLockUnlockPathResponses[keyof NamespacesWriteNamespacesApiLockUnlockPathResponses];

export type NamespacesDeleteNamespacesPathData = {
    body?: never;
    path: {
        /**
         * Path of the namespace.
         */
        path: string;
    };
    query?: never;
    url: '/sys/namespaces/{path}';
};

export type NamespacesDeleteNamespacesPathResponses = {
    /**
     * OK
     */
    200: NamespacesDeleteNamespacesPathResponse;
    /**
     * No Content
     */
    204: void;
};

export type NamespacesDeleteNamespacesPathResponse2 = NamespacesDeleteNamespacesPathResponses[keyof NamespacesDeleteNamespacesPathResponses];

export type NamespacesReadNamespacesPathData = {
    body?: never;
    path: {
        /**
         * Path of the namespace.
         */
        path: string;
    };
    query?: never;
    url: '/sys/namespaces/{path}';
};

export type NamespacesReadNamespacesPathResponses = {
    /**
     * OK
     */
    200: NamespacesReadNamespacesPathResponse;
};

export type NamespacesReadNamespacesPathResponse2 = NamespacesReadNamespacesPathResponses[keyof NamespacesReadNamespacesPathResponses];

export type NamespacesWriteNamespacesPathData = {
    body: NamespacesWriteNamespacesPathRequest;
    path: {
        /**
         * Path of the namespace.
         */
        path: string;
    };
    query?: never;
    url: '/sys/namespaces/{path}';
};

export type NamespacesWriteNamespacesPathResponses = {
    /**
     * OK
     */
    200: NamespacesWriteNamespacesPathResponse;
};

export type NamespacesWriteNamespacesPathResponse2 = NamespacesWriteNamespacesPathResponses[keyof NamespacesWriteNamespacesPathResponses];

export type PluginsCatalogListPluginsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/plugins/catalog';
};

export type PluginsCatalogListPluginsResponses = {
    /**
     * OK
     */
    200: PluginsCatalogListPluginsResponse;
};

export type PluginsCatalogListPluginsResponse2 = PluginsCatalogListPluginsResponses[keyof PluginsCatalogListPluginsResponses];

export type PluginsCatalogRemovePluginData = {
    body?: never;
    path: {
        /**
         * The name of the plugin
         */
        name: string;
    };
    query?: never;
    url: '/sys/plugins/catalog/{name}';
};

export type PluginsCatalogRemovePluginResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type PluginsCatalogReadPluginConfigurationData = {
    body?: never;
    path: {
        /**
         * The name of the plugin
         */
        name: string;
    };
    query?: never;
    url: '/sys/plugins/catalog/{name}';
};

export type PluginsCatalogReadPluginConfigurationResponses = {
    /**
     * OK
     */
    200: PluginsCatalogReadPluginConfigurationResponse;
};

export type PluginsCatalogReadPluginConfigurationResponse2 = PluginsCatalogReadPluginConfigurationResponses[keyof PluginsCatalogReadPluginConfigurationResponses];

export type PluginsCatalogRegisterPluginData = {
    body: PluginsCatalogRegisterPluginRequest;
    path: {
        /**
         * The name of the plugin
         */
        name: string;
    };
    query?: never;
    url: '/sys/plugins/catalog/{name}';
};

export type PluginsCatalogRegisterPluginResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type PluginsCatalogListPluginsWithTypeData = {
    body?: never;
    path: {
        /**
         * The type of the plugin, may be auth, secret, or database
         */
        type: string;
    };
    query: {
        /**
         * Must be set to `true`
         */
        list: 'true';
    };
    url: '/sys/plugins/catalog/{type}';
};

export type PluginsCatalogListPluginsWithTypeResponses = {
    /**
     * OK
     */
    200: PluginsCatalogListPluginsWithTypeResponse;
};

export type PluginsCatalogListPluginsWithTypeResponse2 = PluginsCatalogListPluginsWithTypeResponses[keyof PluginsCatalogListPluginsWithTypeResponses];

export type PluginsCatalogRemovePluginWithTypeData = {
    body?: never;
    path: {
        /**
         * The name of the plugin
         */
        name: string;
        /**
         * The type of the plugin, may be auth, secret, or database
         */
        type: string;
    };
    query?: never;
    url: '/sys/plugins/catalog/{type}/{name}';
};

export type PluginsCatalogRemovePluginWithTypeResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type PluginsCatalogReadPluginConfigurationWithTypeData = {
    body?: never;
    path: {
        /**
         * The name of the plugin
         */
        name: string;
        /**
         * The type of the plugin, may be auth, secret, or database
         */
        type: string;
    };
    query?: never;
    url: '/sys/plugins/catalog/{type}/{name}';
};

export type PluginsCatalogReadPluginConfigurationWithTypeResponses = {
    /**
     * OK
     */
    200: PluginsCatalogReadPluginConfigurationWithTypeResponse;
};

export type PluginsCatalogReadPluginConfigurationWithTypeResponse2 = PluginsCatalogReadPluginConfigurationWithTypeResponses[keyof PluginsCatalogReadPluginConfigurationWithTypeResponses];

export type PluginsCatalogRegisterPluginWithTypeData = {
    body: PluginsCatalogRegisterPluginWithTypeRequest;
    path: {
        /**
         * The name of the plugin
         */
        name: string;
        /**
         * The type of the plugin, may be auth, secret, or database
         */
        type: string;
    };
    query?: never;
    url: '/sys/plugins/catalog/{type}/{name}';
};

export type PluginsCatalogRegisterPluginWithTypeResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type PluginsReloadBackendsData = {
    body: PluginsReloadBackendsRequest;
    path?: never;
    query?: never;
    url: '/sys/plugins/reload/backend';
};

export type PluginsReloadBackendsResponses = {
    /**
     * OK
     */
    200: PluginsReloadBackendsResponse;
    /**
     * OK
     */
    202: PluginsReloadBackendsResponse;
};

export type PluginsReloadBackendsResponse2 = PluginsReloadBackendsResponses[keyof PluginsReloadBackendsResponses];

export type PoliciesListAclPoliciesData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Must be set to `true`
         */
        list: 'true';
    };
    url: '/sys/policies/acl';
};

export type PoliciesListAclPoliciesResponses = {
    /**
     * OK
     */
    200: PoliciesListAclPoliciesResponse;
};

export type PoliciesListAclPoliciesResponse2 = PoliciesListAclPoliciesResponses[keyof PoliciesListAclPoliciesResponses];

export type PoliciesDeleteAclPolicyData = {
    body?: never;
    path: {
        /**
         * The name of the policy. Example: "ops"
         */
        name: string;
    };
    query?: never;
    url: '/sys/policies/acl/{name}';
};

export type PoliciesDeleteAclPolicyResponses = {
    /**
     * OK
     */
    204: void;
};

export type PoliciesDeleteAclPolicyResponse = PoliciesDeleteAclPolicyResponses[keyof PoliciesDeleteAclPolicyResponses];

export type PoliciesReadAclPolicyData = {
    body?: never;
    path: {
        /**
         * The name of the policy. Example: "ops"
         */
        name: string;
    };
    query?: {
        /**
         * Return a list if `true`
         */
        list?: string;
    };
    url: '/sys/policies/acl/{name}';
};

export type PoliciesReadAclPolicyResponses = {
    /**
     * OK
     */
    200: PoliciesReadAclPolicyResponse;
};

export type PoliciesReadAclPolicyResponse2 = PoliciesReadAclPolicyResponses[keyof PoliciesReadAclPolicyResponses];

export type PoliciesWriteAclPolicyData = {
    body: PoliciesWriteAclPolicyRequest;
    path: {
        /**
         * The name of the policy. Example: "ops"
         */
        name: string;
    };
    query?: never;
    url: '/sys/policies/acl/{name}';
};

export type PoliciesWriteAclPolicyResponses = {
    /**
     * OK
     */
    204: void;
};

export type PoliciesWriteAclPolicyResponse = PoliciesWriteAclPolicyResponses[keyof PoliciesWriteAclPolicyResponses];

export type SystemListPoliciesDetailedAclData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Must be set to `true`
         */
        list: 'true';
    };
    url: '/sys/policies/detailed/acl';
};

export type SystemListPoliciesDetailedAclResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type PoliciesListPasswordPoliciesData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Must be set to `true`
         */
        list: 'true';
    };
    url: '/sys/policies/password';
};

export type PoliciesListPasswordPoliciesResponses = {
    /**
     * OK
     */
    200: PoliciesListPasswordPoliciesResponse;
};

export type PoliciesListPasswordPoliciesResponse2 = PoliciesListPasswordPoliciesResponses[keyof PoliciesListPasswordPoliciesResponses];

export type PoliciesDeletePasswordPolicyData = {
    body?: never;
    path: {
        /**
         * The name of the password policy.
         */
        name: string;
    };
    query?: never;
    url: '/sys/policies/password/{name}';
};

export type PoliciesDeletePasswordPolicyResponses = {
    /**
     * OK
     */
    204: void;
};

export type PoliciesDeletePasswordPolicyResponse = PoliciesDeletePasswordPolicyResponses[keyof PoliciesDeletePasswordPolicyResponses];

export type PoliciesReadPasswordPolicyData = {
    body?: never;
    path: {
        /**
         * The name of the password policy.
         */
        name: string;
    };
    query?: never;
    url: '/sys/policies/password/{name}';
};

export type PoliciesReadPasswordPolicyResponses = {
    /**
     * OK
     */
    204: PoliciesReadPasswordPolicyResponse;
};

export type PoliciesReadPasswordPolicyResponse2 = PoliciesReadPasswordPolicyResponses[keyof PoliciesReadPasswordPolicyResponses];

export type PoliciesWritePasswordPolicyData = {
    body: PoliciesWritePasswordPolicyRequest;
    path: {
        /**
         * The name of the password policy.
         */
        name: string;
    };
    query?: never;
    url: '/sys/policies/password/{name}';
};

export type PoliciesWritePasswordPolicyResponses = {
    /**
     * OK
     */
    204: void;
};

export type PoliciesWritePasswordPolicyResponse = PoliciesWritePasswordPolicyResponses[keyof PoliciesWritePasswordPolicyResponses];

export type PoliciesGeneratePasswordFromPasswordPolicyData = {
    body?: never;
    path: {
        /**
         * The name of the password policy.
         */
        name: string;
    };
    query?: never;
    url: '/sys/policies/password/{name}/generate';
};

export type PoliciesGeneratePasswordFromPasswordPolicyResponses = {
    /**
     * OK
     */
    200: PoliciesGeneratePasswordFromPasswordPolicyResponse;
};

export type PoliciesGeneratePasswordFromPasswordPolicyResponse2 = PoliciesGeneratePasswordFromPasswordPolicyResponses[keyof PoliciesGeneratePasswordFromPasswordPolicyResponses];

export type PoliciesListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Return a list if `true`
         */
        list?: string;
    };
    url: '/sys/policy';
};

export type PoliciesListResponses = {
    /**
     * OK
     */
    200: PoliciesListResponse;
};

export type PoliciesListResponse2 = PoliciesListResponses[keyof PoliciesListResponses];

export type PoliciesDeleteAclPolicy2Data = {
    body?: never;
    path: {
        /**
         * The name of the policy. Example: "ops"
         */
        name: string;
    };
    query?: never;
    url: '/sys/policy/{name}';
};

export type PoliciesDeleteAclPolicy2Responses = {
    /**
     * OK
     */
    204: void;
};

export type PoliciesDeleteAclPolicy2Response = PoliciesDeleteAclPolicy2Responses[keyof PoliciesDeleteAclPolicy2Responses];

export type PoliciesReadAclPolicy2Data = {
    body?: never;
    path: {
        /**
         * The name of the policy. Example: "ops"
         */
        name: string;
    };
    query?: {
        /**
         * Return a list if `true`
         */
        list?: string;
    };
    url: '/sys/policy/{name}';
};

export type PoliciesReadAclPolicy2Responses = {
    /**
     * OK
     */
    200: PoliciesReadAclPolicy2Response;
};

export type PoliciesReadAclPolicy2Response2 = PoliciesReadAclPolicy2Responses[keyof PoliciesReadAclPolicy2Responses];

export type PoliciesWriteAclPolicy2Data = {
    body: PoliciesWriteAclPolicy2Request;
    path: {
        /**
         * The name of the policy. Example: "ops"
         */
        name: string;
    };
    query?: never;
    url: '/sys/policy/{name}';
};

export type PoliciesWriteAclPolicy2Responses = {
    /**
     * OK
     */
    204: void;
};

export type PoliciesWriteAclPolicy2Response = PoliciesWriteAclPolicy2Responses[keyof PoliciesWriteAclPolicy2Responses];

export type PprofIndexData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/pprof';
};

export type PprofIndexResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type PprofMemoryAllocationsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/pprof/allocs';
};

export type PprofMemoryAllocationsResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type PprofBlockingData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/pprof/block';
};

export type PprofBlockingResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type PprofCommandLineData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/pprof/cmdline';
};

export type PprofCommandLineResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type PprofGoroutinesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/pprof/goroutine';
};

export type PprofGoroutinesResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type PprofMemoryAllocationsLiveData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/pprof/heap';
};

export type PprofMemoryAllocationsLiveResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type PprofMutexesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/pprof/mutex';
};

export type PprofMutexesResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type PprofCpuProfileData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/pprof/profile';
};

export type PprofCpuProfileResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type PprofSymbolsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/pprof/symbol';
};

export type PprofSymbolsResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type PprofThreadCreationsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/pprof/threadcreate';
};

export type PprofThreadCreationsResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type PprofExecutionTraceData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/pprof/trace';
};

export type PprofExecutionTraceResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type RateLimitQuotasReadConfigurationData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/quotas/config';
};

export type RateLimitQuotasReadConfigurationResponses = {
    /**
     * OK
     */
    200: RateLimitQuotasReadConfigurationResponse;
};

export type RateLimitQuotasReadConfigurationResponse2 = RateLimitQuotasReadConfigurationResponses[keyof RateLimitQuotasReadConfigurationResponses];

export type RateLimitQuotasConfigureData = {
    body: RateLimitQuotasConfigureRequest;
    path?: never;
    query?: never;
    url: '/sys/quotas/config';
};

export type RateLimitQuotasConfigureResponses = {
    /**
     * OK
     */
    204: void;
};

export type RateLimitQuotasConfigureResponse = RateLimitQuotasConfigureResponses[keyof RateLimitQuotasConfigureResponses];

export type RateLimitQuotasListData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Must be set to `true`
         */
        list: 'true';
    };
    url: '/sys/quotas/rate-limit';
};

export type RateLimitQuotasListResponses = {
    /**
     * OK
     */
    200: RateLimitQuotasListResponse;
};

export type RateLimitQuotasListResponse2 = RateLimitQuotasListResponses[keyof RateLimitQuotasListResponses];

export type RateLimitQuotasDeleteData = {
    body?: never;
    path: {
        /**
         * Name of the quota rule.
         */
        name: string;
    };
    query?: never;
    url: '/sys/quotas/rate-limit/{name}';
};

export type RateLimitQuotasDeleteResponses = {
    /**
     * OK
     */
    204: void;
};

export type RateLimitQuotasDeleteResponse = RateLimitQuotasDeleteResponses[keyof RateLimitQuotasDeleteResponses];

export type RateLimitQuotasReadData = {
    body?: never;
    path: {
        /**
         * Name of the quota rule.
         */
        name: string;
    };
    query?: never;
    url: '/sys/quotas/rate-limit/{name}';
};

export type RateLimitQuotasReadResponses = {
    /**
     * OK
     */
    200: RateLimitQuotasReadResponse;
};

export type RateLimitQuotasReadResponse2 = RateLimitQuotasReadResponses[keyof RateLimitQuotasReadResponses];

export type RateLimitQuotasWriteData = {
    body: RateLimitQuotasWriteRequest;
    path: {
        /**
         * Name of the quota rule.
         */
        name: string;
    };
    query?: never;
    url: '/sys/quotas/rate-limit/{name}';
};

export type RateLimitQuotasWriteResponses = {
    /**
     * No Content
     */
    204: void;
};

export type RateLimitQuotasWriteResponse = RateLimitQuotasWriteResponses[keyof RateLimitQuotasWriteResponses];

export type RawDeleteData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/raw';
};

export type RawDeleteResponses = {
    /**
     * OK
     */
    204: void;
};

export type RawDeleteResponse = RawDeleteResponses[keyof RawDeleteResponses];

export type RawReadData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Return a list if `true`
         */
        list?: string;
    };
    url: '/sys/raw';
};

export type RawReadResponses = {
    /**
     * OK
     */
    200: RawReadResponse;
};

export type RawReadResponse2 = RawReadResponses[keyof RawReadResponses];

export type RawWriteData = {
    body: RawWriteRequest;
    path?: never;
    query?: never;
    url: '/sys/raw';
};

export type RawWriteResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type RawDeletePathData = {
    body?: never;
    path: {
        path: string;
    };
    query?: never;
    url: '/sys/raw/{path}';
};

export type RawDeletePathResponses = {
    /**
     * OK
     */
    204: void;
};

export type RawDeletePathResponse = RawDeletePathResponses[keyof RawDeletePathResponses];

export type RawReadPathData = {
    body?: never;
    path: {
        path: string;
    };
    query?: {
        /**
         * Return a list if `true`
         */
        list?: string;
    };
    url: '/sys/raw/{path}';
};

export type RawReadPathResponses = {
    /**
     * OK
     */
    200: RawReadPathResponse;
};

export type RawReadPathResponse2 = RawReadPathResponses[keyof RawReadPathResponses];

export type RawWritePathData = {
    body: RawWritePathRequest;
    path: {
        path: string;
    };
    query?: never;
    url: '/sys/raw/{path}';
};

export type RawWritePathResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type RekeyDeleteBackupKeyData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/rekey/backup';
};

export type RekeyDeleteBackupKeyResponses = {
    /**
     * OK
     */
    204: void;
};

export type RekeyDeleteBackupKeyResponse = RekeyDeleteBackupKeyResponses[keyof RekeyDeleteBackupKeyResponses];

export type RekeyReadBackupKeyData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/rekey/backup';
};

export type RekeyReadBackupKeyResponses = {
    /**
     * OK
     */
    200: RekeyReadBackupKeyResponse;
};

export type RekeyReadBackupKeyResponse2 = RekeyReadBackupKeyResponses[keyof RekeyReadBackupKeyResponses];

export type RekeyAttemptCancelData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/rekey/init';
};

export type RekeyAttemptCancelResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type RekeyAttemptReadProgressData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/rekey/init';
};

export type RekeyAttemptReadProgressResponses = {
    /**
     * OK
     */
    200: RekeyAttemptReadProgressResponse;
};

export type RekeyAttemptReadProgressResponse2 = RekeyAttemptReadProgressResponses[keyof RekeyAttemptReadProgressResponses];

export type RekeyAttemptInitializeData = {
    body: RekeyAttemptInitializeRequest;
    path?: never;
    query?: never;
    url: '/sys/rekey/init';
};

export type RekeyAttemptInitializeResponses = {
    /**
     * OK
     */
    200: RekeyAttemptInitializeResponse;
};

export type RekeyAttemptInitializeResponse2 = RekeyAttemptInitializeResponses[keyof RekeyAttemptInitializeResponses];

export type RekeyDeleteBackupRecoveryKeyData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/rekey/recovery-key-backup';
};

export type RekeyDeleteBackupRecoveryKeyResponses = {
    /**
     * OK
     */
    204: void;
};

export type RekeyDeleteBackupRecoveryKeyResponse = RekeyDeleteBackupRecoveryKeyResponses[keyof RekeyDeleteBackupRecoveryKeyResponses];

export type RekeyReadBackupRecoveryKeyData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/rekey/recovery-key-backup';
};

export type RekeyReadBackupRecoveryKeyResponses = {
    /**
     * OK
     */
    200: RekeyReadBackupRecoveryKeyResponse;
};

export type RekeyReadBackupRecoveryKeyResponse2 = RekeyReadBackupRecoveryKeyResponses[keyof RekeyReadBackupRecoveryKeyResponses];

export type RekeyAttemptUpdateData = {
    body: RekeyAttemptUpdateRequest;
    path?: never;
    query?: never;
    url: '/sys/rekey/update';
};

export type RekeyAttemptUpdateResponses = {
    /**
     * OK
     */
    200: RekeyAttemptUpdateResponse;
};

export type RekeyAttemptUpdateResponse2 = RekeyAttemptUpdateResponses[keyof RekeyAttemptUpdateResponses];

export type RekeyVerificationCancelData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/rekey/verify';
};

export type RekeyVerificationCancelResponses = {
    /**
     * OK
     */
    200: RekeyVerificationCancelResponse;
};

export type RekeyVerificationCancelResponse2 = RekeyVerificationCancelResponses[keyof RekeyVerificationCancelResponses];

export type RekeyVerificationReadProgressData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/rekey/verify';
};

export type RekeyVerificationReadProgressResponses = {
    /**
     * OK
     */
    200: RekeyVerificationReadProgressResponse;
};

export type RekeyVerificationReadProgressResponse2 = RekeyVerificationReadProgressResponses[keyof RekeyVerificationReadProgressResponses];

export type RekeyVerificationUpdateData = {
    body: RekeyVerificationUpdateRequest;
    path?: never;
    query?: never;
    url: '/sys/rekey/verify';
};

export type RekeyVerificationUpdateResponses = {
    /**
     * OK
     */
    200: RekeyVerificationUpdateResponse;
};

export type RekeyVerificationUpdateResponse2 = RekeyVerificationUpdateResponses[keyof RekeyVerificationUpdateResponses];

export type RemountData = {
    body: RemountRequest;
    path?: never;
    query?: never;
    url: '/sys/remount';
};

export type RemountResponses = {
    /**
     * OK
     */
    200: RemountResponse;
};

export type RemountResponse2 = RemountResponses[keyof RemountResponses];

export type RemountStatusData = {
    body?: never;
    path: {
        /**
         * The ID of the migration operation
         */
        migration_id: string;
    };
    query?: never;
    url: '/sys/remount/status/{migration_id}';
};

export type RemountStatusResponses = {
    /**
     * OK
     */
    200: RemountStatusResponse;
};

export type RemountStatusResponse2 = RemountStatusResponses[keyof RemountStatusResponses];

export type LeasesRenewLease2Data = {
    body: LeasesRenewLease2Request;
    path?: never;
    query?: never;
    url: '/sys/renew';
};

export type LeasesRenewLease2Responses = {
    /**
     * OK
     */
    204: void;
};

export type LeasesRenewLease2Response = LeasesRenewLease2Responses[keyof LeasesRenewLease2Responses];

export type LeasesRenewLeaseWithId2Data = {
    body: LeasesRenewLeaseWithId2Request;
    path: {
        /**
         * The lease identifier to renew. This is included with a lease.
         */
        url_lease_id: string;
    };
    query?: never;
    url: '/sys/renew/{url_lease_id}';
};

export type LeasesRenewLeaseWithId2Responses = {
    /**
     * OK
     */
    204: void;
};

export type LeasesRenewLeaseWithId2Response = LeasesRenewLeaseWithId2Responses[keyof LeasesRenewLeaseWithId2Responses];

export type LeasesRevokeLease2Data = {
    body: LeasesRevokeLease2Request;
    path?: never;
    query?: never;
    url: '/sys/revoke';
};

export type LeasesRevokeLease2Responses = {
    /**
     * OK
     */
    204: void;
};

export type LeasesRevokeLease2Response = LeasesRevokeLease2Responses[keyof LeasesRevokeLease2Responses];

export type LeasesForceRevokeLeaseWithPrefix2Data = {
    body?: never;
    path: {
        /**
         * The path to revoke keys under. Example: "prod/aws/ops"
         */
        prefix: string;
    };
    query?: never;
    url: '/sys/revoke-force/{prefix}';
};

export type LeasesForceRevokeLeaseWithPrefix2Responses = {
    /**
     * OK
     */
    204: void;
};

export type LeasesForceRevokeLeaseWithPrefix2Response = LeasesForceRevokeLeaseWithPrefix2Responses[keyof LeasesForceRevokeLeaseWithPrefix2Responses];

export type LeasesRevokeLeaseWithPrefix2Data = {
    body: LeasesRevokeLeaseWithPrefix2Request;
    path: {
        /**
         * The path to revoke keys under. Example: "prod/aws/ops"
         */
        prefix: string;
    };
    query?: never;
    url: '/sys/revoke-prefix/{prefix}';
};

export type LeasesRevokeLeaseWithPrefix2Responses = {
    /**
     * OK
     */
    204: void;
};

export type LeasesRevokeLeaseWithPrefix2Response = LeasesRevokeLeaseWithPrefix2Responses[keyof LeasesRevokeLeaseWithPrefix2Responses];

export type LeasesRevokeLeaseWithId2Data = {
    body: LeasesRevokeLeaseWithId2Request;
    path: {
        /**
         * The lease identifier to renew. This is included with a lease.
         */
        url_lease_id: string;
    };
    query?: never;
    url: '/sys/revoke/{url_lease_id}';
};

export type LeasesRevokeLeaseWithId2Responses = {
    /**
     * OK
     */
    204: void;
};

export type LeasesRevokeLeaseWithId2Response = LeasesRevokeLeaseWithId2Responses[keyof LeasesRevokeLeaseWithId2Responses];

export type EncryptionKeyRotateData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/rotate';
};

export type EncryptionKeyRotateResponses = {
    /**
     * No Content
     */
    204: void;
};

export type EncryptionKeyRotateResponse = EncryptionKeyRotateResponses[keyof EncryptionKeyRotateResponses];

export type EncryptionKeyReadRotationConfigurationData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/rotate/config';
};

export type EncryptionKeyReadRotationConfigurationResponses = {
    /**
     * OK
     */
    200: EncryptionKeyReadRotationConfigurationResponse;
};

export type EncryptionKeyReadRotationConfigurationResponse2 = EncryptionKeyReadRotationConfigurationResponses[keyof EncryptionKeyReadRotationConfigurationResponses];

export type EncryptionKeyConfigureRotationConfigurationData = {
    body: EncryptionKeyConfigureRotationConfigurationRequest;
    path?: never;
    query?: never;
    url: '/sys/rotate/config';
};

export type EncryptionKeyConfigureRotationConfigurationResponses = {
    /**
     * No Content
     */
    204: void;
};

export type EncryptionKeyConfigureRotationConfigurationResponse = EncryptionKeyConfigureRotationConfigurationResponses[keyof EncryptionKeyConfigureRotationConfigurationResponses];

export type EncryptionKeyRotateRotateKeyringData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/rotate/keyring';
};

export type EncryptionKeyRotateRotateKeyringResponses = {
    /**
     * No Content
     */
    204: void;
};

export type EncryptionKeyRotateRotateKeyringResponse = EncryptionKeyRotateRotateKeyringResponses[keyof EncryptionKeyRotateRotateKeyringResponses];

export type EncryptionKeyReadRotateKeyringConfigData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/rotate/keyring/config';
};

export type EncryptionKeyReadRotateKeyringConfigResponses = {
    /**
     * OK
     */
    200: EncryptionKeyReadRotateKeyringConfigResponse;
};

export type EncryptionKeyReadRotateKeyringConfigResponse2 = EncryptionKeyReadRotateKeyringConfigResponses[keyof EncryptionKeyReadRotateKeyringConfigResponses];

export type EncryptionKeyConfigureRotateKeyringConfigData = {
    body: EncryptionKeyConfigureRotateKeyringConfigRequest;
    path?: never;
    query?: never;
    url: '/sys/rotate/keyring/config';
};

export type EncryptionKeyConfigureRotateKeyringConfigResponses = {
    /**
     * No Content
     */
    204: void;
};

export type EncryptionKeyConfigureRotateKeyringConfigResponse = EncryptionKeyConfigureRotateKeyringConfigResponses[keyof EncryptionKeyConfigureRotateKeyringConfigResponses];

export type RotateDeleteRotateRecoveryBackupData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/rotate/recovery/backup';
};

export type RotateDeleteRotateRecoveryBackupResponses = {
    /**
     * No Content
     */
    204: void;
};

export type RotateDeleteRotateRecoveryBackupResponse = RotateDeleteRotateRecoveryBackupResponses[keyof RotateDeleteRotateRecoveryBackupResponses];

export type RotateReadRotateRecoveryBackupData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/rotate/recovery/backup';
};

export type RotateReadRotateRecoveryBackupResponses = {
    /**
     * OK
     */
    200: RotateReadRotateRecoveryBackupResponse;
};

export type RotateReadRotateRecoveryBackupResponse2 = RotateReadRotateRecoveryBackupResponses[keyof RotateReadRotateRecoveryBackupResponses];

export type RotateAttemptCancelRotateRecoveryInitData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/rotate/recovery/init';
};

export type RotateAttemptCancelRotateRecoveryInitResponses = {
    /**
     * No Content
     */
    204: void;
};

export type RotateAttemptCancelRotateRecoveryInitResponse = RotateAttemptCancelRotateRecoveryInitResponses[keyof RotateAttemptCancelRotateRecoveryInitResponses];

export type RotateAttemptReadRotateRecoveryInitData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/rotate/recovery/init';
};

export type RotateAttemptReadRotateRecoveryInitResponses = {
    /**
     * OK
     */
    200: RotateAttemptReadRotateRecoveryInitResponse;
};

export type RotateAttemptReadRotateRecoveryInitResponse2 = RotateAttemptReadRotateRecoveryInitResponses[keyof RotateAttemptReadRotateRecoveryInitResponses];

export type RotateAttemptInitializeRotateRecoveryInitData = {
    body: RotateAttemptInitializeRotateRecoveryInitRequest;
    path?: never;
    query?: never;
    url: '/sys/rotate/recovery/init';
};

export type RotateAttemptInitializeRotateRecoveryInitResponses = {
    /**
     * OK
     */
    200: RotateAttemptInitializeRotateRecoveryInitResponse;
};

export type RotateAttemptInitializeRotateRecoveryInitResponse2 = RotateAttemptInitializeRotateRecoveryInitResponses[keyof RotateAttemptInitializeRotateRecoveryInitResponses];

export type RotateAttemptUpdateRotateRecoveryUpdateData = {
    body: RotateAttemptUpdateRotateRecoveryUpdateRequest;
    path?: never;
    query?: never;
    url: '/sys/rotate/recovery/update';
};

export type RotateAttemptUpdateRotateRecoveryUpdateResponses = {
    /**
     * OK
     */
    200: RotateAttemptUpdateRotateRecoveryUpdateResponse;
};

export type RotateAttemptUpdateRotateRecoveryUpdateResponse2 = RotateAttemptUpdateRotateRecoveryUpdateResponses[keyof RotateAttemptUpdateRotateRecoveryUpdateResponses];

export type RotateVerificationCancelRotateRecoveryVerifyData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/rotate/recovery/verify';
};

export type RotateVerificationCancelRotateRecoveryVerifyResponses = {
    /**
     * OK
     */
    200: RotateVerificationCancelRotateRecoveryVerifyResponse;
};

export type RotateVerificationCancelRotateRecoveryVerifyResponse2 = RotateVerificationCancelRotateRecoveryVerifyResponses[keyof RotateVerificationCancelRotateRecoveryVerifyResponses];

export type RotateVerificationReadRotateRecoveryVerifyData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/rotate/recovery/verify';
};

export type RotateVerificationReadRotateRecoveryVerifyResponses = {
    /**
     * OK
     */
    200: RotateVerificationReadRotateRecoveryVerifyResponse;
};

export type RotateVerificationReadRotateRecoveryVerifyResponse2 = RotateVerificationReadRotateRecoveryVerifyResponses[keyof RotateVerificationReadRotateRecoveryVerifyResponses];

export type RotateVerificationUpdateRotateRecoveryVerifyData = {
    body: RotateVerificationUpdateRotateRecoveryVerifyRequest;
    path?: never;
    query?: never;
    url: '/sys/rotate/recovery/verify';
};

export type RotateVerificationUpdateRotateRecoveryVerifyResponses = {
    /**
     * OK
     */
    200: RotateVerificationUpdateRotateRecoveryVerifyResponse;
};

export type RotateVerificationUpdateRotateRecoveryVerifyResponse2 = RotateVerificationUpdateRotateRecoveryVerifyResponses[keyof RotateVerificationUpdateRotateRecoveryVerifyResponses];

export type RootKeyRotateData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/rotate/root';
};

export type RootKeyRotateResponses = {
    /**
     * No Content
     */
    204: void;
};

export type RootKeyRotateResponse = RootKeyRotateResponses[keyof RootKeyRotateResponses];

export type RotateDeleteBackupKeyData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/rotate/root/backup';
};

export type RotateDeleteBackupKeyResponses = {
    /**
     * No Content
     */
    204: void;
};

export type RotateDeleteBackupKeyResponse = RotateDeleteBackupKeyResponses[keyof RotateDeleteBackupKeyResponses];

export type RotateReadBackupKeyData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/rotate/root/backup';
};

export type RotateReadBackupKeyResponses = {
    /**
     * OK
     */
    200: RotateReadBackupKeyResponse;
};

export type RotateReadBackupKeyResponse2 = RotateReadBackupKeyResponses[keyof RotateReadBackupKeyResponses];

export type RotateAttemptCancelData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/rotate/root/init';
};

export type RotateAttemptCancelResponses = {
    /**
     * No Content
     */
    204: void;
};

export type RotateAttemptCancelResponse = RotateAttemptCancelResponses[keyof RotateAttemptCancelResponses];

export type RotateAttemptReadProgressData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/rotate/root/init';
};

export type RotateAttemptReadProgressResponses = {
    /**
     * OK
     */
    200: RotateAttemptReadProgressResponse;
};

export type RotateAttemptReadProgressResponse2 = RotateAttemptReadProgressResponses[keyof RotateAttemptReadProgressResponses];

export type RotateAttemptInitializeData = {
    body: RotateAttemptInitializeRequest;
    path?: never;
    query?: never;
    url: '/sys/rotate/root/init';
};

export type RotateAttemptInitializeResponses = {
    /**
     * OK
     */
    200: RotateAttemptInitializeResponse;
};

export type RotateAttemptInitializeResponse2 = RotateAttemptInitializeResponses[keyof RotateAttemptInitializeResponses];

export type RotateAttemptUpdateData = {
    body: RotateAttemptUpdateRequest;
    path?: never;
    query?: never;
    url: '/sys/rotate/root/update';
};

export type RotateAttemptUpdateResponses = {
    /**
     * OK
     */
    200: RotateAttemptUpdateResponse;
};

export type RotateAttemptUpdateResponse2 = RotateAttemptUpdateResponses[keyof RotateAttemptUpdateResponses];

export type RotateVerificationCancelData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/rotate/root/verify';
};

export type RotateVerificationCancelResponses = {
    /**
     * OK
     */
    200: RotateVerificationCancelResponse;
};

export type RotateVerificationCancelResponse2 = RotateVerificationCancelResponses[keyof RotateVerificationCancelResponses];

export type RotateVerificationReadProgressData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/rotate/root/verify';
};

export type RotateVerificationReadProgressResponses = {
    /**
     * OK
     */
    200: RotateVerificationReadProgressResponse;
};

export type RotateVerificationReadProgressResponse2 = RotateVerificationReadProgressResponses[keyof RotateVerificationReadProgressResponses];

export type RotateVerificationUpdateData = {
    body: RotateVerificationUpdateRequest;
    path?: never;
    query?: never;
    url: '/sys/rotate/root/verify';
};

export type RotateVerificationUpdateResponses = {
    /**
     * OK
     */
    200: RotateVerificationUpdateResponse;
};

export type RotateVerificationUpdateResponse2 = RotateVerificationUpdateResponses[keyof RotateVerificationUpdateResponses];

export type SealData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/seal';
};

export type SealResponses = {
    /**
     * OK
     */
    204: void;
};

export type SealResponse = SealResponses[keyof SealResponses];

export type SealStatusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/seal-status';
};

export type SealStatusResponses = {
    200: SealStatusResponse;
};

export type SealStatusResponse2 = SealStatusResponses[keyof SealStatusResponses];

export type StepDownLeaderData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/step-down';
};

export type StepDownLeaderResponses = {
    /**
     * empty body
     */
    204: void;
};

export type StepDownLeaderResponse = StepDownLeaderResponses[keyof StepDownLeaderResponses];

export type GenerateHashData = {
    body: GenerateHashRequest;
    path?: never;
    query?: never;
    url: '/sys/tools/hash';
};

export type GenerateHashResponses = {
    /**
     * OK
     */
    200: GenerateHashResponse;
};

export type GenerateHashResponse2 = GenerateHashResponses[keyof GenerateHashResponses];

export type GenerateHashWithAlgorithmData = {
    body: GenerateHashWithAlgorithmRequest;
    path: {
        /**
         * Algorithm to use (POST URL parameter)
         */
        urlalgorithm: string;
    };
    query?: never;
    url: '/sys/tools/hash/{urlalgorithm}';
};

export type GenerateHashWithAlgorithmResponses = {
    /**
     * OK
     */
    200: GenerateHashWithAlgorithmResponse;
};

export type GenerateHashWithAlgorithmResponse2 = GenerateHashWithAlgorithmResponses[keyof GenerateHashWithAlgorithmResponses];

export type GenerateRandomData = {
    body: GenerateRandomRequest;
    path?: never;
    query?: never;
    url: '/sys/tools/random';
};

export type GenerateRandomResponses = {
    /**
     * OK
     */
    200: GenerateRandomResponse;
};

export type GenerateRandomResponse2 = GenerateRandomResponses[keyof GenerateRandomResponses];

export type GenerateRandomWithSourceData = {
    body: GenerateRandomWithSourceRequest;
    path: {
        /**
         * Which system to source random data from, ether "platform", "seal", or "all".
         */
        source: string;
    };
    query?: never;
    url: '/sys/tools/random/{source}';
};

export type GenerateRandomWithSourceResponses = {
    /**
     * OK
     */
    200: GenerateRandomWithSourceResponse;
};

export type GenerateRandomWithSourceResponse2 = GenerateRandomWithSourceResponses[keyof GenerateRandomWithSourceResponses];

export type GenerateRandomWithSourceAndBytesData = {
    body: GenerateRandomWithSourceAndBytesRequest;
    path: {
        /**
         * Which system to source random data from, ether "platform", "seal", or "all".
         */
        source: string;
        /**
         * The number of bytes to generate (POST URL parameter)
         */
        urlbytes: string;
    };
    query?: never;
    url: '/sys/tools/random/{source}/{urlbytes}';
};

export type GenerateRandomWithSourceAndBytesResponses = {
    /**
     * OK
     */
    200: GenerateRandomWithSourceAndBytesResponse;
};

export type GenerateRandomWithSourceAndBytesResponse2 = GenerateRandomWithSourceAndBytesResponses[keyof GenerateRandomWithSourceAndBytesResponses];

export type GenerateRandomWithBytesData = {
    body: GenerateRandomWithBytesRequest;
    path: {
        /**
         * The number of bytes to generate (POST URL parameter)
         */
        urlbytes: string;
    };
    query?: never;
    url: '/sys/tools/random/{urlbytes}';
};

export type GenerateRandomWithBytesResponses = {
    /**
     * OK
     */
    200: GenerateRandomWithBytesResponse;
};

export type GenerateRandomWithBytesResponse2 = GenerateRandomWithBytesResponses[keyof GenerateRandomWithBytesResponses];

export type UnsealData = {
    body: UnsealRequest;
    path?: never;
    query?: never;
    url: '/sys/unseal';
};

export type UnsealResponses = {
    200: UnsealResponse;
};

export type UnsealResponse2 = UnsealResponses[keyof UnsealResponses];

export type VersionHistoryData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Must be set to `true`
         */
        list: 'true';
    };
    url: '/sys/version-history';
};

export type VersionHistoryResponses = {
    /**
     * OK
     */
    200: VersionHistoryResponse;
};

export type VersionHistoryResponse2 = VersionHistoryResponses[keyof VersionHistoryResponses];

export type ReadWrappingProperties2Data = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/wrapping/lookup';
};

export type ReadWrappingProperties2Responses = {
    /**
     * OK
     */
    200: ReadWrappingProperties2Response;
};

export type ReadWrappingProperties2Response2 = ReadWrappingProperties2Responses[keyof ReadWrappingProperties2Responses];

export type ReadWrappingPropertiesData = {
    body: ReadWrappingPropertiesRequest;
    path?: never;
    query?: never;
    url: '/sys/wrapping/lookup';
};

export type ReadWrappingPropertiesResponses = {
    /**
     * OK
     */
    200: ReadWrappingPropertiesResponse;
};

export type ReadWrappingPropertiesResponse2 = ReadWrappingPropertiesResponses[keyof ReadWrappingPropertiesResponses];

export type RewrapData = {
    body: RewrapRequest;
    path?: never;
    query?: never;
    url: '/sys/wrapping/rewrap';
};

export type RewrapResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type UnwrapData = {
    body: UnwrapRequest;
    path?: never;
    query?: never;
    url: '/sys/wrapping/unwrap';
};

export type UnwrapResponses = {
    /**
     * OK
     */
    200: unknown;
    /**
     * No content
     */
    204: void;
};

export type UnwrapResponse = UnwrapResponses[keyof UnwrapResponses];

export type WrapData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sys/wrapping/wrap';
};

export type WrapResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type KvReadConfigData = {
    body?: never;
    path: {
        /**
         * Path that the backend was mounted at
         */
        secret_mount_path: string;
    };
    query?: never;
    url: '/{secret_mount_path}/config';
};

export type KvReadConfigResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type KvWriteConfigData = {
    body: KvWriteConfigRequest;
    path: {
        /**
         * Path that the backend was mounted at
         */
        secret_mount_path: string;
    };
    query?: never;
    url: '/{secret_mount_path}/config';
};

export type KvWriteConfigResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type KvDeleteDataPathData = {
    body?: never;
    path: {
        /**
         * Location of the secret.
         */
        path: string;
        /**
         * Path that the backend was mounted at
         */
        secret_mount_path: string;
    };
    query?: never;
    url: '/{secret_mount_path}/data/{path}';
};

export type KvDeleteDataPathResponses = {
    /**
     * empty body
     */
    204: void;
};

export type KvDeleteDataPathResponse = KvDeleteDataPathResponses[keyof KvDeleteDataPathResponses];

export type KvReadDataPathData = {
    body?: never;
    path: {
        /**
         * Location of the secret.
         */
        path: string;
        /**
         * Path that the backend was mounted at
         */
        secret_mount_path: string;
    };
    query?: never;
    url: '/{secret_mount_path}/data/{path}';
};

export type KvReadDataPathResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type KvWriteDataPathData = {
    body: KvWriteDataPathRequest;
    path: {
        /**
         * Location of the secret.
         */
        path: string;
        /**
         * Path that the backend was mounted at
         */
        secret_mount_path: string;
    };
    query?: never;
    url: '/{secret_mount_path}/data/{path}';
};

export type KvWriteDataPathResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type KvWriteDeletePathData = {
    body: KvWriteDeletePathRequest;
    path: {
        /**
         * Location of the secret.
         */
        path: string;
        /**
         * Path that the backend was mounted at
         */
        secret_mount_path: string;
    };
    query?: never;
    url: '/{secret_mount_path}/delete/{path}';
};

export type KvWriteDeletePathResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type KvWriteDestroyPathData = {
    body: KvWriteDestroyPathRequest;
    path: {
        /**
         * Location of the secret.
         */
        path: string;
        /**
         * Path that the backend was mounted at
         */
        secret_mount_path: string;
    };
    query?: never;
    url: '/{secret_mount_path}/destroy/{path}';
};

export type KvWriteDestroyPathResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type KvListDetailedMetadataPathData = {
    body?: never;
    path: {
        /**
         * Location of the secret.
         */
        path: string;
        /**
         * Path that the backend was mounted at
         */
        secret_mount_path: string;
    };
    query: {
        /**
         * Must be set to `true`
         */
        list: 'true';
    };
    url: '/{secret_mount_path}/detailed-metadata/{path}';
};

export type KvListDetailedMetadataPathResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type KvDeleteMetadataPathData = {
    body?: never;
    path: {
        /**
         * Location of the secret.
         */
        path: string;
        /**
         * Path that the backend was mounted at
         */
        secret_mount_path: string;
    };
    query?: never;
    url: '/{secret_mount_path}/metadata/{path}';
};

export type KvDeleteMetadataPathResponses = {
    /**
     * empty body
     */
    204: void;
};

export type KvDeleteMetadataPathResponse = KvDeleteMetadataPathResponses[keyof KvDeleteMetadataPathResponses];

export type KvReadMetadataPathData = {
    body?: never;
    path: {
        /**
         * Location of the secret.
         */
        path: string;
        /**
         * Path that the backend was mounted at
         */
        secret_mount_path: string;
    };
    query?: {
        /**
         * Return a list if `true`
         */
        list?: string;
    };
    url: '/{secret_mount_path}/metadata/{path}';
};

export type KvReadMetadataPathResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type KvWriteMetadataPathData = {
    body: KvWriteMetadataPathRequest;
    path: {
        /**
         * Location of the secret.
         */
        path: string;
        /**
         * Path that the backend was mounted at
         */
        secret_mount_path: string;
    };
    query?: never;
    url: '/{secret_mount_path}/metadata/{path}';
};

export type KvWriteMetadataPathResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type KvReadSubkeysPathData = {
    body?: never;
    path: {
        /**
         * Location of the secret.
         */
        path: string;
        /**
         * Path that the backend was mounted at
         */
        secret_mount_path: string;
    };
    query?: never;
    url: '/{secret_mount_path}/subkeys/{path}';
};

export type KvReadSubkeysPathResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type KvWriteUndeletePathData = {
    body: KvWriteUndeletePathRequest;
    path: {
        /**
         * Location of the secret.
         */
        path: string;
        /**
         * Path that the backend was mounted at
         */
        secret_mount_path: string;
    };
    query?: never;
    url: '/{secret_mount_path}/undelete/{path}';
};

export type KvWriteUndeletePathResponses = {
    /**
     * OK
     */
    200: unknown;
};
