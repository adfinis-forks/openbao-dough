/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/auth/token/accessors": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["token-list-accessors"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/token/create": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["token-create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/token/create-orphan": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["token-create-orphan"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/token/create/{role_name}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the role */
                role_name: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["token-create-against-role"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/token/lookup": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["token-look-up-2"];
        put?: never;
        post: operations["token-look-up"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/token/lookup-accessor": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["token-look-up-accessor"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/token/lookup-self": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["token-look-up-self"];
        put?: never;
        post: operations["token-look-up-self2"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/token/renew": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["token-renew"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/token/renew-accessor": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["token-renew-accessor"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/token/renew-self": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["token-renew-self"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/token/revoke": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["token-revoke"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/token/revoke-accessor": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["token-revoke-accessor"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/token/revoke-orphan": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["token-revoke-orphan"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/token/revoke-self": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["token-revoke-self"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/token/roles": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["token-list-roles"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/token/roles/{role_name}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the role */
                role_name: string;
            };
            cookie?: never;
        };
        get: operations["token-read-role"];
        put?: never;
        post: operations["token-write-role"];
        delete: operations["token-delete-role"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/token/tidy": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["token-tidy"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/cubbyhole/{path}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Specifies the path of the secret. */
                path: string;
            };
            cookie?: never;
        };
        /** Retrieve the secret at the specified location. */
        get: operations["cubbyhole-read"];
        put?: never;
        /** Store a secret at the specified location. */
        post: operations["cubbyhole-write"];
        /** Deletes the secret at the specified location. */
        delete: operations["cubbyhole-delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/alias": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["alias-create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/alias/id": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["alias-list-by-id"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/alias/id/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the alias */
                id: string;
            };
            cookie?: never;
        };
        get: operations["alias-read-by-id"];
        put?: never;
        post: operations["alias-update-by-id"];
        delete: operations["alias-delete-by-id"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/entity": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["entity-create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/entity-alias": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["entity-create-alias"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/entity-alias/id": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["entity-list-aliases-by-id"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/entity-alias/id/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the alias */
                id: string;
            };
            cookie?: never;
        };
        get: operations["entity-read-alias-by-id"];
        put?: never;
        post: operations["entity-update-alias-by-id"];
        delete: operations["entity-delete-alias-by-id"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/entity/batch-delete": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["entity-batch-delete"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/entity/id": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["entity-list-by-id"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/entity/id/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the entity. If set, updates the corresponding existing entity. */
                id: string;
            };
            cookie?: never;
        };
        get: operations["entity-read-by-id"];
        put?: never;
        post: operations["entity-update-by-id"];
        delete: operations["entity-delete-by-id"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/entity/merge": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["entity-merge"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/entity/name": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["entity-list-by-name"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/entity/name/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the entity */
                name: string;
            };
            cookie?: never;
        };
        get: operations["entity-read-by-name"];
        put?: never;
        post: operations["entity-update-by-name"];
        delete: operations["entity-delete-by-name"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/group": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["group-create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/group-alias": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["group-create-alias"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/group-alias/id": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["group-list-aliases-by-id"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/group-alias/id/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the group alias. */
                id: string;
            };
            cookie?: never;
        };
        get: operations["group-read-alias-by-id"];
        put?: never;
        post: operations["group-update-alias-by-id"];
        delete: operations["group-delete-alias-by-id"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/group/id": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["group-list-by-id"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/group/id/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the group. If set, updates the corresponding existing group. */
                id: string;
            };
            cookie?: never;
        };
        get: operations["group-read-by-id"];
        put?: never;
        post: operations["group-update-by-id"];
        delete: operations["group-delete-by-id"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/group/name": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["group-list-by-name"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/group/name/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the group. */
                name: string;
            };
            cookie?: never;
        };
        get: operations["group-read-by-name"];
        put?: never;
        post: operations["group-update-by-name"];
        delete: operations["group-delete-by-name"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/lookup/entity": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["entity-look-up"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/lookup/group": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["group-look-up"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/mfa/login-enforcement": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List login enforcements */
        get: operations["mfa-list-login-enforcements"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/mfa/login-enforcement/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name for this login enforcement configuration */
                name: string;
            };
            cookie?: never;
        };
        /** Read the current login enforcement */
        get: operations["mfa-read-login-enforcement"];
        put?: never;
        /** Create or update a login enforcement */
        post: operations["mfa-write-login-enforcement"];
        /** Delete a login enforcement */
        delete: operations["mfa-delete-login-enforcement"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/mfa/method": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List MFA method configurations for all MFA methods */
        get: operations["mfa-list-methods"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/mfa/method/duo": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List MFA method configurations for the given MFA method */
        get: operations["mfa-list-duo-methods"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/mfa/method/duo/{method_id}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier for this MFA method. */
                method_id: string;
            };
            cookie?: never;
        };
        /** Read the current configuration for the given MFA method */
        get: operations["mfa-read-duo-method-configuration"];
        put?: never;
        /** Update or create a configuration for the given MFA method */
        post: operations["mfa-configure-duo-method"];
        /** Delete a configuration for the given MFA method */
        delete: operations["mfa-delete-duo-method"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/mfa/method/okta": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List MFA method configurations for the given MFA method */
        get: operations["mfa-list-okta-methods"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/mfa/method/okta/{method_id}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier for this MFA method. */
                method_id: string;
            };
            cookie?: never;
        };
        /** Read the current configuration for the given MFA method */
        get: operations["mfa-read-okta-method-configuration"];
        put?: never;
        /** Update or create a configuration for the given MFA method */
        post: operations["mfa-configure-okta-method"];
        /** Delete a configuration for the given MFA method */
        delete: operations["mfa-delete-okta-method"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/mfa/method/pingid": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List MFA method configurations for the given MFA method */
        get: operations["mfa-list-ping-id-methods"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/mfa/method/pingid/{method_id}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier for this MFA method. */
                method_id: string;
            };
            cookie?: never;
        };
        /** Read the current configuration for the given MFA method */
        get: operations["mfa-read-ping-id-method-configuration"];
        put?: never;
        /** Update or create a configuration for the given MFA method */
        post: operations["mfa-configure-ping-id-method"];
        /** Delete a configuration for the given MFA method */
        delete: operations["mfa-delete-ping-id-method"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/mfa/method/totp": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List MFA method configurations for the given MFA method */
        get: operations["mfa-list-totp-methods"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/mfa/method/totp/admin-destroy": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Destroys a TOTP secret for the given MFA method ID on the given entity */
        post: operations["mfa-admin-destroy-totp-secret"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/mfa/method/totp/admin-generate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Update or create TOTP secret for the given method ID on the given entity. */
        post: operations["mfa-admin-generate-totp-secret"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/mfa/method/totp/generate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Update or create TOTP secret for the given method ID on the given entity. */
        post: operations["mfa-generate-totp-secret"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/mfa/method/totp/{method_id}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier for this MFA method. */
                method_id: string;
            };
            cookie?: never;
        };
        /** Read the current configuration for the given MFA method */
        get: operations["mfa-read-totp-method-configuration"];
        put?: never;
        /** Update or create a configuration for the given MFA method */
        post: operations["mfa-configure-totp-method"];
        /** Delete a configuration for the given MFA method */
        delete: operations["mfa-delete-totp-method"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/mfa/method/{method_id}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier for this MFA method. */
                method_id: string;
            };
            cookie?: never;
        };
        /** Read the current configuration for the given ID regardless of the MFA method type */
        get: operations["mfa-read-method-configuration"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/oidc/.well-known/keys": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["oidc-read-public-keys"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/oidc/.well-known/openid-configuration": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["oidc-read-open-id-configuration"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/oidc/assignment": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["oidc-list-assignments"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/oidc/assignment/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the assignment */
                name: string;
            };
            cookie?: never;
        };
        get: operations["oidc-read-assignment"];
        put?: never;
        post: operations["oidc-write-assignment"];
        delete: operations["oidc-delete-assignment"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/oidc/client": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["oidc-list-clients"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/oidc/client/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the client. */
                name: string;
            };
            cookie?: never;
        };
        get: operations["oidc-read-client"];
        put?: never;
        post: operations["oidc-write-client"];
        delete: operations["oidc-delete-client"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/oidc/config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["oidc-read-configuration"];
        put?: never;
        post: operations["oidc-configure"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/oidc/introspect": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["oidc-introspect"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/oidc/key": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["oidc-list-keys"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/oidc/key/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the key */
                name: string;
            };
            cookie?: never;
        };
        get: operations["oidc-read-key"];
        put?: never;
        post: operations["oidc-write-key"];
        delete: operations["oidc-delete-key"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/oidc/key/{name}/rotate": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the key */
                name: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["oidc-rotate-key"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/oidc/provider": {
        parameters: {
            query?: {
                /** @description Filters the list of OIDC providers to those that allow the given client ID in their set of allowed_client_ids. */
                allowed_client_id?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["oidc-list-providers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/oidc/provider/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the provider */
                name: string;
            };
            cookie?: never;
        };
        get: operations["oidc-read-provider"];
        put?: never;
        post: operations["oidc-write-provider"];
        delete: operations["oidc-delete-provider"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/oidc/provider/{name}/.well-known/keys": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the provider */
                name: string;
            };
            cookie?: never;
        };
        get: operations["oidc-read-provider-public-keys"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/oidc/provider/{name}/.well-known/openid-configuration": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the provider */
                name: string;
            };
            cookie?: never;
        };
        get: operations["oidc-read-provider-open-id-configuration"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/oidc/provider/{name}/authorize": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the provider */
                name: string;
            };
            cookie?: never;
        };
        get: operations["oidc-provider-authorize"];
        put?: never;
        post: operations["oidc-provider-authorize-with-parameters"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/oidc/provider/{name}/token": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the provider */
                name: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["oidc-provider-token"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/oidc/provider/{name}/userinfo": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the provider */
                name: string;
            };
            cookie?: never;
        };
        get: operations["oidc-provider-user-info"];
        put?: never;
        post: operations["oidc-provider-user-info2"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/oidc/role": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["oidc-list-roles"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/oidc/role/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the role */
                name: string;
            };
            cookie?: never;
        };
        get: operations["oidc-read-role"];
        put?: never;
        post: operations["oidc-write-role"];
        delete: operations["oidc-delete-role"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/oidc/scope": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["oidc-list-scopes"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/oidc/scope/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the scope */
                name: string;
            };
            cookie?: never;
        };
        get: operations["oidc-read-scope"];
        put?: never;
        post: operations["oidc-write-scope"];
        delete: operations["oidc-delete-scope"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/oidc/token/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the role */
                name: string;
            };
            cookie?: never;
        };
        get: operations["oidc-generate-token"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/persona": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["persona-create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/persona/id": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["persona-list-by-id"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identity/persona/id/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the persona */
                id: string;
            };
            cookie?: never;
        };
        get: operations["persona-read-by-id"];
        put?: never;
        post: operations["persona-update-by-id"];
        delete: operations["persona-delete-by-id"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/audit": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List the enabled audit devices. */
        get: operations["auditing-list-enabled-devices"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/audit-hash/{path}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the backend. Cannot be delimited. Example: "mysql" */
                path: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["auditing-calculate-hash"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/audit/{path}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the backend. Cannot be delimited. Example: "mysql" */
                path: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Enable a new audit device at the supplied path. */
        post: operations["auditing-enable-device"];
        /** Disable the audit device at the given path. */
        delete: operations["auditing-disable-device"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/auth": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["auth-list-enabled-methods"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/auth/{path}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The path to mount to. Cannot be delimited. Example: "user" */
                path: string;
            };
            cookie?: never;
        };
        /** Read the configuration of the auth engine at the given path. */
        get: operations["auth-read-configuration"];
        put?: never;
        /**
         * Enables a new auth method.
         * @description After enabling, the auth method can be accessed and configured via the auth path specified as part of the URL. This auth path will be nested under the auth prefix.
         *
         *     For example, enable the "foo" auth method will make it accessible at /auth/foo.
         */
        post: operations["auth-enable-method"];
        /** Disable the auth method at the given auth path */
        delete: operations["auth-disable-method"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/auth/{path}/tune": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Tune the configuration parameters for an auth path. */
                path: string;
            };
            cookie?: never;
        };
        /**
         * Reads the given auth path's configuration.
         * @description This endpoint requires sudo capability on the final path, but the same functionality can be achieved without sudo via `sys/mounts/auth/[auth-path]/tune`.
         */
        get: operations["auth-read-tuning-information"];
        put?: never;
        /**
         * Tune configuration parameters for a given auth path.
         * @description This endpoint requires sudo capability on the final path, but the same functionality can be achieved without sudo via `sys/mounts/auth/[auth-path]/tune`.
         */
        post: operations["auth-tune-configuration-parameters"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/capabilities": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["query-token-capabilities"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/capabilities-accessor": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["query-token-accessor-capabilities"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/capabilities-self": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["query-token-self-capabilities"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/config/auditing/request-headers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List the request headers that are configured to be audited. */
        get: operations["auditing-list-request-headers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/config/auditing/request-headers/{header}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                header: string;
            };
            cookie?: never;
        };
        /** List the information for the given request header. */
        get: operations["auditing-read-request-header-information"];
        put?: never;
        /** Enable auditing of a header. */
        post: operations["auditing-enable-request-header"];
        /** Disable auditing of the given request header. */
        delete: operations["auditing-disable-request-header"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/config/cors": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Return the current CORS settings. */
        get: operations["cors-read-configuration"];
        put?: never;
        /** Configure the CORS settings. */
        post: operations["cors-configure"];
        /** Remove any CORS settings. */
        delete: operations["cors-delete-configuration"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/config/reload/{subsystem}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                subsystem: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Reload the given subsystem */
        post: operations["reload-subsystem"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/config/state/sanitized": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Return a sanitized version of the OpenBao server configuration.
         * @description The sanitized output strips configuration values in the storage, HA storage, and seals stanzas, which may contain sensitive values such as API tokens. It also removes any token or secret fields in other stanzas, such as the circonus_api_token from telemetry.
         */
        get: operations["read-sanitized-configuration-state"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/config/ui/headers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Return a list of configured UI headers. */
        get: operations["ui-headers-list"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/config/ui/headers/{header}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the header. */
                header: string;
            };
            cookie?: never;
        };
        /** Return the given UI header's configuration */
        get: operations["ui-headers-read-configuration"];
        put?: never;
        /** Configure the values to be returned for the UI header. */
        post: operations["ui-headers-configure"];
        /** Remove a UI header. */
        delete: operations["ui-headers-delete-configuration"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/decode-token": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Decodes the encoded token with the otp. */
        post: operations["decode"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/generate-root": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Read the configuration and progress of the current root generation attempt. */
        get: operations["root-token-generation-read-progress2"];
        put?: never;
        /**
         * Initializes a new root generation attempt.
         * @description Only a single root generation attempt can take place at a time. One (and only one) of otp or pgp_key are required.
         */
        post: operations["root-token-generation-initialize-2"];
        /** Cancels any in-progress root generation attempt. */
        delete: operations["root-token-generation-cancel-2"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/generate-root/attempt": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Read the configuration and progress of the current root generation attempt. */
        get: operations["root-token-generation-read-progress"];
        put?: never;
        /**
         * Initializes a new root generation attempt.
         * @description Only a single root generation attempt can take place at a time. One (and only one) of otp or pgp_key are required.
         */
        post: operations["root-token-generation-initialize"];
        /** Cancels any in-progress root generation attempt. */
        delete: operations["root-token-generation-cancel"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/generate-root/update": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Enter a single unseal key share to progress the root generation attempt.
         * @description If the threshold number of unseal key shares is reached, OpenBao will complete the root generation and issue the new token. Otherwise, this API must be called multiple times until that threshold is met. The attempt nonce must be provided with each call.
         */
        post: operations["root-token-generation-update"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/ha-status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Check the HA status of an OpenBao cluster */
        get: operations["ha-status"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns the health status of OpenBao. */
        get: operations["read-health-status"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/host-info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Information about the host instance that this OpenBao server is running on.
         * @description Information about the host instance that this OpenBao server is running on.
         *     		The information that gets collected includes host hardware information, and CPU,
         *     		disk, and memory utilization
         */
        get: operations["collect-host-information"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/in-flight-req": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * reports in-flight requests
         * @description This path responds to the following HTTP methods.
         *     		GET /
         *     			Returns a map of in-flight requests.
         */
        get: operations["collect-in-flight-request-information"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/init": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns the initialization status of OpenBao. */
        get: operations["read-initialization-status"];
        put?: never;
        /**
         * Initialize a new OpenBao instance.
         * @description The OpenBao instance must not have been previously initialized. The recovery options, as well as the stored shares option, are only available when using OpenBao HSM.
         */
        post: operations["initialize-system"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/internal/counters/entities": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Backwards compatibility is not guaranteed for this API */
        get: operations["internal-count-entities"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/internal/counters/requests": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Backwards compatibility is not guaranteed for this API
         * @deprecated
         */
        get: operations["internal-count-requests"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/internal/counters/tokens": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Backwards compatibility is not guaranteed for this API */
        get: operations["internal-count-tokens"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/internal/inspect/request": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Expose all request information to the caller */
        get: operations["internal-inspect-request"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/internal/inspect/router/{tag}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of subtree being observed */
                tag: string;
            };
            cookie?: never;
        };
        /** Expose the route entry and mount entry tables present in the router */
        get: operations["internal-inspect-router"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/internal/specs/openapi": {
        parameters: {
            query?: {
                /** @description Use generic mount paths */
                generic_mount_paths?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["internal-generate-open-api-document"];
        put?: never;
        post: operations["internal-generate-open-api-document-with-parameters"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/internal/ui/feature-flags": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Lists enabled feature flags. */
        get: operations["internal-ui-list-enabled-feature-flags"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/internal/ui/mounts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Lists all enabled and visible auth and secrets mounts. */
        get: operations["internal-ui-list-enabled-visible-mounts"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/internal/ui/mounts/{path}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The path of the mount. */
                path: string;
            };
            cookie?: never;
        };
        /** Return information about the given mount. */
        get: operations["internal-ui-read-mount-information"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/internal/ui/namespaces": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Backwards compatibility is not guaranteed for this API */
        get: operations["internal-ui-list-namespaces"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/internal/ui/resultant-acl": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Backwards compatibility is not guaranteed for this API */
        get: operations["internal-ui-read-resultant-acl"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/key-status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["encryption-key-status"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/leader": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns the high availability status and current leader instance of OpenBao. */
        get: operations["leader-status"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/leases": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["leases-list"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/leases/count": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["leases-count"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/leases/lookup": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["leases-read-lease"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/leases/lookup/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["leases-look-up"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/leases/lookup/{prefix}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The path to list leases under. Example: "aws/creds/deploy" */
                prefix: string;
            };
            cookie?: never;
        };
        get: operations["leases-look-up-with-prefix"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/leases/renew": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Renews a lease, requesting to extend the lease. */
        post: operations["leases-renew-lease"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/leases/renew/{url_lease_id}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The lease identifier to renew. This is included with a lease. */
                url_lease_id: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Renews a lease, requesting to extend the lease. */
        post: operations["leases-renew-lease-with-id"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/leases/revoke": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Revokes a lease immediately. */
        post: operations["leases-revoke-lease"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/leases/revoke-force/{prefix}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The path to revoke keys under. Example: "prod/aws/ops" */
                prefix: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Revokes all secrets or tokens generated under a given prefix immediately
         * @description Unlike `/sys/leases/revoke-prefix`, this path ignores backend errors encountered during revocation. This is potentially very dangerous and should only be used in specific emergency situations where errors in the backend or the connected backend service prevent normal revocation.
         *
         *     By ignoring these errors, OpenBao abdicates responsibility for ensuring that the issued credentials or secrets are properly revoked and/or cleaned up. Access to this endpoint should be tightly controlled.
         */
        post: operations["leases-force-revoke-lease-with-prefix"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/leases/revoke-prefix/{prefix}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The path to revoke keys under. Example: "prod/aws/ops" */
                prefix: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Revokes all secrets (via a lease ID prefix) or tokens (via the tokens' path property) generated under a given prefix immediately. */
        post: operations["leases-revoke-lease-with-prefix"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/leases/revoke/{url_lease_id}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The lease identifier to renew. This is included with a lease. */
                url_lease_id: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Revokes a lease immediately. */
        post: operations["leases-revoke-lease-with-id"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/leases/tidy": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["leases-tidy"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/locked-users": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Report the locked user count metrics, for this namespace and all child namespaces. */
        get: operations["locked-users-list"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/locked-users/{mount_accessor}/unlock/{alias_identifier}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description It is the name of the alias (user). For example, if the alias belongs to userpass backend, the name should be a valid username within userpass auth method. If the alias belongs to an approle auth method, the name should be a valid RoleID */
                alias_identifier: string;
                /** @description MountAccessor is the identifier of the mount entry to which the user belongs */
                mount_accessor: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Unlocks the user with given mount_accessor and alias_identifier */
        post: operations["locked-users-unlock"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/loggers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Read the log level for all existing loggers. */
        get: operations["loggers-read-verbosity-level"];
        put?: never;
        /** Modify the log level for all existing loggers. */
        post: operations["loggers-update-verbosity-level"];
        /** Revert the all loggers to use log level provided in config. */
        delete: operations["loggers-revert-verbosity-level"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/loggers/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the logger to be modified. */
                name: string;
            };
            cookie?: never;
        };
        /** Read the log level for a single logger. */
        get: operations["loggers-read-verbosity-level-for"];
        put?: never;
        /** Modify the log level of a single logger. */
        post: operations["loggers-update-verbosity-level-for"];
        /** Revert a single logger to use log level provided in config. */
        delete: operations["loggers-revert-verbosity-level-for"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/metrics": {
        parameters: {
            query?: {
                /** @description Format to export metrics into. Currently accepts only "prometheus". */
                format?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["metrics"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/mfa/validate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Validates the login for the given MFA methods. Upon successful validation, it returns an auth response containing the client token */
        post: operations["mfa-validate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/monitor": {
        parameters: {
            query?: {
                /** @description Output format of logs. Supported values are "standard" and "json". The default is "standard". */
                log_format?: string;
                /** @description Log level to view system logs at. Currently supported values are "trace", "debug", "info", "warn", "error". */
                log_level?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["monitor"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/mounts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["mounts-list-secrets-engines"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/mounts/{path}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The path to mount to. Example: "aws/east" */
                path: string;
            };
            cookie?: never;
        };
        /** Read the configuration of the secret engine at the given path. */
        get: operations["mounts-read-configuration"];
        put?: never;
        /** Enable a new secrets engine at the given path. */
        post: operations["mounts-enable-secrets-engine"];
        /** Disable the mount point specified at the given path. */
        delete: operations["mounts-disable-secrets-engine"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/mounts/{path}/tune": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The path to mount to. Example: "aws/east" */
                path: string;
            };
            cookie?: never;
        };
        get: operations["mounts-read-tuning-information"];
        put?: never;
        post: operations["mounts-tune-configuration-parameters"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/namespaces": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List namespaces. */
        get: operations["namespaces-list-namespaces"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/namespaces/api-lock/lock": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Lock a namespace. */
        post: operations["namespaces-write-namespaces-api-lock-lock"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/namespaces/api-lock/lock/{path}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Path of the namespace. */
                path: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Lock a namespace. */
        post: operations["namespaces-write-namespaces-api-lock-lock-path"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/namespaces/api-lock/unlock": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Unlock a namespace. */
        post: operations["namespaces-write-namespaces-api-lock-unlock"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/namespaces/api-lock/unlock/{path}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Path of the namespace. */
                path: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Unlock a namespace. */
        post: operations["namespaces-write-namespaces-api-lock-unlock-path"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/namespaces/{path}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Path of the namespace. */
                path: string;
            };
            cookie?: never;
        };
        /** Retrieve a namespace. */
        get: operations["namespaces-read-namespaces-path"];
        put?: never;
        /** Create or update a namespace. */
        post: operations["namespaces-write-namespaces-path"];
        /** Delete a namespace. */
        delete: operations["namespaces-delete-namespaces-path"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/plugins/catalog": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["plugins-catalog-list-plugins"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/plugins/catalog/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the plugin */
                name: string;
            };
            cookie?: never;
        };
        /** Return the configuration data for the plugin with the given name. */
        get: operations["plugins-catalog-read-plugin-configuration"];
        put?: never;
        /** Register a new plugin, or updates an existing one with the supplied name. */
        post: operations["plugins-catalog-register-plugin"];
        /** Remove the plugin with the given name. */
        delete: operations["plugins-catalog-remove-plugin"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/plugins/catalog/{type}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The type of the plugin, may be auth, secret, or database */
                type: string;
            };
            cookie?: never;
        };
        /** List the plugins in the catalog. */
        get: operations["plugins-catalog-list-plugins-with-type"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/plugins/catalog/{type}/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the plugin */
                name: string;
                /** @description The type of the plugin, may be auth, secret, or database */
                type: string;
            };
            cookie?: never;
        };
        /** Return the configuration data for the plugin with the given name. */
        get: operations["plugins-catalog-read-plugin-configuration-with-type"];
        put?: never;
        /** Register a new plugin, or updates an existing one with the supplied name. */
        post: operations["plugins-catalog-register-plugin-with-type"];
        /** Remove the plugin with the given name. */
        delete: operations["plugins-catalog-remove-plugin-with-type"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/plugins/reload/backend": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reload mounted plugin backends.
         * @description Either the plugin name (`plugin`) or the desired plugin backend mounts (`mounts`) must be provided, but not both. In the case that the plugin name is provided, all mounted paths that use that plugin backend will be reloaded.  If (`scope`) is provided and is (`global`), the plugin(s) are reloaded globally.
         */
        post: operations["plugins-reload-backends"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/policies/acl": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["policies-list-acl-policies"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/policies/acl/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the policy. Example: "ops" */
                name: string;
            };
            cookie?: never;
        };
        /** Retrieve information about the named ACL policy. */
        get: operations["policies-read-acl-policy"];
        put?: never;
        /** Add a new or update an existing ACL policy. */
        post: operations["policies-write-acl-policy"];
        /** Delete the ACL policy with the given name. */
        delete: operations["policies-delete-acl-policy"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/policies/detailed/acl": {
        parameters: {
            query?: {
                /** @description List ACL policies */
                list?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List ACL policies with detailed information. */
        get: operations["system-list-policies-detailed-acl"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/policies/password": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List the existing password policies. */
        get: operations["policies-list-password-policies"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/policies/password/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the password policy. */
                name: string;
            };
            cookie?: never;
        };
        /** Retrieve an existing password policy. */
        get: operations["policies-read-password-policy"];
        put?: never;
        /** Add a new or update an existing password policy. */
        post: operations["policies-write-password-policy"];
        /** Delete a password policy. */
        delete: operations["policies-delete-password-policy"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/policies/password/{name}/generate": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the password policy. */
                name: string;
            };
            cookie?: never;
        };
        /** Generate a password from an existing password policy. */
        get: operations["policies-generate-password-from-password-policy"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/policy": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["policies-list"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/policy/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the policy. Example: "ops" */
                name: string;
            };
            cookie?: never;
        };
        /** Retrieve the policy body for the named policy. */
        get: operations["policies-read-acl-policy2"];
        put?: never;
        /** Add a new or update an existing policy. */
        post: operations["policies-write-acl-policy2"];
        /** Delete the policy with the given name. */
        delete: operations["policies-delete-acl-policy2"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/pprof": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns an HTML page listing the available profiles.
         * @description Returns an HTML page listing the available
         *     profiles. This should be mainly accessed via browsers or applications that can
         *     render pages.
         */
        get: operations["pprof-index"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/pprof/allocs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns a sampling of all past memory allocations.
         * @description Returns a sampling of all past memory allocations.
         */
        get: operations["pprof-memory-allocations"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/pprof/block": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns stack traces that led to blocking on synchronization primitives
         * @description Returns stack traces that led to blocking on synchronization primitives
         */
        get: operations["pprof-blocking"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/pprof/cmdline": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns the running program's command line.
         * @description Returns the running program's command line, with arguments separated by NUL bytes.
         */
        get: operations["pprof-command-line"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/pprof/goroutine": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns stack traces of all current goroutines.
         * @description Returns stack traces of all current goroutines.
         */
        get: operations["pprof-goroutines"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/pprof/heap": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns a sampling of memory allocations of live object.
         * @description Returns a sampling of memory allocations of live object.
         */
        get: operations["pprof-memory-allocations-live"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/pprof/mutex": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns stack traces of holders of contended mutexes
         * @description Returns stack traces of holders of contended mutexes
         */
        get: operations["pprof-mutexes"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/pprof/profile": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns a pprof-formatted cpu profile payload.
         * @description Returns a pprof-formatted cpu profile payload. Profiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified.
         */
        get: operations["pprof-cpu-profile"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/pprof/symbol": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns the program counters listed in the request.
         * @description Returns the program counters listed in the request.
         */
        get: operations["pprof-symbols"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/pprof/threadcreate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns stack traces that led to the creation of new OS threads
         * @description Returns stack traces that led to the creation of new OS threads
         */
        get: operations["pprof-thread-creations"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/pprof/trace": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns the execution trace in binary form.
         * @description Returns  the execution trace in binary form. Tracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified.
         */
        get: operations["pprof-execution-trace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/quotas/config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["rate-limit-quotas-read-configuration"];
        put?: never;
        post: operations["rate-limit-quotas-configure"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/quotas/rate-limit": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["rate-limit-quotas-list"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/quotas/rate-limit/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the quota rule. */
                name: string;
            };
            cookie?: never;
        };
        get: operations["rate-limit-quotas-read"];
        put?: never;
        post: operations["rate-limit-quotas-write"];
        delete: operations["rate-limit-quotas-delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/raw": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Read the value of the key at the given path. */
        get: operations["raw-read"];
        put?: never;
        /** Update the value of the key at the given path. */
        post: operations["raw-write"];
        /** Delete the key with given path. */
        delete: operations["raw-delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/raw/{path}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                path: string;
            };
            cookie?: never;
        };
        /** Read the value of the key at the given path. */
        get: operations["raw-read-path"];
        put?: never;
        /** Update the value of the key at the given path. */
        post: operations["raw-write-path"];
        /** Delete the key with given path. */
        delete: operations["raw-delete-path"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/rekey/backup": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Return the backup copy of PGP-encrypted unseal keys. */
        get: operations["rekey-read-backup-key"];
        put?: never;
        post?: never;
        /** Delete the backup copy of PGP-encrypted unseal keys. */
        delete: operations["rekey-delete-backup-key"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/rekey/init": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Reads the configuration and progress of the current rekey attempt. */
        get: operations["rekey-attempt-read-progress"];
        put?: never;
        /**
         * Initializes a new rekey attempt.
         * @description Only a single rekey attempt can take place at a time, and changing the parameters of a rekey requires canceling and starting a new rekey, which will also provide a new nonce.
         */
        post: operations["rekey-attempt-initialize"];
        /**
         * Cancels any in-progress rekey.
         * @description This clears the rekey settings as well as any progress made. This must be called to change the parameters of the rekey. Note: verification is still a part of a rekey. If rekeying is canceled during the verification flow, the current unseal keys remain valid.
         */
        delete: operations["rekey-attempt-cancel"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/rekey/recovery-key-backup": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["rekey-read-backup-recovery-key"];
        put?: never;
        post?: never;
        delete: operations["rekey-delete-backup-recovery-key"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/rekey/update": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Enter a single unseal key share to progress the rekey of the OpenBao. */
        post: operations["rekey-attempt-update"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/rekey/verify": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Read the configuration and progress of the current rekey verification attempt. */
        get: operations["rekey-verification-read-progress"];
        put?: never;
        /** Enter a single new key share to progress the rekey verification operation. */
        post: operations["rekey-verification-update"];
        /**
         * Cancel any in-progress rekey verification operation.
         * @description This clears any progress made and resets the nonce. Unlike a `DELETE` against `sys/rekey/init`, this only resets the current verification operation, not the entire rekey atttempt.
         */
        delete: operations["rekey-verification-cancel"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/remount": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Initiate a mount migration */
        post: operations["remount"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/remount/status/{migration_id}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the migration operation */
                migration_id: string;
            };
            cookie?: never;
        };
        /** Check status of a mount migration */
        get: operations["remount-status"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/renew": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Renews a lease, requesting to extend the lease. */
        post: operations["leases-renew-lease2"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/renew/{url_lease_id}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The lease identifier to renew. This is included with a lease. */
                url_lease_id: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Renews a lease, requesting to extend the lease. */
        post: operations["leases-renew-lease-with-id2"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/revoke": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Revokes a lease immediately. */
        post: operations["leases-revoke-lease2"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/revoke-force/{prefix}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The path to revoke keys under. Example: "prod/aws/ops" */
                prefix: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Revokes all secrets or tokens generated under a given prefix immediately
         * @description Unlike `/sys/leases/revoke-prefix`, this path ignores backend errors encountered during revocation. This is potentially very dangerous and should only be used in specific emergency situations where errors in the backend or the connected backend service prevent normal revocation.
         *
         *     By ignoring these errors, OpenBao abdicates responsibility for ensuring that the issued credentials or secrets are properly revoked and/or cleaned up. Access to this endpoint should be tightly controlled.
         */
        post: operations["leases-force-revoke-lease-with-prefix2"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/revoke-prefix/{prefix}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The path to revoke keys under. Example: "prod/aws/ops" */
                prefix: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Revokes all secrets (via a lease ID prefix) or tokens (via the tokens' path property) generated under a given prefix immediately. */
        post: operations["leases-revoke-lease-with-prefix2"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/revoke/{url_lease_id}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The lease identifier to renew. This is included with a lease. */
                url_lease_id: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Revokes a lease immediately. */
        post: operations["leases-revoke-lease-with-id2"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/rotate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["encryption-key-rotate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/rotate/config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["encryption-key-read-rotation-configuration"];
        put?: never;
        post: operations["encryption-key-configure-rotation-configuration"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/rotate/keyring": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["encryption-key-rotate-rotate-keyring"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/rotate/keyring/config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["encryption-key-read-rotate-keyring-config"];
        put?: never;
        post: operations["encryption-key-configure-rotate-keyring-config"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/rotate/recovery/backup": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Return the backup copy of PGP-encrypted unseal keys. */
        get: operations["rotate-read-rotate-recovery-backup"];
        put?: never;
        post?: never;
        /** Delete the backup copy of PGP-encrypted unseal keys. */
        delete: operations["rotate-delete-rotate-recovery-backup"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/rotate/recovery/init": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Reads the configuration and progress of the current root rotate attempt. */
        get: operations["rotate-attempt-read-rotate-recovery-init"];
        put?: never;
        /**
         * Initializes a new root rotate attempt.
         * @description Only a single rotate attempt can take place at a time, and changing the parameters of a rotate requires canceling and starting a new rotation, which will also provide a new nonce.
         */
        post: operations["rotate-attempt-initialize-rotate-recovery-init"];
        /**
         * Cancels any in-progress rotate root operation.
         * @description This clears the rotate settings as well as any progress made. This must be called to change the parameters of the rotate. Note: verification is still a part of a rotate. If rotating is canceled during the verification flow, the current unseal keys remain valid.
         */
        delete: operations["rotate-attempt-cancel-rotate-recovery-init"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/rotate/recovery/update": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Enter a single unseal key share to progress the rotation of the root key of OpenBao. */
        post: operations["rotate-attempt-update-rotate-recovery-update"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/rotate/recovery/verify": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Read the configuration and progress of the current rotate verification attempt. */
        get: operations["rotate-verification-read-rotate-recovery-verify"];
        put?: never;
        /** Enter a single new key share to progress the rotation verification operation. */
        post: operations["rotate-verification-update-rotate-recovery-verify"];
        /**
         * Cancel any in-progress rotate verification operation.
         * @description This clears any progress made and resets the nonce. Unlike a `DELETE` against `sys/rotate/(root/recovery)/init`, this only resets the current verification operation, not the entire rotate atttempt.
         */
        delete: operations["rotate-verification-cancel-rotate-recovery-verify"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/rotate/root": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["root-key-rotate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/rotate/root/backup": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Return the backup copy of PGP-encrypted unseal keys. */
        get: operations["rotate-read-backup-key"];
        put?: never;
        post?: never;
        /** Delete the backup copy of PGP-encrypted unseal keys. */
        delete: operations["rotate-delete-backup-key"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/rotate/root/init": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Reads the configuration and progress of the current root rotate attempt. */
        get: operations["rotate-attempt-read-progress"];
        put?: never;
        /**
         * Initializes a new root rotate attempt.
         * @description Only a single rotate attempt can take place at a time, and changing the parameters of a rotate requires canceling and starting a new rotation, which will also provide a new nonce.
         */
        post: operations["rotate-attempt-initialize"];
        /**
         * Cancels any in-progress rotate root operation.
         * @description This clears the rotate settings as well as any progress made. This must be called to change the parameters of the rotate. Note: verification is still a part of a rotate. If rotating is canceled during the verification flow, the current unseal keys remain valid.
         */
        delete: operations["rotate-attempt-cancel"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/rotate/root/update": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Enter a single unseal key share to progress the rotation of the root key of OpenBao. */
        post: operations["rotate-attempt-update"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/rotate/root/verify": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Read the configuration and progress of the current rotate verification attempt. */
        get: operations["rotate-verification-read-progress"];
        put?: never;
        /** Enter a single new key share to progress the rotation verification operation. */
        post: operations["rotate-verification-update"];
        /**
         * Cancel any in-progress rotate verification operation.
         * @description This clears any progress made and resets the nonce. Unlike a `DELETE` against `sys/rotate/(root/recovery)/init`, this only resets the current verification operation, not the entire rotate atttempt.
         */
        delete: operations["rotate-verification-cancel"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/seal": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Seal the OpenBao instance. */
        post: operations["seal"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/seal-status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Check the seal status of an OpenBao instance. */
        get: operations["seal-status"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/step-down": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Cause the node to give up active status.
         * @description This endpoint forces the node to give up active status. If the node does not have active status, this endpoint does nothing. Note that the node will sleep for ten seconds before attempting to grab the active lock again, but if no standby nodes grab the active lock in the interim, the same node may become the active node again.
         */
        post: operations["step-down-leader"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/tools/hash": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["generate-hash"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/tools/hash/{urlalgorithm}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Algorithm to use (POST URL parameter) */
                urlalgorithm: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["generate-hash-with-algorithm"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/tools/random": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["generate-random"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/tools/random/{source}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Which system to source random data from, ether "platform", "seal", or "all". */
                source: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["generate-random-with-source"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/tools/random/{source}/{urlbytes}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Which system to source random data from, ether "platform", "seal", or "all". */
                source: string;
                /** @description The number of bytes to generate (POST URL parameter) */
                urlbytes: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["generate-random-with-source-and-bytes"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/tools/random/{urlbytes}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The number of bytes to generate (POST URL parameter) */
                urlbytes: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["generate-random-with-bytes"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/unseal": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Unseal the OpenBao instance. */
        post: operations["unseal"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/version-history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns map of historical version change entries */
        get: operations["version-history"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/wrapping/lookup": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Look up wrapping properties for the requester's token. */
        get: operations["read-wrapping-properties2"];
        put?: never;
        /** Look up wrapping properties for the given token. */
        post: operations["read-wrapping-properties"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/wrapping/rewrap": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["rewrap"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/wrapping/unwrap": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["unwrap"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sys/wrapping/wrap": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["wrap"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/{secret_mount_path}/^.*$": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Path that the backend was mounted at */
                secret_mount_path: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/{secret_mount_path}/config": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Path that the backend was mounted at */
                secret_mount_path: string;
            };
            cookie?: never;
        };
        /** Read the backend level settings. */
        get: operations["kv-read-config"];
        put?: never;
        /** Configure backend level settings that are applied to every key in the key-value store. */
        post: operations["kv-write-config"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/{secret_mount_path}/data/{path}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Location of the secret. */
                path: string;
                /** @description Path that the backend was mounted at */
                secret_mount_path: string;
            };
            cookie?: never;
        };
        get: operations["kv-read-data-path"];
        put?: never;
        post: operations["kv-write-data-path"];
        delete: operations["kv-delete-data-path"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/{secret_mount_path}/delete/{path}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Location of the secret. */
                path: string;
                /** @description Path that the backend was mounted at */
                secret_mount_path: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["kv-write-delete-path"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/{secret_mount_path}/destroy/{path}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Location of the secret. */
                path: string;
                /** @description Path that the backend was mounted at */
                secret_mount_path: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["kv-write-destroy-path"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/{secret_mount_path}/detailed-metadata/{path}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Location of the secret. */
                path: string;
                /** @description Path that the backend was mounted at */
                secret_mount_path: string;
            };
            cookie?: never;
        };
        get: operations["kv-list-detailed-metadata-path"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/{secret_mount_path}/metadata/{path}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Location of the secret. */
                path: string;
                /** @description Path that the backend was mounted at */
                secret_mount_path: string;
            };
            cookie?: never;
        };
        get: operations["kv-read-metadata-path"];
        put?: never;
        post: operations["kv-write-metadata-path"];
        delete: operations["kv-delete-metadata-path"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/{secret_mount_path}/subkeys/{path}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Location of the secret. */
                path: string;
                /** @description Path that the backend was mounted at */
                secret_mount_path: string;
            };
            cookie?: never;
        };
        get: operations["kv-read-subkeys-path"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/{secret_mount_path}/undelete/{path}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Location of the secret. */
                path: string;
                /** @description Path that the backend was mounted at */
                secret_mount_path: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["kv-write-undelete-path"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        AliasCreateRequest: {
            /** @description Entity ID to which this alias belongs to */
            canonical_id?: string;
            /** @description Entity ID to which this alias belongs to. This field is deprecated in favor of 'canonical_id'. */
            entity_id?: string;
            /** @description ID of the alias */
            id?: string;
            /** @description Mount accessor to which this alias belongs to */
            mount_accessor?: string;
            /** @description Name of the alias */
            name?: string;
        };
        AliasUpdateByIdRequest: {
            /** @description Entity ID to which this alias should be tied to */
            canonical_id?: string;
            /** @description Entity ID to which this alias should be tied to. This field is deprecated in favor of 'canonical_id'. */
            entity_id?: string;
            /** @description Mount accessor to which this alias belongs to */
            mount_accessor?: string;
            /** @description Name of the alias */
            name?: string;
        };
        AuditingCalculateHashRequest: {
            input?: string;
        };
        AuditingCalculateHashResponse: {
            hash?: string;
        };
        AuditingEnableDeviceRequest: {
            /** @description User-friendly description for this audit backend. */
            description?: string;
            /**
             * @description Mark the mount as a local mount, which is not replicated and is unaffected by replication.
             * @default false
             */
            local: boolean;
            /**
             * Format: kvpairs
             * @description Configuration options for the audit backend.
             */
            options?: Record<string, never>;
            /** @description The type of the backend. Example: "mysql" */
            type?: string;
        };
        AuditingEnableRequestHeaderRequest: {
            hmac?: boolean;
        };
        AuditingListRequestHeadersResponse: {
            /** Format: map */
            headers?: Record<string, never>;
        };
        AuthEnableMethodRequest: {
            /**
             * Format: map
             * @description Configuration for this mount, such as plugin_name.
             */
            config?: Record<string, never>;
            /** @description User-friendly description for this credential backend. */
            description?: string;
            /**
             * @description Whether to give the mount access to OpenBao's external entropy.
             * @default false
             */
            external_entropy_access: boolean;
            /**
             * @description Mark the mount as a local mount, which is not replicated and is unaffected by replication.
             * @default false
             */
            local: boolean;
            /**
             * Format: kvpairs
             * @description The options to pass into the backend. Should be a json object with string keys and values.
             */
            options?: Record<string, never>;
            /** @description Name of the auth plugin to use based from the name in the plugin catalog. */
            plugin_name?: string;
            /** @description The semantic version of the plugin to use. */
            plugin_version?: string;
            /**
             * @description Whether to turn on seal wrapping for the mount.
             * @default false
             */
            seal_wrap: boolean;
            /** @description The type of the backend. Example: "userpass" */
            type?: string;
        };
        AuthReadConfigurationResponse: {
            accessor?: string;
            /** Format: map */
            config?: Record<string, never>;
            deprecation_status?: string;
            description?: string;
            external_entropy_access?: boolean;
            local?: boolean;
            /** Format: map */
            options?: Record<string, never>;
            plugin_version?: string;
            running_plugin_version?: string;
            running_sha256?: string;
            seal_wrap?: boolean;
            type?: string;
            uuid?: string;
        };
        AuthReadTuningInformationResponse: {
            allowed_managed_keys?: string[];
            allowed_response_headers?: string[];
            audit_non_hmac_request_keys?: string[];
            audit_non_hmac_response_keys?: string[];
            default_lease_ttl?: number;
            description?: string;
            external_entropy_access?: boolean;
            force_no_cache?: boolean;
            listing_visibility?: string;
            max_lease_ttl?: number;
            /** Format: map */
            options?: Record<string, never>;
            passthrough_request_headers?: string[];
            plugin_version?: string;
            token_type?: string;
            /** Format: int64 */
            user_lockout_counter_reset_duration?: number;
            user_lockout_disable?: boolean;
            /** Format: int64 */
            user_lockout_duration?: number;
            /** Format: int64 */
            user_lockout_threshold?: number;
        };
        AuthTuneConfigurationParametersRequest: {
            /** @description A list of headers to whitelist and allow a plugin to set on responses. */
            allowed_response_headers?: string[];
            /** @description The list of keys in the request data object that will not be HMAC'ed by audit devices. */
            audit_non_hmac_request_keys?: string[];
            /** @description The list of keys in the response data object that will not be HMAC'ed by audit devices. */
            audit_non_hmac_response_keys?: string[];
            /** @description The default lease TTL for this mount. */
            default_lease_ttl?: string;
            /** @description User-friendly description for this credential backend. */
            description?: string;
            /** @description Determines the visibility of the mount in the UI-specific listing endpoint. Accepted value are 'unauth' and 'hidden', with the empty default ('') behaving like 'hidden'. */
            listing_visibility?: string;
            /** @description The max lease TTL for this mount. */
            max_lease_ttl?: string;
            /**
             * Format: kvpairs
             * @description The options to pass into the backend. Should be a json object with string keys and values.
             */
            options?: Record<string, never>;
            /** @description A list of headers to whitelist and pass from the request to the plugin. */
            passthrough_request_headers?: string[];
            /** @description The semantic version of the plugin to use. */
            plugin_version?: string;
            /** @description The type of token to issue (service or batch). */
            token_type?: string;
            /**
             * Format: map
             * @description The user lockout configuration to pass into the backend. Should be a json object with string keys and values.
             */
            user_lockout_config?: Record<string, never>;
        };
        CollectHostInformationResponse: {
            cpu?: Record<string, never>[];
            cpu_times?: Record<string, never>[];
            disk?: Record<string, never>[];
            /** Format: map */
            host?: Record<string, never>;
            /** Format: map */
            memory?: Record<string, never>;
            /** Format: date-time */
            timestamp?: string;
        };
        CorsConfigureRequest: {
            /** @description A comma-separated string or array of strings indicating headers that are allowed on cross-origin requests. */
            allowed_headers?: string[];
            /** @description A comma-separated string or array of strings indicating origins that may make cross-origin requests. */
            allowed_origins?: string[];
            /** @description Enables or disables CORS headers on requests. */
            enable?: boolean;
        };
        CorsReadConfigurationResponse: {
            allowed_headers?: string[];
            allowed_origins?: string[];
            enabled?: boolean;
        };
        DecodeRequest: {
            /** @description Specifies the encoded token (result from generate-root). */
            encoded_token?: string;
            /** @description Specifies the otp code for decode. */
            otp?: string;
        };
        EncryptionKeyConfigureRotateKeyringConfigRequest: {
            /** @description Whether automatic rotation is enabled. */
            enabled?: boolean;
            /**
             * Format: seconds
             * @description How long after installation of an active key term that the key will be automatically rotated.
             */
            interval?: number;
            /**
             * Format: int64
             * @description The number of encryption operations performed before the barrier key is automatically rotated.
             */
            max_operations?: number;
        };
        EncryptionKeyConfigureRotationConfigurationRequest: {
            /** @description Whether automatic rotation is enabled. */
            enabled?: boolean;
            /**
             * Format: seconds
             * @description How long after installation of an active key term that the key will be automatically rotated.
             */
            interval?: number;
            /**
             * Format: int64
             * @description The number of encryption operations performed before the barrier key is automatically rotated.
             */
            max_operations?: number;
        };
        EncryptionKeyReadRotateKeyringConfigResponse: {
            /** @description Whether automatic rotation is enabled. */
            enabled?: boolean;
            /**
             * Format: seconds
             * @description How long after installation of an active key term that the key will be automatically rotated.
             */
            interval?: number;
            /**
             * Format: int64
             * @description The number of encryption operations performed before the barrier key is automatically rotated.
             */
            max_operations?: number;
        };
        EncryptionKeyReadRotationConfigurationResponse: {
            /** @description Whether automatic rotation is enabled. */
            enabled?: boolean;
            /**
             * Format: seconds
             * @description How long after installation of an active key term that the key will be automatically rotated.
             */
            interval?: number;
            /**
             * Format: int64
             * @description The number of encryption operations performed before the barrier key is automatically rotated.
             */
            max_operations?: number;
        };
        EntityBatchDeleteRequest: {
            /** @description Entity IDs to delete */
            entity_ids?: string[];
        };
        EntityCreateAliasRequest: {
            /** @description Entity ID to which this alias belongs */
            canonical_id?: string;
            /**
             * Format: kvpairs
             * @description User provided key-value pairs
             */
            custom_metadata?: Record<string, never>;
            /** @description Entity ID to which this alias belongs. This field is deprecated, use canonical_id. */
            entity_id?: string;
            /** @description ID of the entity alias. If set, updates the corresponding entity alias. */
            id?: string;
            /** @description Mount accessor to which this alias belongs to; unused for a modify */
            mount_accessor?: string;
            /** @description Name of the alias; unused for a modify */
            name?: string;
        };
        EntityCreateRequest: {
            /** @description If set true, tokens tied to this identity will not be able to be used (but will not be revoked). */
            disabled?: boolean;
            /** @description ID of the entity. If set, updates the corresponding existing entity. */
            id?: string;
            /**
             * Format: kvpairs
             * @description Metadata to be associated with the entity. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: bao <command> <path> metadata=key1=value1 metadata=key2=value2
             */
            metadata?: Record<string, never>;
            /** @description Name of the entity */
            name?: string;
            /** @description Policies to be tied to the entity. */
            policies?: string[];
        };
        EntityLookUpRequest: {
            /** @description ID of the alias. */
            alias_id?: string;
            /** @description Accessor of the mount to which the alias belongs to. This should be supplied in conjunction with 'alias_name'. */
            alias_mount_accessor?: string;
            /** @description Name of the alias. This should be supplied in conjunction with 'alias_mount_accessor'. */
            alias_name?: string;
            /** @description ID of the entity. */
            id?: string;
            /** @description Name of the entity. */
            name?: string;
        };
        EntityMergeRequest: {
            /** @description Alias IDs to keep in case of conflicting aliases. Ignored if no conflicting aliases found */
            conflicting_alias_ids_to_keep?: string[];
            /** @description Setting this will follow the 'mine' strategy for merging MFA secrets. If there are secrets of the same type both in entities that are merged from and in entity into which all others are getting merged, secrets in the destination will be unaltered. If not set, this API will throw an error containing all the conflicts. */
            force?: boolean;
            /** @description Entity IDs which need to get merged */
            from_entity_ids?: string[];
            /** @description Entity ID into which all the other entities need to get merged */
            to_entity_id?: string;
        };
        EntityUpdateAliasByIdRequest: {
            /** @description Entity ID to which this alias should be tied to */
            canonical_id?: string;
            /**
             * Format: kvpairs
             * @description User provided key-value pairs
             */
            custom_metadata?: Record<string, never>;
            /** @description Entity ID to which this alias belongs to. This field is deprecated, use canonical_id. */
            entity_id?: string;
            /** @description (Unused) */
            mount_accessor?: string;
            /** @description (Unused) */
            name?: string;
        };
        EntityUpdateByIdRequest: {
            /** @description If set true, tokens tied to this identity will not be able to be used (but will not be revoked). */
            disabled?: boolean;
            /**
             * Format: kvpairs
             * @description Metadata to be associated with the entity. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: bao <command> <path> metadata=key1=value1 metadata=key2=value2
             */
            metadata?: Record<string, never>;
            /** @description Name of the entity */
            name?: string;
            /** @description Policies to be tied to the entity. */
            policies?: string[];
        };
        EntityUpdateByNameRequest: {
            /** @description If set true, tokens tied to this identity will not be able to be used (but will not be revoked). */
            disabled?: boolean;
            /** @description ID of the entity. If set, updates the corresponding existing entity. */
            id?: string;
            /**
             * Format: kvpairs
             * @description Metadata to be associated with the entity. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: bao <command> <path> metadata=key1=value1 metadata=key2=value2
             */
            metadata?: Record<string, never>;
            /** @description Policies to be tied to the entity. */
            policies?: string[];
        };
        GenerateHashRequest: {
            /**
             * @description Algorithm to use (POST body parameter). Valid values are: * sha2-224 * sha2-256 * sha2-384 * sha2-512 Defaults to "sha2-256".
             * @default sha2-256
             */
            algorithm: string;
            /**
             * @description Encoding format to use. Can be "hex" or "base64". Defaults to "hex".
             * @default hex
             */
            format: string;
            /** @description The base64-encoded input data */
            input?: string;
            /** @description Algorithm to use (POST URL parameter) */
            urlalgorithm?: string;
        };
        GenerateHashResponse: {
            sum?: string;
        };
        GenerateHashWithAlgorithmRequest: {
            /**
             * @description Algorithm to use (POST body parameter). Valid values are: * sha2-224 * sha2-256 * sha2-384 * sha2-512 Defaults to "sha2-256".
             * @default sha2-256
             */
            algorithm: string;
            /**
             * @description Encoding format to use. Can be "hex" or "base64". Defaults to "hex".
             * @default hex
             */
            format: string;
            /** @description The base64-encoded input data */
            input?: string;
        };
        GenerateHashWithAlgorithmResponse: {
            sum?: string;
        };
        GenerateRandomRequest: {
            /**
             * @description The number of bytes to generate (POST body parameter). Defaults to 32 (256 bits).
             * @default 32
             */
            bytes: number;
            /**
             * @description Encoding format to use. Can be "hex" or "base64". Defaults to "base64".
             * @default base64
             */
            format: string;
            /**
             * @description Which system to source random data from, ether "platform", "seal", or "all".
             * @default platform
             */
            source: string;
            /** @description The number of bytes to generate (POST URL parameter) */
            urlbytes?: string;
        };
        GenerateRandomResponse: {
            random_bytes?: string;
        };
        GenerateRandomWithBytesRequest: {
            /**
             * @description The number of bytes to generate (POST body parameter). Defaults to 32 (256 bits).
             * @default 32
             */
            bytes: number;
            /**
             * @description Encoding format to use. Can be "hex" or "base64". Defaults to "base64".
             * @default base64
             */
            format: string;
            /**
             * @description Which system to source random data from, ether "platform", "seal", or "all".
             * @default platform
             */
            source: string;
        };
        GenerateRandomWithBytesResponse: {
            random_bytes?: string;
        };
        GenerateRandomWithSourceAndBytesRequest: {
            /**
             * @description The number of bytes to generate (POST body parameter). Defaults to 32 (256 bits).
             * @default 32
             */
            bytes: number;
            /**
             * @description Encoding format to use. Can be "hex" or "base64". Defaults to "base64".
             * @default base64
             */
            format: string;
        };
        GenerateRandomWithSourceAndBytesResponse: {
            random_bytes?: string;
        };
        GenerateRandomWithSourceRequest: {
            /**
             * @description The number of bytes to generate (POST body parameter). Defaults to 32 (256 bits).
             * @default 32
             */
            bytes: number;
            /**
             * @description Encoding format to use. Can be "hex" or "base64". Defaults to "base64".
             * @default base64
             */
            format: string;
            /** @description The number of bytes to generate (POST URL parameter) */
            urlbytes?: string;
        };
        GenerateRandomWithSourceResponse: {
            random_bytes?: string;
        };
        GroupCreateAliasRequest: {
            /** @description ID of the group to which this is an alias. */
            canonical_id?: string;
            /** @description ID of the group alias. */
            id?: string;
            /** @description Mount accessor to which this alias belongs to. */
            mount_accessor?: string;
            /** @description Alias of the group. */
            name?: string;
        };
        GroupCreateRequest: {
            /** @description ID of the group. If set, updates the corresponding existing group. */
            id?: string;
            /** @description Entity IDs to be assigned as group members. */
            member_entity_ids?: string[];
            /** @description Group IDs to be assigned as group members. */
            member_group_ids?: string[];
            /**
             * Format: kvpairs
             * @description Metadata to be associated with the group. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: bao <command> <path> metadata=key1=value1 metadata=key2=value2
             */
            metadata?: Record<string, never>;
            /** @description Name of the group. */
            name?: string;
            /** @description Policies to be tied to the group. */
            policies?: string[];
            /** @description Type of the group, 'internal' or 'external'. Defaults to 'internal' */
            type?: string;
        };
        GroupLookUpRequest: {
            /** @description ID of the alias. */
            alias_id?: string;
            /** @description Accessor of the mount to which the alias belongs to. This should be supplied in conjunction with 'alias_name'. */
            alias_mount_accessor?: string;
            /** @description Name of the alias. This should be supplied in conjunction with 'alias_mount_accessor'. */
            alias_name?: string;
            /** @description ID of the group. */
            id?: string;
            /** @description Name of the group. */
            name?: string;
        };
        GroupUpdateAliasByIdRequest: {
            /** @description ID of the group to which this is an alias. */
            canonical_id?: string;
            /** @description Mount accessor to which this alias belongs to. */
            mount_accessor?: string;
            /** @description Alias of the group. */
            name?: string;
        };
        GroupUpdateByIdRequest: {
            /** @description Entity IDs to be assigned as group members. */
            member_entity_ids?: string[];
            /** @description Group IDs to be assigned as group members. */
            member_group_ids?: string[];
            /**
             * Format: kvpairs
             * @description Metadata to be associated with the group. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: bao <command> <path> metadata=key1=value1 metadata=key2=value2
             */
            metadata?: Record<string, never>;
            /** @description Name of the group. */
            name?: string;
            /** @description Policies to be tied to the group. */
            policies?: string[];
            /** @description Type of the group, 'internal' or 'external'. Defaults to 'internal' */
            type?: string;
        };
        GroupUpdateByNameRequest: {
            /** @description ID of the group. If set, updates the corresponding existing group. */
            id?: string;
            /** @description Entity IDs to be assigned as group members. */
            member_entity_ids?: string[];
            /** @description Group IDs to be assigned as group members. */
            member_group_ids?: string[];
            /**
             * Format: kvpairs
             * @description Metadata to be associated with the group. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: bao <command> <path> metadata=key1=value1 metadata=key2=value2
             */
            metadata?: Record<string, never>;
            /** @description Policies to be tied to the group. */
            policies?: string[];
            /** @description Type of the group, 'internal' or 'external'. Defaults to 'internal' */
            type?: string;
        };
        HaStatusResponse: {
            nodes?: Record<string, never>[];
        };
        InitializeSystemRequest: {
            /** @description Specifies an array of PGP public keys used to encrypt the output unseal keys. Ordering is preserved. The keys must be base64-encoded from their original binary representation. The size of this array must be the same as `secret_shares`. */
            pgp_keys?: string[];
            /** @description Specifies an array of PGP public keys used to encrypt the output recovery keys. Ordering is preserved. The keys must be base64-encoded from their original binary representation. The size of this array must be the same as `recovery_shares`. */
            recovery_pgp_keys?: string[];
            /** @description Specifies the number of shares to split the recovery key into. */
            recovery_shares?: number;
            /** @description Specifies the number of shares required to reconstruct the recovery key. This must be less than or equal to `recovery_shares`. */
            recovery_threshold?: number;
            /** @description Specifies a PGP public key used to encrypt the initial root token. The key must be base64-encoded from its original binary representation. */
            root_token_pgp_key?: string;
            /** @description Specifies the number of shares to split the unseal key into. */
            secret_shares?: number;
            /** @description Specifies the number of shares required to reconstruct the unseal key. This must be less than or equal secret_shares. If using OpenBao HSM with auto-unsealing, this value must be the same as `secret_shares`. */
            secret_threshold?: number;
            /** @description Specifies the number of shares that should be encrypted by the HSM and stored for auto-unsealing. Currently must be the same as `secret_shares`. */
            stored_shares?: number;
        };
        InternalCountEntitiesResponse: {
            /** Format: map */
            counters?: Record<string, never>;
        };
        InternalCountTokensResponse: {
            /** Format: map */
            counters?: Record<string, never>;
        };
        InternalGenerateOpenApiDocumentWithParametersRequest: {
            /** @description Context string appended to every operationId */
            context?: string;
        };
        InternalUiListEnabledFeatureFlagsResponse: {
            feature_flags?: string[];
        };
        InternalUiListEnabledVisibleMountsResponse: {
            /**
             * Format: map
             * @description auth mounts
             */
            auth?: Record<string, never>;
            /**
             * Format: map
             * @description secret mounts
             */
            secret?: Record<string, never>;
        };
        InternalUiListNamespacesResponse: {
            /** @description field is only returned if there are one or more namespaces */
            keys?: string[];
        };
        InternalUiReadMountInformationResponse: {
            accessor?: string;
            /** Format: map */
            config?: Record<string, never>;
            deprecation_status?: string;
            description?: string;
            external_entropy_access?: boolean;
            local?: boolean;
            /** Format: map */
            options?: Record<string, never>;
            path?: string;
            plugin_version?: string;
            running_plugin_version?: string;
            running_sha256?: string;
            seal_wrap?: boolean;
            type?: string;
            uuid?: string;
        };
        InternalUiReadResultantAclResponse: {
            /** Format: map */
            exact_paths?: Record<string, never>;
            /** Format: map */
            glob_paths?: Record<string, never>;
            root?: boolean;
        };
        KvWriteConfigRequest: {
            /** @description If true, the backend will require the cas parameter to be set for each write */
            cas_required?: boolean;
            /**
             * Format: seconds
             * @description If set, the length of time before a version is deleted. A negative duration disables the use of delete_version_after on all keys. A zero duration clears the current setting. Accepts a Go duration format string.
             */
            delete_version_after?: number;
            /** @description The number of versions to keep for each key. Defaults to 10 */
            max_versions?: number;
            /** @description If true, the backend will require the metadata_cas parameter to be set for each metadata update */
            metadata_cas_required?: boolean;
        };
        KvWriteDataPathRequest: {
            /**
             * Format: map
             * @description The contents of the data map will be stored and returned on read.
             */
            data?: Record<string, never>;
            /**
             * Format: map
             * @description Options for writing a KV entry. Set the "cas" value to use a Check-And-Set operation. If not set the write will be allowed. If set to 0 a write will only be allowed if the key doesn’t exist. If the index is non-zero the write will only be allowed if the key’s current version matches the version specified in the cas parameter.
             */
            options?: Record<string, never>;
            /** @description If provided during a read, the value at the version number will be returned */
            version?: number;
        };
        KvWriteDeletePathRequest: {
            /** @description The versions to be archived. The versioned data will not be deleted, but it will no longer be returned in normal get requests. */
            versions?: number[];
        };
        KvWriteDestroyPathRequest: {
            /** @description The versions to destroy. Their data will be permanently deleted. */
            versions?: number[];
        };
        KvWriteMetadataPathRequest: {
            /** @description Optional entry to list begin listing after, not required to exist. Only used for listing. */
            after?: string;
            /** @description If true the key will require the cas parameter to be set on all write requests. If false, the backend’s configuration will be used. */
            cas_required?: boolean;
            /**
             * Format: map
             * @description User-provided key-value pairs that are used to describe arbitrary and version-agnostic information about a secret.
             */
            custom_metadata?: Record<string, never>;
            /**
             * Format: seconds
             * @description The length of time before a version is deleted. If not set, the backend's configured delete_version_after is used. Cannot be greater than the backend's delete_version_after. A zero duration clears the current setting. A negative duration will cause an error.
             */
            delete_version_after?: number;
            /** @description Optional number of entries to return; defaults to all entries. Only used for listing. */
            limit?: number;
            /** @description The number of versions to keep. If not set, the backend’s configured max version is used. */
            max_versions?: number;
            /** @description Check-and-set parameter for metadata updates. Must match the current metadata version for the update to succeed. Set to 0 for initial metadata creation. */
            metadata_cas?: number;
            /** @description If true the key will require the cas parameter to be set on all metadata update requests. If false, the backend's configuration will be used. */
            metadata_cas_required?: boolean;
        };
        KvWriteUndeletePathRequest: {
            /** @description The versions to unarchive. The versions will be restored and their data will be returned on normal get requests. */
            versions?: number[];
        };
        LeaderStatusResponse: {
            /** Format: date-time */
            active_time?: string;
            ha_enabled?: boolean;
            is_self?: boolean;
            /** Format: int64 */
            last_wal?: number;
            leader_address?: string;
            leader_cluster_address?: string;
            performance_standby?: boolean;
            /** Format: int64 */
            performance_standby_last_remote_wal?: number;
            /** Format: int64 */
            raft_applied_index?: number;
            /** Format: int64 */
            raft_committed_index?: number;
        };
        LeasesCountResponse: {
            /** @description Number of matching leases per mount */
            counts?: number;
            /** @description Number of matching leases */
            lease_count?: number;
        };
        LeasesListResponse: {
            /** @description Number of matching leases per mount */
            counts?: number;
            /** @description Number of matching leases */
            lease_count?: number;
        };
        LeasesLookUpResponse: {
            /** @description A list of lease ids */
            keys?: string[];
        };
        LeasesLookUpWithPrefixResponse: {
            /** @description A list of lease ids */
            keys?: string[];
        };
        LeasesReadLeaseRequest: {
            /** @description The lease identifier to renew. This is included with a lease. */
            lease_id?: string;
        };
        LeasesReadLeaseResponse: {
            /**
             * Format: date-time
             * @description Optional lease expiry time
             */
            expire_time?: string;
            /** @description Lease id */
            id?: string;
            /**
             * Format: date-time
             * @description Timestamp for the lease's issue time
             */
            issue_time?: string;
            /**
             * Format: date-time
             * @description Optional Timestamp of the last time the lease was renewed
             */
            last_renewal?: string;
            /** @description True if the lease is able to be renewed */
            renewable?: boolean;
            /** @description Time to Live set for the lease, returns 0 if unset */
            ttl?: number;
        };
        LeasesRenewLease2Request: {
            /**
             * Format: seconds
             * @description The desired increment in seconds to the lease
             */
            increment?: number;
            /** @description The lease identifier to renew. This is included with a lease. */
            lease_id?: string;
            /** @description The lease identifier to renew. This is included with a lease. */
            url_lease_id?: string;
        };
        LeasesRenewLeaseRequest: {
            /**
             * Format: seconds
             * @description The desired increment in seconds to the lease
             */
            increment?: number;
            /** @description The lease identifier to renew. This is included with a lease. */
            lease_id?: string;
            /** @description The lease identifier to renew. This is included with a lease. */
            url_lease_id?: string;
        };
        LeasesRenewLeaseWithId2Request: {
            /**
             * Format: seconds
             * @description The desired increment in seconds to the lease
             */
            increment?: number;
            /** @description The lease identifier to renew. This is included with a lease. */
            lease_id?: string;
        };
        LeasesRenewLeaseWithIdRequest: {
            /**
             * Format: seconds
             * @description The desired increment in seconds to the lease
             */
            increment?: number;
            /** @description The lease identifier to renew. This is included with a lease. */
            lease_id?: string;
        };
        LeasesRevokeLease2Request: {
            /** @description The lease identifier to renew. This is included with a lease. */
            lease_id?: string;
            /**
             * @description Whether or not to perform the revocation synchronously
             * @default true
             */
            sync: boolean;
            /** @description The lease identifier to renew. This is included with a lease. */
            url_lease_id?: string;
        };
        LeasesRevokeLeaseRequest: {
            /** @description The lease identifier to renew. This is included with a lease. */
            lease_id?: string;
            /**
             * @description Whether or not to perform the revocation synchronously
             * @default true
             */
            sync: boolean;
            /** @description The lease identifier to renew. This is included with a lease. */
            url_lease_id?: string;
        };
        LeasesRevokeLeaseWithId2Request: {
            /** @description The lease identifier to renew. This is included with a lease. */
            lease_id?: string;
            /**
             * @description Whether or not to perform the revocation synchronously
             * @default true
             */
            sync: boolean;
        };
        LeasesRevokeLeaseWithIdRequest: {
            /** @description The lease identifier to renew. This is included with a lease. */
            lease_id?: string;
            /**
             * @description Whether or not to perform the revocation synchronously
             * @default true
             */
            sync: boolean;
        };
        LeasesRevokeLeaseWithPrefix2Request: {
            /**
             * @description Whether or not to perform the revocation synchronously
             * @default true
             */
            sync: boolean;
        };
        LeasesRevokeLeaseWithPrefixRequest: {
            /**
             * @description Whether or not to perform the revocation synchronously
             * @default true
             */
            sync: boolean;
        };
        LoggersUpdateVerbosityLevelForRequest: {
            /** @description Log verbosity level. Supported values (in order of detail) are "trace", "debug", "info", "warn", and "error". */
            level?: string;
        };
        LoggersUpdateVerbosityLevelRequest: {
            /** @description Log verbosity level. Supported values (in order of detail) are "trace", "debug", "info", "warn", and "error". */
            level?: string;
        };
        MfaAdminDestroyTotpSecretRequest: {
            /** @description Identifier of the entity from which the MFA method secret needs to be removed. */
            entity_id: string;
            /** @description The unique identifier for this MFA method. */
            method_id: string;
        };
        MfaAdminGenerateTotpSecretRequest: {
            /** @description Entity ID on which the generated secret needs to get stored. */
            entity_id: string;
            /** @description The unique identifier for this MFA method. */
            method_id: string;
        };
        MfaConfigureDuoMethodRequest: {
            /** @description API host name for Duo. */
            api_hostname?: string;
            /** @description Integration key for Duo. */
            integration_key?: string;
            /** @description The unique name identifier for this MFA method. */
            method_name?: string;
            /** @description Push information for Duo. */
            push_info?: string;
            /** @description Secret key for Duo. */
            secret_key?: string;
            /** @description If true, the user is reminded to use the passcode upon MFA validation. This option does not enforce using the passcode. Defaults to false. */
            use_passcode?: boolean;
            /** @description A template string for mapping Identity names to MFA method names. Values to subtitute should be placed in {{}}. For example, "{{alias.name}}@example.com". Currently-supported mappings: alias.name: The name returned by the mount configured via the mount_accessor parameter If blank, the Alias's name field will be used as-is. */
            username_format?: string;
        };
        MfaConfigureOktaMethodRequest: {
            /** @description Okta API key. */
            api_token?: string;
            /** @description The base domain to use for the Okta API. When not specified in the configuration, "okta.com" is used. */
            base_url?: string;
            /** @description The unique name identifier for this MFA method. */
            method_name?: string;
            /** @description Name of the organization to be used in the Okta API. */
            org_name?: string;
            /** @description If true, the username will only match the primary email for the account. Defaults to false. */
            primary_email?: boolean;
            /** @description (DEPRECATED) Use base_url instead. */
            production?: boolean;
            /** @description A template string for mapping Identity names to MFA method names. Values to substitute should be placed in {{}}. For example, "{{entity.name}}@example.com". If blank, the Entity's name field will be used as-is. */
            username_format?: string;
        };
        MfaConfigurePingIdMethodRequest: {
            /** @description The unique name identifier for this MFA method. */
            method_name?: string;
            /** @description The settings file provided by Ping, Base64-encoded. This must be a settings file suitable for third-party clients, not the PingID SDK or PingFederate. */
            settings_file_base64?: string;
            /** @description A template string for mapping Identity names to MFA method names. Values to subtitute should be placed in {{}}. For example, "{{alias.name}}@example.com". Currently-supported mappings: alias.name: The name returned by the mount configured via the mount_accessor parameter If blank, the Alias's name field will be used as-is. */
            username_format?: string;
        };
        MfaConfigureTotpMethodRequest: {
            /**
             * @description The hashing algorithm used to generate the TOTP token. Options include SHA1, SHA256 and SHA512.
             * @default SHA1
             */
            algorithm: string;
            /**
             * @description The number of digits in the generated TOTP token. This value can either be 6 or 8.
             * @default 6
             */
            digits: number;
            /** @description The name of the key's issuing organization. */
            issuer?: string;
            /**
             * @description Determines the size in bytes of the generated key.
             * @default 20
             */
            key_size: number;
            /** @description Max number of allowed validation attempts. */
            max_validation_attempts?: number;
            /** @description The unique name identifier for this MFA method. */
            method_name?: string;
            /**
             * Format: seconds
             * @description The length of time used to generate a counter for the TOTP token calculation.
             * @default 30
             */
            period: number;
            /**
             * @description The pixel size of the generated square QR code.
             * @default 200
             */
            qr_size: number;
            /**
             * @description The number of delay periods that are allowed when validating a TOTP token. This value can either be 0 or 1.
             * @default 1
             */
            skew: number;
        };
        MfaGenerateTotpSecretRequest: {
            /** @description The unique identifier for this MFA method. */
            method_id: string;
        };
        MfaValidateRequest: {
            /**
             * Format: map
             * @description A map from MFA method ID to a slice of passcodes or an empty slice if the method does not use passcodes
             */
            mfa_payload: Record<string, never>;
            /** @description ID for this MFA request */
            mfa_request_id: string;
        };
        MfaWriteLoginEnforcementRequest: {
            /** @description Array of auth mount accessor IDs */
            auth_method_accessors?: string[];
            /** @description Array of auth mount types */
            auth_method_types?: string[];
            /** @description Array of identity entity IDs */
            identity_entity_ids?: string[];
            /** @description Array of identity group IDs */
            identity_group_ids?: string[];
            /** @description Array of Method IDs that determine what methods will be enforced */
            mfa_method_ids: string[];
        };
        MountsEnableSecretsEngineRequest: {
            /**
             * Format: map
             * @description Configuration for this mount, such as default_lease_ttl and max_lease_ttl.
             */
            config?: Record<string, never>;
            /** @description User-friendly description for this mount. */
            description?: string;
            /**
             * @description Whether to give the mount access to OpenBao's external entropy.
             * @default false
             */
            external_entropy_access: boolean;
            /**
             * @description Mark the mount as a local mount, which is not replicated and is unaffected by replication.
             * @default false
             */
            local: boolean;
            /**
             * Format: kvpairs
             * @description The options to pass into the backend. Should be a json object with string keys and values.
             */
            options?: Record<string, never>;
            /** @description Name of the plugin to mount based from the name registered in the plugin catalog. */
            plugin_name?: string;
            /** @description The semantic version of the plugin to use. */
            plugin_version?: string;
            /**
             * @description Whether to turn on seal wrapping for the mount.
             * @default false
             */
            seal_wrap: boolean;
            /** @description The type of the backend. Example: "passthrough" */
            type?: string;
        };
        MountsReadConfigurationResponse: {
            accessor?: string;
            /**
             * Format: map
             * @description Configuration for this mount, such as default_lease_ttl and max_lease_ttl.
             */
            config?: Record<string, never>;
            deprecation_status?: string;
            /** @description User-friendly description for this mount. */
            description?: string;
            external_entropy_access?: boolean;
            /**
             * @description Mark the mount as a local mount, which is not replicated and is unaffected by replication.
             * @default false
             */
            local: boolean;
            /**
             * Format: kvpairs
             * @description The options to pass into the backend. Should be a json object with string keys and values.
             */
            options?: Record<string, never>;
            /** @description The semantic version of the plugin to use. */
            plugin_version?: string;
            running_plugin_version?: string;
            running_sha256?: string;
            /**
             * @description Whether to turn on seal wrapping for the mount.
             * @default false
             */
            seal_wrap: boolean;
            /** @description The type of the backend. Example: "passthrough" */
            type?: string;
            uuid?: string;
        };
        MountsReadTuningInformationResponse: {
            allowed_managed_keys?: string[];
            /** @description A list of headers to whitelist and allow a plugin to set on responses. */
            allowed_response_headers?: string[];
            audit_non_hmac_request_keys?: string[];
            audit_non_hmac_response_keys?: string[];
            /** @description The default lease TTL for this mount. */
            default_lease_ttl?: number;
            /** @description User-friendly description for this credential backend. */
            description?: string;
            external_entropy_access?: boolean;
            force_no_cache?: boolean;
            listing_visibility?: string;
            /** @description The max lease TTL for this mount. */
            max_lease_ttl?: number;
            /**
             * Format: kvpairs
             * @description The options to pass into the backend. Should be a json object with string keys and values.
             */
            options?: Record<string, never>;
            passthrough_request_headers?: string[];
            /** @description The semantic version of the plugin to use. */
            plugin_version?: string;
            /** @description The type of token to issue (service or batch). */
            token_type?: string;
            /** Format: int64 */
            user_lockout_counter_reset_duration?: number;
            user_lockout_disable?: boolean;
            /** Format: int64 */
            user_lockout_duration?: number;
            /** Format: int64 */
            user_lockout_threshold?: number;
        };
        MountsTuneConfigurationParametersRequest: {
            allowed_managed_keys?: string[];
            /** @description A list of headers to whitelist and allow a plugin to set on responses. */
            allowed_response_headers?: string[];
            /** @description The list of keys in the request data object that will not be HMAC'ed by audit devices. */
            audit_non_hmac_request_keys?: string[];
            /** @description The list of keys in the response data object that will not be HMAC'ed by audit devices. */
            audit_non_hmac_response_keys?: string[];
            /** @description The default lease TTL for this mount. */
            default_lease_ttl?: string;
            /** @description User-friendly description for this credential backend. */
            description?: string;
            /** @description Determines the visibility of the mount in the UI-specific listing endpoint. Accepted value are 'unauth' and 'hidden', with the empty default ('') behaving like 'hidden'. */
            listing_visibility?: string;
            /** @description The max lease TTL for this mount. */
            max_lease_ttl?: string;
            /**
             * Format: kvpairs
             * @description The options to pass into the backend. Should be a json object with string keys and values.
             */
            options?: Record<string, never>;
            /** @description A list of headers to whitelist and pass from the request to the plugin. */
            passthrough_request_headers?: string[];
            /** @description The semantic version of the plugin to use. */
            plugin_version?: string;
            /** @description The type of token to issue (service or batch). */
            token_type?: string;
            /**
             * Format: map
             * @description The user lockout configuration to pass into the backend. Should be a json object with string keys and values.
             */
            user_lockout_config?: Record<string, never>;
        };
        NamespacesDeleteNamespacesPathResponse: {
            /** @description Status of the deletion operation. */
            status?: string;
        };
        NamespacesListNamespacesResponse: {
            /**
             * Format: map
             * @description Map of namespace details by path.
             */
            key_info?: Record<string, never>;
            /** @description List of namespace paths. */
            keys?: string[];
        };
        NamespacesPatchNamespacesPathResponse: {
            /**
             * Format: map
             * @description User provided key-value pairs.
             */
            custom_metadata?: Record<string, never>;
            /** @description Accessor ID of the namespace. */
            id?: string;
            /** @description Flag representing the lock status of the namespace. */
            locked?: boolean;
            /** @description Path of the namespace. */
            path?: string;
            /** @description Flag representing the taint status of the namespace. */
            tainted?: boolean;
            /** @description Internal UUID of the namespace. */
            uuid?: string;
        };
        NamespacesReadNamespacesPathResponse: {
            /**
             * Format: map
             * @description User provided key-value pairs.
             */
            custom_metadata?: Record<string, never>;
            /** @description Accessor ID of the namespace. */
            id?: string;
            /** @description Flag representing the lock status of the namespace. */
            locked?: boolean;
            /** @description Path of the namespace. */
            path?: string;
            /** @description Flag representing the taint status of the namespace. */
            tainted?: boolean;
            /** @description Internal UUID of the namespace. */
            uuid?: string;
        };
        NamespacesScanNamespacesResponse: {
            /**
             * Format: map
             * @description Map of namespace details by path.
             */
            key_info?: Record<string, never>;
            /** @description List of namespace paths. */
            keys?: string[];
        };
        NamespacesWriteNamespacesApiLockLockPathResponse: {
            /** @description Unlock key required for unlocking the namespace. */
            unlock_key?: string;
        };
        NamespacesWriteNamespacesApiLockLockRequest: {
            /** @description Path of the namespace. */
            path?: string;
        };
        NamespacesWriteNamespacesApiLockLockResponse: {
            /** @description Unlock key required for unlocking the namespace. */
            unlock_key?: string;
        };
        NamespacesWriteNamespacesApiLockUnlockPathRequest: {
            /** @description Unlock key required for unlocking the namespace */
            unlock_key: string;
        };
        NamespacesWriteNamespacesApiLockUnlockRequest: {
            /** @description Path of the namespace. */
            path?: string;
            /** @description Unlock key required for unlocking the namespace */
            unlock_key: string;
        };
        NamespacesWriteNamespacesPathRequest: {
            /**
             * Format: map
             * @description User provided key-value pairs.
             */
            custom_metadata?: Record<string, never>;
        };
        NamespacesWriteNamespacesPathResponse: {
            /**
             * Format: map
             * @description User provided key-value pairs.
             */
            custom_metadata?: Record<string, never>;
            /** @description Accessor ID of the namespace. */
            id?: string;
            /** @description Flag representing the lock status of the namespace. */
            locked?: boolean;
            /** @description Path of the namespace. */
            path?: string;
            /** @description Flag representing the taint status of the namespace. */
            tainted?: boolean;
            /** @description Internal UUID of the namespace. */
            uuid?: string;
        };
        OidcConfigureRequest: {
            /** @description Issuer URL to be used in the iss claim of the token. If not set, OpenBao's app_addr will be used. */
            issuer?: string;
        };
        OidcIntrospectRequest: {
            /** @description Optional client_id to verify */
            client_id?: string;
            /** @description Token to verify */
            token?: string;
        };
        OidcProviderAuthorizeWithParametersRequest: {
            /** @description The ID of the requesting client. */
            client_id: string;
            /** @description The code challenge derived from the code verifier. */
            code_challenge?: string;
            /**
             * @description The method that was used to derive the code challenge. The following methods are supported: 'S256', 'plain'. Defaults to 'plain'.
             * @default plain
             */
            code_challenge_method: string;
            /** @description The allowable elapsed time in seconds since the last time the end-user was actively authenticated. */
            max_age?: number;
            /** @description The value that will be returned in the ID token nonce claim after a token exchange. */
            nonce?: string;
            /** @description The redirection URI to which the response will be sent. */
            redirect_uri: string;
            /** @description The OIDC authentication flow to be used. The following response types are supported: 'code' */
            response_type: string;
            /** @description A space-delimited, case-sensitive list of scopes to be requested. The 'openid' scope is required. */
            scope: string;
            /** @description The value used to maintain state between the authentication request and client. */
            state?: string;
        };
        OidcProviderTokenRequest: {
            /** @description The ID of the requesting client. */
            client_id?: string;
            /** @description The secret of the requesting client. */
            client_secret?: string;
            /** @description The authorization code received from the provider's authorization endpoint. */
            code: string;
            /** @description The code verifier associated with the authorization code. */
            code_verifier?: string;
            /** @description The authorization grant type. The following grant types are supported: 'authorization_code'. */
            grant_type: string;
            /** @description The callback location where the authentication response was sent. */
            redirect_uri: string;
        };
        OidcRotateKeyRequest: {
            /**
             * Format: seconds
             * @description Controls how long the public portion of a key will be available for verification after being rotated. Setting verification_ttl here will override the verification_ttl set on the key.
             */
            verification_ttl?: number;
        };
        OidcWriteAssignmentRequest: {
            /** @description Comma separated string or array of identity entity IDs */
            entity_ids?: string[];
            /** @description Comma separated string or array of identity group IDs */
            group_ids?: string[];
        };
        OidcWriteClientRequest: {
            /**
             * Format: seconds
             * @description The time-to-live for access tokens obtained by the client.
             * @default 24h
             */
            access_token_ttl: number;
            /** @description Comma separated string or array of assignment resources. */
            assignments?: string[];
            /**
             * @description The client type based on its ability to maintain confidentiality of credentials. The following client types are supported: 'confidential', 'public'. Defaults to 'confidential'.
             * @default confidential
             */
            client_type: string;
            /**
             * Format: seconds
             * @description The time-to-live for ID tokens obtained by the client.
             * @default 24h
             */
            id_token_ttl: number;
            /**
             * @description A reference to a named key resource. Cannot be modified after creation. Defaults to the 'default' key.
             * @default default
             */
            key: string;
            /** @description Comma separated string or array of redirect URIs used by the client. One of these values must exactly match the redirect_uri parameter value used in each authentication request. */
            redirect_uris?: string[];
        };
        OidcWriteKeyRequest: {
            /**
             * @description Signing algorithm to use. This will default to RS256.
             * @default RS256
             */
            algorithm: string;
            /** @description Comma separated string or array of role client ids allowed to use this key for signing. If empty no roles are allowed. If "*" all roles are allowed. */
            allowed_client_ids?: string[];
            /**
             * Format: seconds
             * @description How often to generate a new keypair.
             * @default 24h
             */
            rotation_period: number;
            /**
             * Format: seconds
             * @description Controls how long the public portion of a key will be available for verification after being rotated.
             * @default 24h
             */
            verification_ttl: number;
        };
        OidcWriteProviderRequest: {
            /** @description The client IDs that are permitted to use the provider */
            allowed_client_ids?: string[];
            /** @description Specifies what will be used for the iss claim of ID tokens. */
            issuer?: string;
            /** @description The scopes supported for requesting on the provider */
            scopes_supported?: string[];
        };
        OidcWriteRoleRequest: {
            /** @description Optional client_id */
            client_id?: string;
            /** @description The OIDC key to use for generating tokens. The specified key must already exist. */
            key: string;
            /** @description The template string to use for generating tokens. This may be in string-ified JSON or base64 format. */
            template?: string;
            /**
             * Format: seconds
             * @description TTL of the tokens generated against the role.
             * @default 24h
             */
            ttl: number;
        };
        OidcWriteScopeRequest: {
            /** @description The description of the scope */
            description?: string;
            /** @description The template string to use for the scope. This may be in string-ified JSON or base64 format. */
            template?: string;
        };
        PersonaCreateRequest: {
            /** @description Entity ID to which this persona belongs to */
            entity_id?: string;
            /** @description ID of the persona */
            id?: string;
            /**
             * Format: kvpairs
             * @description Metadata to be associated with the persona. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: bao <command> <path> metadata=key1=value1 metadata=key2=value2
             */
            metadata?: Record<string, never>;
            /** @description Mount accessor to which this persona belongs to */
            mount_accessor?: string;
            /** @description Name of the persona */
            name?: string;
        };
        PersonaUpdateByIdRequest: {
            /** @description Entity ID to which this persona should be tied to */
            entity_id?: string;
            /**
             * Format: kvpairs
             * @description Metadata to be associated with the persona. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: bao <command> <path> metadata=key1=value1 metadata=key2=value2
             */
            metadata?: Record<string, never>;
            /** @description Mount accessor to which this persona belongs to */
            mount_accessor?: string;
            /** @description Name of the persona */
            name?: string;
        };
        PluginsCatalogListPluginsResponse: {
            /** Format: map */
            detailed?: Record<string, never>;
        };
        PluginsCatalogListPluginsWithTypeResponse: {
            /** @description List of plugin names in the catalog */
            keys?: string[];
        };
        PluginsCatalogReadPluginConfigurationResponse: {
            /** @description The args passed to plugin command. */
            args?: string[];
            builtin?: boolean;
            /** @description The command used to start the plugin. The executable defined in this command must exist in OpenBao's plugin directory. */
            command?: string;
            deprecation_status?: string;
            /** @description The name of the plugin */
            name?: string;
            /** @description The SHA256 sum of the executable used in the command field. This should be HEX encoded. */
            sha256?: string;
            /** @description The semantic version of the plugin to use. */
            version?: string;
        };
        PluginsCatalogReadPluginConfigurationWithTypeResponse: {
            /** @description The args passed to plugin command. */
            args?: string[];
            builtin?: boolean;
            /** @description The command used to start the plugin. The executable defined in this command must exist in OpenBao's plugin directory. */
            command?: string;
            deprecation_status?: string;
            /** @description The name of the plugin */
            name?: string;
            /** @description The SHA256 sum of the executable used in the command field. This should be HEX encoded. */
            sha256?: string;
            /** @description The semantic version of the plugin to use. */
            version?: string;
        };
        PluginsCatalogRegisterPluginRequest: {
            /** @description The args passed to plugin command. */
            args?: string[];
            /** @description The command used to start the plugin. The executable defined in this command must exist in OpenBao's plugin directory. */
            command?: string;
            /** @description The environment variables passed to plugin command. Each entry is of the form "key=value". */
            env?: string[];
            /** @description The SHA256 sum of the executable used in the command field. This should be HEX encoded. */
            sha256?: string;
            /** @description The type of the plugin, may be auth, secret, or database */
            type?: string;
            /** @description The semantic version of the plugin to use. */
            version?: string;
        };
        PluginsCatalogRegisterPluginWithTypeRequest: {
            /** @description The args passed to plugin command. */
            args?: string[];
            /** @description The command used to start the plugin. The executable defined in this command must exist in OpenBao's plugin directory. */
            command?: string;
            /** @description The environment variables passed to plugin command. Each entry is of the form "key=value". */
            env?: string[];
            /** @description The SHA256 sum of the executable used in the command field. This should be HEX encoded. */
            sha256?: string;
            /** @description The semantic version of the plugin to use. */
            version?: string;
        };
        PluginsReloadBackendsRequest: {
            /** @description The mount paths of the plugin backends to reload. */
            mounts?: string[];
            /** @description The name of the plugin to reload, as registered in the plugin catalog. */
            plugin?: string;
            scope?: string;
        };
        PluginsReloadBackendsResponse: {
            reload_id?: string;
        };
        PoliciesGeneratePasswordFromPasswordPolicyResponse: {
            password?: string;
        };
        PoliciesListAclPoliciesResponse: {
            keys?: string[];
            policies?: string[];
        };
        PoliciesListPasswordPoliciesResponse: {
            keys?: string[];
        };
        PoliciesListResponse: {
            keys?: string[];
            policies?: string[];
        };
        PoliciesReadAclPolicy2Response: {
            cas_required?: boolean;
            /** Format: date-time */
            expiration?: string;
            /** Format: date-time */
            modified?: string;
            name?: string;
            policy?: string;
            rules?: string;
            version?: number;
        };
        PoliciesReadAclPolicyResponse: {
            cas_required?: boolean;
            /** Format: date-time */
            expiration?: string;
            /** Format: date-time */
            modified?: string;
            name?: string;
            policy?: string;
            rules?: string;
            version?: number;
        };
        PoliciesReadPasswordPolicyResponse: {
            policy?: string;
        };
        PoliciesWriteAclPolicy2Request: {
            /** @description The rules of the policy. */
            cas?: number;
            /** @description The rules of the policy. */
            cas_required?: boolean;
            /**
             * Format: date-time
             * @description The rules of the policy.
             */
            expiration?: string;
            /** @description The rules of the policy. */
            policy?: string;
            /**
             * @deprecated
             * @description The rules of the policy.
             */
            rules?: string;
            /**
             * Format: seconds
             * @description The rules of the policy.
             */
            ttl?: number;
        };
        PoliciesWriteAclPolicyRequest: {
            /** @description The rules of the policy. */
            cas?: number;
            /** @description The rules of the policy. */
            cas_required?: boolean;
            /**
             * Format: date-time
             * @description The rules of the policy.
             */
            expiration?: string;
            /** @description The rules of the policy. */
            policy?: string;
            /**
             * Format: seconds
             * @description The rules of the policy.
             */
            ttl?: number;
        };
        PoliciesWritePasswordPolicyRequest: {
            /** @description The password policy */
            policy?: string;
        };
        QueryTokenAccessorCapabilitiesRequest: {
            /** @description Accessor of the token for which capabilities are being queried. */
            accessor?: string;
            /**
             * @deprecated
             * @description Use 'paths' instead.
             */
            path?: string[];
            /** @description Paths on which capabilities are being queried. */
            paths?: string[];
        };
        QueryTokenCapabilitiesRequest: {
            /**
             * @deprecated
             * @description Use 'paths' instead.
             */
            path?: string[];
            /** @description Paths on which capabilities are being queried. */
            paths?: string[];
            /** @description Token for which capabilities are being queried. */
            token?: string;
        };
        QueryTokenSelfCapabilitiesRequest: {
            /**
             * @deprecated
             * @description Use 'paths' instead.
             */
            path?: string[];
            /** @description Paths on which capabilities are being queried. */
            paths?: string[];
            /** @description Token for which capabilities are being queried. */
            token?: string;
        };
        RateLimitQuotasConfigureRequest: {
            /** @description If set, starts audit logging of requests that get rejected due to rate limit quota rule violations. */
            enable_rate_limit_audit_logging?: boolean;
            /** @description If set, additional rate limit quota HTTP headers will be added to responses. */
            enable_rate_limit_response_headers?: boolean;
            /** @description Specifies the list of exempt paths from all rate limit quotas. If empty no paths will be exempt. */
            rate_limit_exempt_paths?: string[];
        };
        RateLimitQuotasListResponse: {
            keys?: string[];
        };
        RateLimitQuotasReadConfigurationResponse: {
            enable_rate_limit_audit_logging?: boolean;
            enable_rate_limit_response_headers?: boolean;
            rate_limit_exempt_paths?: string[];
        };
        RateLimitQuotasReadResponse: {
            block_interval?: number;
            inheritable?: boolean;
            interval?: number;
            name?: string;
            path?: string;
            /** Format: float */
            rate?: number;
            role?: string;
            type?: string;
        };
        RateLimitQuotasWriteRequest: {
            /**
             * Format: seconds
             * @description If set, when a client reaches a rate limit threshold, the client will be prohibited from any further requests until after the 'block_interval' has elapsed.
             */
            block_interval?: number;
            /** @description If set to true, child namespaces will use this quota, unless another more specific quota exists. Can only be set on namespace quotas. A quota on the root namespace will by default be inheritable. */
            inheritable?: boolean;
            /**
             * Format: seconds
             * @description The duration to enforce rate limiting for (default '1s').
             */
            interval?: number;
            /** @description Path of the mount or namespace to apply the quota. A blank path configures a global quota. For example namespace1/ adds a quota to a full namespace, namespace1/auth/userpass adds a quota to userpass in namespace1. */
            path?: string;
            /**
             * Format: float
             * @description The maximum number of requests in a given interval to be allowed by the quota rule. The 'rate' must be positive.
             */
            rate?: number;
            /** @description Login role to apply this quota to. Note that when set, path must be configured to a valid auth method with a concept of roles. */
            role?: string;
            /** @description Type of the quota rule. */
            type?: string;
        };
        RawReadPathResponse: {
            value?: string;
        };
        RawReadResponse: {
            value?: string;
        };
        RawWritePathRequest: {
            /** @description Optional entry to list begin listing after, not required to exist. Only used in list operations. */
            after?: string;
            compressed?: boolean;
            compression_type?: string;
            encoding?: string;
            /** @description Optional number of entries to return; defaults to all entries. Only used in list operations. */
            limit?: number;
            value?: string;
        };
        RawWriteRequest: {
            /** @description Optional entry to list begin listing after, not required to exist. Only used in list operations. */
            after?: string;
            compressed?: boolean;
            compression_type?: string;
            encoding?: string;
            /** @description Optional number of entries to return; defaults to all entries. Only used in list operations. */
            limit?: number;
            path?: string;
            value?: string;
        };
        ReadWrappingProperties2Response: {
            creation_path?: string;
            /** Format: date-time */
            creation_time?: string;
            /** Format: seconds */
            creation_ttl?: number;
        };
        ReadWrappingPropertiesRequest: {
            token?: string;
        };
        ReadWrappingPropertiesResponse: {
            creation_path?: string;
            /** Format: date-time */
            creation_time?: string;
            /** Format: seconds */
            creation_ttl?: number;
        };
        RekeyAttemptInitializeRequest: {
            /** @description Specifies if using PGP-encrypted keys, whether OpenBao should also store a plaintext backup of the PGP-encrypted keys. */
            backup?: boolean;
            /** @description Specifies an array of PGP public keys used to encrypt the output unseal keys. Ordering is preserved. The keys must be base64-encoded from their original binary representation. The size of this array must be the same as secret_shares. */
            pgp_keys?: string[];
            /** @description Turns on verification functionality */
            require_verification?: boolean;
            /** @description Specifies the number of shares to split the unseal key into. */
            secret_shares?: number;
            /** @description Specifies the number of shares required to reconstruct the unseal key. This must be less than or equal secret_shares. If using OpenBao HSM with auto-unsealing, this value must be the same as secret_shares. */
            secret_threshold?: number;
        };
        RekeyAttemptInitializeResponse: {
            backup?: boolean;
            n?: number;
            nounce?: string;
            pgp_fingerprints?: string[];
            progress?: number;
            required?: number;
            started?: string;
            t?: number;
            verification_nonce?: string;
            verification_required?: boolean;
        };
        RekeyAttemptReadProgressResponse: {
            backup?: boolean;
            n?: number;
            nounce?: string;
            pgp_fingerprints?: string[];
            progress?: number;
            required?: number;
            started?: string;
            t?: number;
            verification_nonce?: string;
            verification_required?: boolean;
        };
        RekeyAttemptUpdateRequest: {
            /** @description Specifies a single unseal key share. */
            key?: string;
            /** @description Specifies the nonce of the rekey attempt. */
            nonce?: string;
        };
        RekeyAttemptUpdateResponse: {
            backup?: boolean;
            complete?: boolean;
            keys?: string[];
            keys_base64?: string[];
            n?: number;
            nounce?: string;
            pgp_fingerprints?: string[];
            progress?: number;
            required?: number;
            started?: string;
            t?: number;
            verification_nonce?: string;
            verification_required?: boolean;
        };
        RekeyReadBackupKeyResponse: {
            /** Format: map */
            keys?: Record<string, never>;
            /** Format: map */
            keys_base64?: Record<string, never>;
            nonce?: string;
        };
        RekeyReadBackupRecoveryKeyResponse: {
            /** Format: map */
            keys?: Record<string, never>;
            /** Format: map */
            keys_base64?: Record<string, never>;
            nonce?: string;
        };
        RekeyVerificationCancelResponse: {
            n?: number;
            nounce?: string;
            progress?: number;
            started?: string;
            t?: number;
        };
        RekeyVerificationReadProgressResponse: {
            n?: number;
            nounce?: string;
            progress?: number;
            started?: string;
            t?: number;
        };
        RekeyVerificationUpdateRequest: {
            /** @description Specifies a single unseal share key from the new set of shares. */
            key?: string;
            /** @description Specifies the nonce of the rekey verification operation. */
            nonce?: string;
        };
        RekeyVerificationUpdateResponse: {
            complete?: boolean;
            nounce?: string;
        };
        RemountRequest: {
            /** @description The previous mount point. */
            from?: string;
            /** @description The new mount point. */
            to?: string;
        };
        RemountResponse: {
            migration_id?: string;
        };
        RemountStatusResponse: {
            migration_id?: string;
            /** Format: map */
            migration_info?: Record<string, never>;
        };
        RewrapRequest: {
            token?: string;
        };
        RootTokenGenerationInitialize2Request: {
            /** @description Specifies a base64-encoded PGP public key. */
            pgp_key?: string;
        };
        RootTokenGenerationInitialize2Response: {
            complete?: boolean;
            encoded_root_token?: string;
            encoded_token?: string;
            nonce?: string;
            otp?: string;
            otp_length?: number;
            pgp_fingerprint?: string;
            progress?: number;
            required?: number;
            started?: boolean;
        };
        RootTokenGenerationInitializeRequest: {
            /** @description Specifies a base64-encoded PGP public key. */
            pgp_key?: string;
        };
        RootTokenGenerationInitializeResponse: {
            complete?: boolean;
            encoded_root_token?: string;
            encoded_token?: string;
            nonce?: string;
            otp?: string;
            otp_length?: number;
            pgp_fingerprint?: string;
            progress?: number;
            required?: number;
            started?: boolean;
        };
        RootTokenGenerationReadProgress2Response: {
            complete?: boolean;
            encoded_root_token?: string;
            encoded_token?: string;
            nonce?: string;
            otp?: string;
            otp_length?: number;
            pgp_fingerprint?: string;
            progress?: number;
            required?: number;
            started?: boolean;
        };
        RootTokenGenerationReadProgressResponse: {
            complete?: boolean;
            encoded_root_token?: string;
            encoded_token?: string;
            nonce?: string;
            otp?: string;
            otp_length?: number;
            pgp_fingerprint?: string;
            progress?: number;
            required?: number;
            started?: boolean;
        };
        RootTokenGenerationUpdateRequest: {
            /** @description Specifies a single unseal key share. */
            key?: string;
            /** @description Specifies the nonce of the attempt. */
            nonce?: string;
        };
        RootTokenGenerationUpdateResponse: {
            complete?: boolean;
            encoded_root_token?: string;
            encoded_token?: string;
            nonce?: string;
            otp?: string;
            otp_length?: number;
            pgp_fingerprint?: string;
            progress?: number;
            required?: number;
            started?: boolean;
        };
        RotateAttemptInitializeRequest: {
            /** @description Specifies if using PGP-encrypted keys, whether OpenBao should also store a plaintext backup of the said keys. */
            backup?: boolean;
            /** @description Specifies an array of PGP public keys used to encrypt the output unseal keys. */
            pgp_keys?: string[];
            /** @description Enables verification which after successful authorization with the current unseal keys, ensures the new unseal keys are returned but the root key is not actually rotated. */
            require_verification?: boolean;
            /** @description Specifies the number of shares to split the root key into. */
            secret_shares: number;
            /** @description Specifies the number of shares required to reconstruct the root key. */
            secret_threshold: number;
        };
        RotateAttemptInitializeResponse: {
            backup?: boolean;
            complete?: boolean;
            keys?: string[];
            keys_base64?: string[];
            n?: number;
            nonce?: string;
            pgp_fingerprints?: string[];
            progress?: number;
            required?: number;
            started?: boolean;
            t?: number;
            verification_nonce?: string;
            verification_required?: boolean;
        };
        RotateAttemptInitializeRotateRecoveryInitRequest: {
            /** @description Specifies if using PGP-encrypted keys, whether OpenBao should also store a plaintext backup of the said keys. */
            backup?: boolean;
            /** @description Specifies an array of PGP public keys used to encrypt the output unseal keys. */
            pgp_keys?: string[];
            /** @description Enables verification which after successful authorization with the current unseal keys, ensures the new unseal keys are returned but the root key is not actually rotated. */
            require_verification?: boolean;
            /** @description Specifies the number of shares to split the root key into. */
            secret_shares: number;
            /** @description Specifies the number of shares required to reconstruct the root key. */
            secret_threshold: number;
        };
        RotateAttemptInitializeRotateRecoveryInitResponse: {
            backup?: boolean;
            complete?: boolean;
            keys?: string[];
            keys_base64?: string[];
            n?: number;
            nonce?: string;
            pgp_fingerprints?: string[];
            progress?: number;
            required?: number;
            started?: boolean;
            t?: number;
            verification_nonce?: string;
            verification_required?: boolean;
        };
        RotateAttemptReadProgressResponse: {
            /** @description Specifies if using PGP-encrypted keys, whether OpenBao should also store a plaintext backup of the said keys. */
            backup?: boolean;
            /** @description Specifies an array of PGP public keys used to encrypt the output unseal keys. */
            pgp_keys?: string[];
            /** @description Enables verification which after successful authorization with the current unseal keys, ensures the new unseal keys are returned but the root key is not actually rotated. */
            require_verification?: boolean;
            /** @description Specifies the number of shares to split the root key into. */
            secret_shares?: number;
            /** @description Specifies the number of shares required to reconstruct the root key. */
            secret_threshold?: number;
        };
        RotateAttemptReadRotateRecoveryInitResponse: {
            /** @description Specifies if using PGP-encrypted keys, whether OpenBao should also store a plaintext backup of the said keys. */
            backup?: boolean;
            /** @description Specifies an array of PGP public keys used to encrypt the output unseal keys. */
            pgp_keys?: string[];
            /** @description Enables verification which after successful authorization with the current unseal keys, ensures the new unseal keys are returned but the root key is not actually rotated. */
            require_verification?: boolean;
            /** @description Specifies the number of shares to split the root key into. */
            secret_shares?: number;
            /** @description Specifies the number of shares required to reconstruct the root key. */
            secret_threshold?: number;
        };
        RotateAttemptUpdateRequest: {
            /** @description Specifies a single unseal key share. */
            key?: string;
            /** @description Specifies the nonce of the rotation attempt. */
            nonce?: string;
        };
        RotateAttemptUpdateResponse: {
            backup?: boolean;
            complete?: boolean;
            keys?: string[];
            keys_base64?: string[];
            n?: number;
            nonce?: string;
            pgp_fingerprints?: string[];
            progress?: number;
            required?: number;
            started?: boolean;
            t?: number;
            verification_nonce?: string;
            verification_required?: boolean;
        };
        RotateAttemptUpdateRotateRecoveryUpdateRequest: {
            /** @description Specifies a single unseal key share. */
            key?: string;
            /** @description Specifies the nonce of the rotation attempt. */
            nonce?: string;
        };
        RotateAttemptUpdateRotateRecoveryUpdateResponse: {
            backup?: boolean;
            complete?: boolean;
            keys?: string[];
            keys_base64?: string[];
            n?: number;
            nonce?: string;
            pgp_fingerprints?: string[];
            progress?: number;
            required?: number;
            started?: boolean;
            t?: number;
            verification_nonce?: string;
            verification_required?: boolean;
        };
        RotateReadBackupKeyResponse: {
            keys?: string[];
            keys_base64?: string[];
            nonce?: string;
        };
        RotateReadRotateRecoveryBackupResponse: {
            keys?: string[];
            keys_base64?: string[];
            nonce?: string;
        };
        RotateVerificationCancelResponse: {
            n?: number;
            nonce?: string;
            progress?: number;
            started?: boolean;
            t?: number;
        };
        RotateVerificationCancelRotateRecoveryVerifyResponse: {
            n?: number;
            nonce?: string;
            progress?: number;
            started?: boolean;
            t?: number;
        };
        RotateVerificationReadProgressResponse: {
            n?: number;
            nonce?: string;
            progress?: number;
            started?: boolean;
            t?: number;
        };
        RotateVerificationReadRotateRecoveryVerifyResponse: {
            n?: number;
            nonce?: string;
            progress?: number;
            started?: boolean;
            t?: number;
        };
        RotateVerificationUpdateRequest: {
            /** @description Specifies a single unseal share key from the new set of shares. */
            key?: string;
            /** @description Specifies the nonce of the rotation verification operation. */
            nonce?: string;
        };
        RotateVerificationUpdateResponse: {
            complete?: boolean;
            nonce?: string;
        };
        RotateVerificationUpdateRotateRecoveryVerifyRequest: {
            /** @description Specifies a single unseal share key from the new set of shares. */
            key?: string;
            /** @description Specifies the nonce of the rotation verification operation. */
            nonce?: string;
        };
        RotateVerificationUpdateRotateRecoveryVerifyResponse: {
            complete?: boolean;
            nonce?: string;
        };
        SealStatusResponse: {
            build_date?: string;
            cluster_id?: string;
            cluster_name?: string;
            initialized?: boolean;
            migration?: boolean;
            n?: number;
            nonce?: string;
            progress?: number;
            recovery_seal?: boolean;
            sealed?: boolean;
            storage_type?: string;
            t?: number;
            type?: string;
            version?: string;
        };
        TokenCreateAgainstRoleRequest: {
            /** @description Name to associate with this token */
            display_name?: string;
            /** @description Name of the entity alias to associate with this token */
            entity_alias?: string;
            /** @description Explicit Max TTL of this token */
            explicit_max_ttl?: string;
            /** @description Value for the token */
            id?: string;
            /**
             * @deprecated
             * @description Use 'ttl' instead
             */
            lease?: string;
            /**
             * Format: kvpairs
             * @description Arbitrary key=value metadata to associate with the token
             */
            meta?: Record<string, never>;
            /** @description Do not include default policy for this token */
            no_default_policy?: boolean;
            /** @description Create the token with no parent */
            no_parent?: boolean;
            /** @description Max number of uses for this token */
            num_uses?: number;
            /** @description Renew period */
            period?: string;
            /** @description List of policies for the token */
            policies?: string[];
            /**
             * @description Allow token to be renewed past its initial TTL up to system/mount maximum TTL
             * @default true
             */
            renewable: boolean;
            /** @description Time to live for this token */
            ttl?: string;
            /** @description Token type */
            type?: string;
        };
        TokenCreateOrphanRequest: {
            /** @description Name to associate with this token */
            display_name?: string;
            /** @description Name of the entity alias to associate with this token */
            entity_alias?: string;
            /** @description Explicit Max TTL of this token */
            explicit_max_ttl?: string;
            /** @description Value for the token */
            id?: string;
            /**
             * @deprecated
             * @description Use 'ttl' instead
             */
            lease?: string;
            /**
             * Format: kvpairs
             * @description Arbitrary key=value metadata to associate with the token
             */
            meta?: Record<string, never>;
            /** @description Do not include default policy for this token */
            no_default_policy?: boolean;
            /** @description Create the token with no parent */
            no_parent?: boolean;
            /** @description Max number of uses for this token */
            num_uses?: number;
            /** @description Renew period */
            period?: string;
            /** @description List of policies for the token */
            policies?: string[];
            /**
             * @description Allow token to be renewed past its initial TTL up to system/mount maximum TTL
             * @default true
             */
            renewable: boolean;
            /** @description Time to live for this token */
            ttl?: string;
            /** @description Token type */
            type?: string;
        };
        TokenCreateRequest: {
            /** @description Name to associate with this token */
            display_name?: string;
            /** @description Name of the entity alias to associate with this token */
            entity_alias?: string;
            /** @description Explicit Max TTL of this token */
            explicit_max_ttl?: string;
            /** @description Value for the token */
            id?: string;
            /**
             * @deprecated
             * @description Use 'ttl' instead
             */
            lease?: string;
            /**
             * Format: kvpairs
             * @description Arbitrary key=value metadata to associate with the token
             */
            meta?: Record<string, never>;
            /** @description Do not include default policy for this token */
            no_default_policy?: boolean;
            /** @description Create the token with no parent */
            no_parent?: boolean;
            /** @description Max number of uses for this token */
            num_uses?: number;
            /** @description Renew period */
            period?: string;
            /** @description List of policies for the token */
            policies?: string[];
            /**
             * @description Allow token to be renewed past its initial TTL up to system/mount maximum TTL
             * @default true
             */
            renewable: boolean;
            /** @description Time to live for this token */
            ttl?: string;
            /** @description Token type */
            type?: string;
        };
        TokenLookUpAccessorRequest: {
            /** @description Accessor of the token to look up (request body) */
            accessor?: string;
        };
        TokenLookUpRequest: {
            /** @description Token to lookup (POST request body) */
            token?: string;
        };
        TokenLookUpSelf2Request: {
            /** @description Token to look up (unused, does not need to be set) */
            token?: string;
        };
        TokenRenewAccessorRequest: {
            /** @description Accessor of the token to renew (request body) */
            accessor?: string;
            /**
             * Format: seconds
             * @description The desired increment in seconds to the token expiration
             * @default 0
             */
            increment: number;
        };
        TokenRenewRequest: {
            /**
             * Format: seconds
             * @description The desired increment in seconds to the token expiration
             * @default 0
             */
            increment: number;
            /** @description Token to renew (request body) */
            token?: string;
        };
        TokenRenewSelfRequest: {
            /**
             * Format: seconds
             * @description The desired increment in seconds to the token expiration
             * @default 0
             */
            increment: number;
            /** @description Token to renew (unused, does not need to be set) */
            token?: string;
        };
        TokenRevokeAccessorRequest: {
            /** @description Accessor of the token (request body) */
            accessor?: string;
        };
        TokenRevokeOrphanRequest: {
            /** @description Token to revoke (request body) */
            token?: string;
        };
        TokenRevokeRequest: {
            /** @description Token to revoke (request body) */
            token?: string;
        };
        TokenWriteRoleRequest: {
            /** @description String or JSON list of allowed entity aliases. If set, specifies the entity aliases which are allowed to be used during token generation. This field supports globbing. */
            allowed_entity_aliases?: string[];
            /** @description If set, tokens can be created with any subset of the policies in this list, rather than the normal semantics of tokens being a subset of the calling token's policies. The parameter is a comma-delimited string of policy names. */
            allowed_policies?: string[];
            /** @description If set, tokens can be created with any subset of glob matched policies in this list, rather than the normal semantics of tokens being a subset of the calling token's policies. The parameter is a comma-delimited string of policy name globs. */
            allowed_policies_glob?: string[];
            /**
             * @deprecated
             * @description Use 'token_bound_cidrs' instead.
             */
            bound_cidrs?: string[];
            /** @description If set, successful token creation via this role will require that no policies in the given list are requested. The parameter is a comma-delimited string of policy names. */
            disallowed_policies?: string[];
            /** @description If set, successful token creation via this role will require that no requested policies glob match any of policies in this list. The parameter is a comma-delimited string of policy name globs. */
            disallowed_policies_glob?: string[];
            /**
             * Format: seconds
             * @deprecated
             * @description Use 'token_explicit_max_ttl' instead.
             */
            explicit_max_ttl?: number;
            /** @description If true, tokens created via this role will be orphan tokens (have no parent) */
            orphan?: boolean;
            /** @description If set, tokens created via this role will contain the given suffix as a part of their path. This can be used to assist use of the 'revoke-prefix' endpoint later on. The given suffix must match the regular expression.\w[\w-.]+\w */
            path_suffix?: string;
            /**
             * Format: seconds
             * @deprecated
             * @description Use 'token_period' instead.
             */
            period?: number;
            /**
             * @description Tokens created via this role will be renewable or not according to this value. Defaults to "true".
             * @default true
             */
            renewable: boolean;
            /** @description Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token. */
            token_bound_cidrs?: string[];
            /**
             * Format: seconds
             * @description If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.
             */
            token_explicit_max_ttl?: number;
            /** @description If true, the 'default' policy will not automatically be added to generated tokens */
            token_no_default_policy?: boolean;
            /** @description The maximum number of times a token may be used, a value of zero means unlimited */
            token_num_uses?: number;
            /**
             * Format: seconds
             * @description If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. "24h").
             */
            token_period?: number;
            /**
             * @description The type of token to generate, service or batch
             * @default default-service
             */
            token_type: string;
        };
        UiHeadersConfigureRequest: {
            /** @description Returns multiple values if true */
            multivalue?: boolean;
            /** @description The values to set the header. */
            values?: string[];
        };
        UiHeadersListResponse: {
            /** @description Lists of configured UI headers. Omitted if list is empty */
            keys?: string[];
        };
        UiHeadersReadConfigurationResponse: {
            /** @description returns the first header value when `multivalue` request parameter is false */
            value?: string;
            /** @description returns all header values when `multivalue` request parameter is true */
            values?: string[];
        };
        UnsealRequest: {
            /** @description Specifies a single unseal key share. This is required unless reset is true. */
            key?: string;
            /** @description Specifies if previously-provided unseal keys are discarded and the unseal process is reset. */
            reset?: boolean;
        };
        UnsealResponse: {
            build_date?: string;
            cluster_id?: string;
            cluster_name?: string;
            initialized?: boolean;
            migration?: boolean;
            n?: number;
            nonce?: string;
            progress?: number;
            recovery_seal?: boolean;
            sealed?: boolean;
            storage_type?: string;
            t?: number;
            type?: string;
            version?: string;
        };
        UnwrapRequest: {
            token?: string;
        };
        VersionHistoryResponse: {
            /** Format: kvpairs */
            key_info?: Record<string, never>;
            keys?: string[];
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    "token-list-accessors": {
        parameters: {
            query: {
                /** @description Must be set to `true` */
                list: "true";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "token-create": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["TokenCreateRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "token-create-orphan": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["TokenCreateOrphanRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "token-create-against-role": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the role */
                role_name: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["TokenCreateAgainstRoleRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "token-look-up-2": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "token-look-up": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["TokenLookUpRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "token-look-up-accessor": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["TokenLookUpAccessorRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "token-look-up-self": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "token-look-up-self2": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["TokenLookUpSelf2Request"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "token-renew": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["TokenRenewRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "token-renew-accessor": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["TokenRenewAccessorRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "token-renew-self": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["TokenRenewSelfRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "token-revoke": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["TokenRevokeRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "token-revoke-accessor": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["TokenRevokeAccessorRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "token-revoke-orphan": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["TokenRevokeOrphanRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "token-revoke-self": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "token-list-roles": {
        parameters: {
            query: {
                /** @description Must be set to `true` */
                list: "true";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "token-read-role": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the role */
                role_name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "token-write-role": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the role */
                role_name: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["TokenWriteRoleRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "token-delete-role": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the role */
                role_name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description empty body */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "token-tidy": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "cubbyhole-read": {
        parameters: {
            query?: {
                /** @description Return a list if `true` */
                list?: string;
            };
            header?: never;
            path: {
                /** @description Specifies the path of the secret. */
                path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "cubbyhole-write": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Specifies the path of the secret. */
                path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "cubbyhole-delete": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Specifies the path of the secret. */
                path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description empty body */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "alias-create": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AliasCreateRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "alias-list-by-id": {
        parameters: {
            query: {
                /** @description Must be set to `true` */
                list: "true";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "alias-read-by-id": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the alias */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "alias-update-by-id": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the alias */
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AliasUpdateByIdRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "alias-delete-by-id": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the alias */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description empty body */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "entity-create": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EntityCreateRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "entity-create-alias": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EntityCreateAliasRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "entity-list-aliases-by-id": {
        parameters: {
            query: {
                /** @description Must be set to `true` */
                list: "true";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "entity-read-alias-by-id": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the alias */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "entity-update-alias-by-id": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the alias */
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EntityUpdateAliasByIdRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "entity-delete-alias-by-id": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the alias */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description empty body */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "entity-batch-delete": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EntityBatchDeleteRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "entity-list-by-id": {
        parameters: {
            query: {
                /** @description Must be set to `true` */
                list: "true";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "entity-read-by-id": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the entity. If set, updates the corresponding existing entity. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "entity-update-by-id": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the entity. If set, updates the corresponding existing entity. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EntityUpdateByIdRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "entity-delete-by-id": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the entity. If set, updates the corresponding existing entity. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description empty body */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "entity-merge": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EntityMergeRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "entity-list-by-name": {
        parameters: {
            query: {
                /** @description Must be set to `true` */
                list: "true";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "entity-read-by-name": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the entity */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "entity-update-by-name": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the entity */
                name: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EntityUpdateByNameRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "entity-delete-by-name": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the entity */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description empty body */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "group-create": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GroupCreateRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "group-create-alias": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GroupCreateAliasRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "group-list-aliases-by-id": {
        parameters: {
            query: {
                /** @description Must be set to `true` */
                list: "true";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "group-read-alias-by-id": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the group alias. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "group-update-alias-by-id": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the group alias. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GroupUpdateAliasByIdRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "group-delete-alias-by-id": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the group alias. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description empty body */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "group-list-by-id": {
        parameters: {
            query: {
                /** @description Must be set to `true` */
                list: "true";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "group-read-by-id": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the group. If set, updates the corresponding existing group. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "group-update-by-id": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the group. If set, updates the corresponding existing group. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GroupUpdateByIdRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "group-delete-by-id": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the group. If set, updates the corresponding existing group. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description empty body */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "group-list-by-name": {
        parameters: {
            query: {
                /** @description Must be set to `true` */
                list: "true";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "group-read-by-name": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the group. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "group-update-by-name": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the group. */
                name: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GroupUpdateByNameRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "group-delete-by-name": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the group. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description empty body */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "entity-look-up": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EntityLookUpRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "group-look-up": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GroupLookUpRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "mfa-list-login-enforcements": {
        parameters: {
            query: {
                /** @description Must be set to `true` */
                list: "true";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "mfa-read-login-enforcement": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name for this login enforcement configuration */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "mfa-write-login-enforcement": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name for this login enforcement configuration */
                name: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MfaWriteLoginEnforcementRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "mfa-delete-login-enforcement": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name for this login enforcement configuration */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description empty body */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "mfa-list-methods": {
        parameters: {
            query: {
                /** @description Must be set to `true` */
                list: "true";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "mfa-list-duo-methods": {
        parameters: {
            query: {
                /** @description Must be set to `true` */
                list: "true";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "mfa-read-duo-method-configuration": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier for this MFA method. */
                method_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "mfa-configure-duo-method": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier for this MFA method. */
                method_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MfaConfigureDuoMethodRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "mfa-delete-duo-method": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier for this MFA method. */
                method_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description empty body */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "mfa-list-okta-methods": {
        parameters: {
            query: {
                /** @description Must be set to `true` */
                list: "true";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "mfa-read-okta-method-configuration": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier for this MFA method. */
                method_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "mfa-configure-okta-method": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier for this MFA method. */
                method_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MfaConfigureOktaMethodRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "mfa-delete-okta-method": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier for this MFA method. */
                method_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description empty body */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "mfa-list-ping-id-methods": {
        parameters: {
            query: {
                /** @description Must be set to `true` */
                list: "true";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "mfa-read-ping-id-method-configuration": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier for this MFA method. */
                method_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "mfa-configure-ping-id-method": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier for this MFA method. */
                method_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MfaConfigurePingIdMethodRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "mfa-delete-ping-id-method": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier for this MFA method. */
                method_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description empty body */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "mfa-list-totp-methods": {
        parameters: {
            query: {
                /** @description Must be set to `true` */
                list: "true";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "mfa-admin-destroy-totp-secret": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MfaAdminDestroyTotpSecretRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "mfa-admin-generate-totp-secret": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MfaAdminGenerateTotpSecretRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "mfa-generate-totp-secret": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MfaGenerateTotpSecretRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "mfa-read-totp-method-configuration": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier for this MFA method. */
                method_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "mfa-configure-totp-method": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier for this MFA method. */
                method_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MfaConfigureTotpMethodRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "mfa-delete-totp-method": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier for this MFA method. */
                method_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description empty body */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "mfa-read-method-configuration": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier for this MFA method. */
                method_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-read-public-keys": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-read-open-id-configuration": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-list-assignments": {
        parameters: {
            query: {
                /** @description Must be set to `true` */
                list: "true";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-read-assignment": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the assignment */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-write-assignment": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the assignment */
                name: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["OidcWriteAssignmentRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-delete-assignment": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the assignment */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description empty body */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-list-clients": {
        parameters: {
            query: {
                /** @description Must be set to `true` */
                list: "true";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-read-client": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the client. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-write-client": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the client. */
                name: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["OidcWriteClientRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-delete-client": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the client. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description empty body */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-read-configuration": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-configure": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["OidcConfigureRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-introspect": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["OidcIntrospectRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-list-keys": {
        parameters: {
            query: {
                /** @description Must be set to `true` */
                list: "true";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-read-key": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the key */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-write-key": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the key */
                name: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["OidcWriteKeyRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-delete-key": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the key */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description empty body */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-rotate-key": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the key */
                name: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["OidcRotateKeyRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-list-providers": {
        parameters: {
            query: {
                /** @description Filters the list of OIDC providers to those that allow the given client ID in their set of allowed_client_ids. */
                allowed_client_id?: string;
                /** @description Must be set to `true` */
                list: "true";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-read-provider": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the provider */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-write-provider": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the provider */
                name: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["OidcWriteProviderRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-delete-provider": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the provider */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description empty body */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-read-provider-public-keys": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the provider */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-read-provider-open-id-configuration": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the provider */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-provider-authorize": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the provider */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-provider-authorize-with-parameters": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the provider */
                name: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["OidcProviderAuthorizeWithParametersRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-provider-token": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the provider */
                name: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["OidcProviderTokenRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-provider-user-info": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the provider */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-provider-user-info2": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the provider */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-list-roles": {
        parameters: {
            query: {
                /** @description Must be set to `true` */
                list: "true";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-read-role": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the role */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-write-role": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the role */
                name: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["OidcWriteRoleRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-delete-role": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the role */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description empty body */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-list-scopes": {
        parameters: {
            query: {
                /** @description Must be set to `true` */
                list: "true";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-read-scope": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the scope */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-write-scope": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the scope */
                name: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["OidcWriteScopeRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-delete-scope": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the scope */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description empty body */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "oidc-generate-token": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the role */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "persona-create": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PersonaCreateRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "persona-list-by-id": {
        parameters: {
            query: {
                /** @description Must be set to `true` */
                list: "true";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "persona-read-by-id": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the persona */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "persona-update-by-id": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the persona */
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PersonaUpdateByIdRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "persona-delete-by-id": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the persona */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description empty body */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "auditing-list-enabled-devices": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "auditing-calculate-hash": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the backend. Cannot be delimited. Example: "mysql" */
                path: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AuditingCalculateHashRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuditingCalculateHashResponse"];
                };
            };
        };
    };
    "auditing-enable-device": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the backend. Cannot be delimited. Example: "mysql" */
                path: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AuditingEnableDeviceRequest"];
            };
        };
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "auditing-disable-device": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the backend. Cannot be delimited. Example: "mysql" */
                path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "auth-list-enabled-methods": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "auth-read-configuration": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The path to mount to. Cannot be delimited. Example: "user" */
                path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthReadConfigurationResponse"];
                };
            };
        };
    };
    "auth-enable-method": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The path to mount to. Cannot be delimited. Example: "user" */
                path: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AuthEnableMethodRequest"];
            };
        };
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "auth-disable-method": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The path to mount to. Cannot be delimited. Example: "user" */
                path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "auth-read-tuning-information": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Tune the configuration parameters for an auth path. */
                path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthReadTuningInformationResponse"];
                };
            };
        };
    };
    "auth-tune-configuration-parameters": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Tune the configuration parameters for an auth path. */
                path: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AuthTuneConfigurationParametersRequest"];
            };
        };
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "query-token-capabilities": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["QueryTokenCapabilitiesRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "query-token-accessor-capabilities": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["QueryTokenAccessorCapabilitiesRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "query-token-self-capabilities": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["QueryTokenSelfCapabilitiesRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "auditing-list-request-headers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuditingListRequestHeadersResponse"];
                };
            };
        };
    };
    "auditing-read-request-header-information": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                header: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "auditing-enable-request-header": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                header: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AuditingEnableRequestHeaderRequest"];
            };
        };
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "auditing-disable-request-header": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                header: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "cors-read-configuration": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CorsReadConfigurationResponse"];
                };
            };
        };
    };
    "cors-configure": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CorsConfigureRequest"];
            };
        };
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "cors-delete-configuration": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "reload-subsystem": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                subsystem: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "read-sanitized-configuration-state": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "ui-headers-list": {
        parameters: {
            query: {
                /** @description Must be set to `true` */
                list: "true";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UiHeadersListResponse"];
                };
            };
        };
    };
    "ui-headers-read-configuration": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the header. */
                header: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UiHeadersReadConfigurationResponse"];
                };
            };
        };
    };
    "ui-headers-configure": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the header. */
                header: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UiHeadersConfigureRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "ui-headers-delete-configuration": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the header. */
                header: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    decode: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["DecodeRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "root-token-generation-read-progress2": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RootTokenGenerationReadProgress2Response"];
                };
            };
        };
    };
    "root-token-generation-initialize-2": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RootTokenGenerationInitialize2Request"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RootTokenGenerationInitialize2Response"];
                };
            };
        };
    };
    "root-token-generation-cancel-2": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "root-token-generation-read-progress": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RootTokenGenerationReadProgressResponse"];
                };
            };
        };
    };
    "root-token-generation-initialize": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RootTokenGenerationInitializeRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RootTokenGenerationInitializeResponse"];
                };
            };
        };
    };
    "root-token-generation-cancel": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "root-token-generation-update": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RootTokenGenerationUpdateRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RootTokenGenerationUpdateResponse"];
                };
            };
        };
    };
    "ha-status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HaStatusResponse"];
                };
            };
        };
    };
    "read-health-status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description initialized, unsealed, and active */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description unsealed and standby */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description data recovery mode replication secondary and active */
            472: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description not initialized */
            501: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description sealed */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "collect-host-information": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CollectHostInformationResponse"];
                };
            };
        };
    };
    "collect-in-flight-request-information": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "read-initialization-status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "initialize-system": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["InitializeSystemRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "internal-count-entities": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["InternalCountEntitiesResponse"];
                };
            };
        };
    };
    "internal-count-requests": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "internal-count-tokens": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["InternalCountTokensResponse"];
                };
            };
        };
    };
    "internal-inspect-request": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "internal-inspect-router": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of subtree being observed */
                tag: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "internal-generate-open-api-document": {
        parameters: {
            query?: {
                /** @description Use generic mount paths */
                generic_mount_paths?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "internal-generate-open-api-document-with-parameters": {
        parameters: {
            query?: {
                /** @description Use generic mount paths */
                generic_mount_paths?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["InternalGenerateOpenApiDocumentWithParametersRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "internal-ui-list-enabled-feature-flags": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["InternalUiListEnabledFeatureFlagsResponse"];
                };
            };
        };
    };
    "internal-ui-list-enabled-visible-mounts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["InternalUiListEnabledVisibleMountsResponse"];
                };
            };
        };
    };
    "internal-ui-read-mount-information": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The path of the mount. */
                path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["InternalUiReadMountInformationResponse"];
                };
            };
        };
    };
    "internal-ui-list-namespaces": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["InternalUiListNamespacesResponse"];
                };
            };
        };
    };
    "internal-ui-read-resultant-acl": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["InternalUiReadResultantAclResponse"];
                };
            };
            /** @description empty response returned if no client token */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "encryption-key-status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "leader-status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LeaderStatusResponse"];
                };
            };
        };
    };
    "leases-list": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LeasesListResponse"];
                };
            };
        };
    };
    "leases-count": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LeasesCountResponse"];
                };
            };
        };
    };
    "leases-read-lease": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LeasesReadLeaseRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LeasesReadLeaseResponse"];
                };
            };
        };
    };
    "leases-look-up": {
        parameters: {
            query: {
                /** @description Must be set to `true` */
                list: "true";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LeasesLookUpResponse"];
                };
            };
        };
    };
    "leases-look-up-with-prefix": {
        parameters: {
            query: {
                /** @description Must be set to `true` */
                list: "true";
            };
            header?: never;
            path: {
                /** @description The path to list leases under. Example: "aws/creds/deploy" */
                prefix: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LeasesLookUpWithPrefixResponse"];
                };
            };
        };
    };
    "leases-renew-lease": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LeasesRenewLeaseRequest"];
            };
        };
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "leases-renew-lease-with-id": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The lease identifier to renew. This is included with a lease. */
                url_lease_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LeasesRenewLeaseWithIdRequest"];
            };
        };
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "leases-revoke-lease": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LeasesRevokeLeaseRequest"];
            };
        };
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "leases-force-revoke-lease-with-prefix": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The path to revoke keys under. Example: "prod/aws/ops" */
                prefix: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "leases-revoke-lease-with-prefix": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The path to revoke keys under. Example: "prod/aws/ops" */
                prefix: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LeasesRevokeLeaseWithPrefixRequest"];
            };
        };
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "leases-revoke-lease-with-id": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The lease identifier to renew. This is included with a lease. */
                url_lease_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LeasesRevokeLeaseWithIdRequest"];
            };
        };
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "leases-tidy": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "locked-users-list": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "locked-users-unlock": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description It is the name of the alias (user). For example, if the alias belongs to userpass backend, the name should be a valid username within userpass auth method. If the alias belongs to an approle auth method, the name should be a valid RoleID */
                alias_identifier: string;
                /** @description MountAccessor is the identifier of the mount entry to which the user belongs */
                mount_accessor: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "loggers-read-verbosity-level": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "loggers-update-verbosity-level": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LoggersUpdateVerbosityLevelRequest"];
            };
        };
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "loggers-revert-verbosity-level": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "loggers-read-verbosity-level-for": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the logger to be modified. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "loggers-update-verbosity-level-for": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the logger to be modified. */
                name: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LoggersUpdateVerbosityLevelForRequest"];
            };
        };
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "loggers-revert-verbosity-level-for": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the logger to be modified. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    metrics: {
        parameters: {
            query?: {
                /** @description Format to export metrics into. Currently accepts only "prometheus". */
                format?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "mfa-validate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MfaValidateRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    monitor: {
        parameters: {
            query?: {
                /** @description Output format of logs. Supported values are "standard" and "json". The default is "standard". */
                log_format?: string;
                /** @description Log level to view system logs at. Currently supported values are "trace", "debug", "info", "warn", "error". */
                log_level?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "mounts-list-secrets-engines": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "mounts-read-configuration": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The path to mount to. Example: "aws/east" */
                path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MountsReadConfigurationResponse"];
                };
            };
        };
    };
    "mounts-enable-secrets-engine": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The path to mount to. Example: "aws/east" */
                path: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MountsEnableSecretsEngineRequest"];
            };
        };
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "mounts-disable-secrets-engine": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The path to mount to. Example: "aws/east" */
                path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "mounts-read-tuning-information": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The path to mount to. Example: "aws/east" */
                path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MountsReadTuningInformationResponse"];
                };
            };
        };
    };
    "mounts-tune-configuration-parameters": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The path to mount to. Example: "aws/east" */
                path: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MountsTuneConfigurationParametersRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "namespaces-list-namespaces": {
        parameters: {
            query: {
                /** @description Must be set to `true` */
                list: "true";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NamespacesListNamespacesResponse"];
                };
            };
        };
    };
    "namespaces-write-namespaces-api-lock-lock": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NamespacesWriteNamespacesApiLockLockRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NamespacesWriteNamespacesApiLockLockResponse"];
                };
            };
        };
    };
    "namespaces-write-namespaces-api-lock-lock-path": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Path of the namespace. */
                path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NamespacesWriteNamespacesApiLockLockPathResponse"];
                };
            };
        };
    };
    "namespaces-write-namespaces-api-lock-unlock": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NamespacesWriteNamespacesApiLockUnlockRequest"];
            };
        };
        responses: {
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "namespaces-write-namespaces-api-lock-unlock-path": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Path of the namespace. */
                path: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NamespacesWriteNamespacesApiLockUnlockPathRequest"];
            };
        };
        responses: {
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "namespaces-read-namespaces-path": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Path of the namespace. */
                path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NamespacesReadNamespacesPathResponse"];
                };
            };
        };
    };
    "namespaces-write-namespaces-path": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Path of the namespace. */
                path: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NamespacesWriteNamespacesPathRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NamespacesWriteNamespacesPathResponse"];
                };
            };
        };
    };
    "namespaces-delete-namespaces-path": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Path of the namespace. */
                path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NamespacesDeleteNamespacesPathResponse"];
                };
            };
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "plugins-catalog-list-plugins": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PluginsCatalogListPluginsResponse"];
                };
            };
        };
    };
    "plugins-catalog-read-plugin-configuration": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the plugin */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PluginsCatalogReadPluginConfigurationResponse"];
                };
            };
        };
    };
    "plugins-catalog-register-plugin": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the plugin */
                name: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PluginsCatalogRegisterPluginRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "plugins-catalog-remove-plugin": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the plugin */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "plugins-catalog-list-plugins-with-type": {
        parameters: {
            query: {
                /** @description Must be set to `true` */
                list: "true";
            };
            header?: never;
            path: {
                /** @description The type of the plugin, may be auth, secret, or database */
                type: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PluginsCatalogListPluginsWithTypeResponse"];
                };
            };
        };
    };
    "plugins-catalog-read-plugin-configuration-with-type": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the plugin */
                name: string;
                /** @description The type of the plugin, may be auth, secret, or database */
                type: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PluginsCatalogReadPluginConfigurationWithTypeResponse"];
                };
            };
        };
    };
    "plugins-catalog-register-plugin-with-type": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the plugin */
                name: string;
                /** @description The type of the plugin, may be auth, secret, or database */
                type: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PluginsCatalogRegisterPluginWithTypeRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "plugins-catalog-remove-plugin-with-type": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the plugin */
                name: string;
                /** @description The type of the plugin, may be auth, secret, or database */
                type: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "plugins-reload-backends": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PluginsReloadBackendsRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PluginsReloadBackendsResponse"];
                };
            };
            /** @description OK */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PluginsReloadBackendsResponse"];
                };
            };
        };
    };
    "policies-list-acl-policies": {
        parameters: {
            query: {
                /** @description Must be set to `true` */
                list: "true";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PoliciesListAclPoliciesResponse"];
                };
            };
        };
    };
    "policies-read-acl-policy": {
        parameters: {
            query?: {
                /** @description Return a list if `true` */
                list?: string;
            };
            header?: never;
            path: {
                /** @description The name of the policy. Example: "ops" */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PoliciesReadAclPolicyResponse"];
                };
            };
        };
    };
    "policies-write-acl-policy": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the policy. Example: "ops" */
                name: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PoliciesWriteAclPolicyRequest"];
            };
        };
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "policies-delete-acl-policy": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the policy. Example: "ops" */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "system-list-policies-detailed-acl": {
        parameters: {
            query: {
                /** @description Must be set to `true` */
                list: "true";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "policies-list-password-policies": {
        parameters: {
            query: {
                /** @description Must be set to `true` */
                list: "true";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PoliciesListPasswordPoliciesResponse"];
                };
            };
        };
    };
    "policies-read-password-policy": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the password policy. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PoliciesReadPasswordPolicyResponse"];
                };
            };
        };
    };
    "policies-write-password-policy": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the password policy. */
                name: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PoliciesWritePasswordPolicyRequest"];
            };
        };
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "policies-delete-password-policy": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the password policy. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "policies-generate-password-from-password-policy": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the password policy. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PoliciesGeneratePasswordFromPasswordPolicyResponse"];
                };
            };
        };
    };
    "policies-list": {
        parameters: {
            query?: {
                /** @description Return a list if `true` */
                list?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PoliciesListResponse"];
                };
            };
        };
    };
    "policies-read-acl-policy2": {
        parameters: {
            query?: {
                /** @description Return a list if `true` */
                list?: string;
            };
            header?: never;
            path: {
                /** @description The name of the policy. Example: "ops" */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PoliciesReadAclPolicy2Response"];
                };
            };
        };
    };
    "policies-write-acl-policy2": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the policy. Example: "ops" */
                name: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PoliciesWriteAclPolicy2Request"];
            };
        };
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "policies-delete-acl-policy2": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the policy. Example: "ops" */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "pprof-index": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "pprof-memory-allocations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "pprof-blocking": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "pprof-command-line": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "pprof-goroutines": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "pprof-memory-allocations-live": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "pprof-mutexes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "pprof-cpu-profile": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "pprof-symbols": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "pprof-thread-creations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "pprof-execution-trace": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "rate-limit-quotas-read-configuration": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RateLimitQuotasReadConfigurationResponse"];
                };
            };
        };
    };
    "rate-limit-quotas-configure": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RateLimitQuotasConfigureRequest"];
            };
        };
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "rate-limit-quotas-list": {
        parameters: {
            query: {
                /** @description Must be set to `true` */
                list: "true";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RateLimitQuotasListResponse"];
                };
            };
        };
    };
    "rate-limit-quotas-read": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the quota rule. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RateLimitQuotasReadResponse"];
                };
            };
        };
    };
    "rate-limit-quotas-write": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the quota rule. */
                name: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RateLimitQuotasWriteRequest"];
            };
        };
        responses: {
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "rate-limit-quotas-delete": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the quota rule. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "raw-read": {
        parameters: {
            query?: {
                /** @description Return a list if `true` */
                list?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RawReadResponse"];
                };
            };
        };
    };
    "raw-write": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RawWriteRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "raw-delete": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "raw-read-path": {
        parameters: {
            query?: {
                /** @description Return a list if `true` */
                list?: string;
            };
            header?: never;
            path: {
                path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RawReadPathResponse"];
                };
            };
        };
    };
    "raw-write-path": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                path: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RawWritePathRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "raw-delete-path": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "rekey-read-backup-key": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RekeyReadBackupKeyResponse"];
                };
            };
        };
    };
    "rekey-delete-backup-key": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "rekey-attempt-read-progress": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RekeyAttemptReadProgressResponse"];
                };
            };
        };
    };
    "rekey-attempt-initialize": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RekeyAttemptInitializeRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RekeyAttemptInitializeResponse"];
                };
            };
        };
    };
    "rekey-attempt-cancel": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "rekey-read-backup-recovery-key": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RekeyReadBackupRecoveryKeyResponse"];
                };
            };
        };
    };
    "rekey-delete-backup-recovery-key": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "rekey-attempt-update": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RekeyAttemptUpdateRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RekeyAttemptUpdateResponse"];
                };
            };
        };
    };
    "rekey-verification-read-progress": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RekeyVerificationReadProgressResponse"];
                };
            };
        };
    };
    "rekey-verification-update": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RekeyVerificationUpdateRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RekeyVerificationUpdateResponse"];
                };
            };
        };
    };
    "rekey-verification-cancel": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RekeyVerificationCancelResponse"];
                };
            };
        };
    };
    remount: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RemountRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RemountResponse"];
                };
            };
        };
    };
    "remount-status": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the migration operation */
                migration_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RemountStatusResponse"];
                };
            };
        };
    };
    "leases-renew-lease2": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LeasesRenewLease2Request"];
            };
        };
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "leases-renew-lease-with-id2": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The lease identifier to renew. This is included with a lease. */
                url_lease_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LeasesRenewLeaseWithId2Request"];
            };
        };
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "leases-revoke-lease2": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LeasesRevokeLease2Request"];
            };
        };
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "leases-force-revoke-lease-with-prefix2": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The path to revoke keys under. Example: "prod/aws/ops" */
                prefix: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "leases-revoke-lease-with-prefix2": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The path to revoke keys under. Example: "prod/aws/ops" */
                prefix: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LeasesRevokeLeaseWithPrefix2Request"];
            };
        };
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "leases-revoke-lease-with-id2": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The lease identifier to renew. This is included with a lease. */
                url_lease_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LeasesRevokeLeaseWithId2Request"];
            };
        };
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "encryption-key-rotate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "encryption-key-read-rotation-configuration": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EncryptionKeyReadRotationConfigurationResponse"];
                };
            };
        };
    };
    "encryption-key-configure-rotation-configuration": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EncryptionKeyConfigureRotationConfigurationRequest"];
            };
        };
        responses: {
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "encryption-key-rotate-rotate-keyring": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "encryption-key-read-rotate-keyring-config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EncryptionKeyReadRotateKeyringConfigResponse"];
                };
            };
        };
    };
    "encryption-key-configure-rotate-keyring-config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EncryptionKeyConfigureRotateKeyringConfigRequest"];
            };
        };
        responses: {
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "rotate-read-rotate-recovery-backup": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RotateReadRotateRecoveryBackupResponse"];
                };
            };
        };
    };
    "rotate-delete-rotate-recovery-backup": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "rotate-attempt-read-rotate-recovery-init": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RotateAttemptReadRotateRecoveryInitResponse"];
                };
            };
        };
    };
    "rotate-attempt-initialize-rotate-recovery-init": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RotateAttemptInitializeRotateRecoveryInitRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RotateAttemptInitializeRotateRecoveryInitResponse"];
                };
            };
        };
    };
    "rotate-attempt-cancel-rotate-recovery-init": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "rotate-attempt-update-rotate-recovery-update": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RotateAttemptUpdateRotateRecoveryUpdateRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RotateAttemptUpdateRotateRecoveryUpdateResponse"];
                };
            };
        };
    };
    "rotate-verification-read-rotate-recovery-verify": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RotateVerificationReadRotateRecoveryVerifyResponse"];
                };
            };
        };
    };
    "rotate-verification-update-rotate-recovery-verify": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RotateVerificationUpdateRotateRecoveryVerifyRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RotateVerificationUpdateRotateRecoveryVerifyResponse"];
                };
            };
        };
    };
    "rotate-verification-cancel-rotate-recovery-verify": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RotateVerificationCancelRotateRecoveryVerifyResponse"];
                };
            };
        };
    };
    "root-key-rotate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "rotate-read-backup-key": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RotateReadBackupKeyResponse"];
                };
            };
        };
    };
    "rotate-delete-backup-key": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "rotate-attempt-read-progress": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RotateAttemptReadProgressResponse"];
                };
            };
        };
    };
    "rotate-attempt-initialize": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RotateAttemptInitializeRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RotateAttemptInitializeResponse"];
                };
            };
        };
    };
    "rotate-attempt-cancel": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "rotate-attempt-update": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RotateAttemptUpdateRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RotateAttemptUpdateResponse"];
                };
            };
        };
    };
    "rotate-verification-read-progress": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RotateVerificationReadProgressResponse"];
                };
            };
        };
    };
    "rotate-verification-update": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RotateVerificationUpdateRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RotateVerificationUpdateResponse"];
                };
            };
        };
    };
    "rotate-verification-cancel": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RotateVerificationCancelResponse"];
                };
            };
        };
    };
    seal: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "seal-status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SealStatusResponse"];
                };
            };
        };
    };
    "step-down-leader": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description empty body */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "generate-hash": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GenerateHashRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GenerateHashResponse"];
                };
            };
        };
    };
    "generate-hash-with-algorithm": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Algorithm to use (POST URL parameter) */
                urlalgorithm: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GenerateHashWithAlgorithmRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GenerateHashWithAlgorithmResponse"];
                };
            };
        };
    };
    "generate-random": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GenerateRandomRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GenerateRandomResponse"];
                };
            };
        };
    };
    "generate-random-with-source": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Which system to source random data from, ether "platform", "seal", or "all". */
                source: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GenerateRandomWithSourceRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GenerateRandomWithSourceResponse"];
                };
            };
        };
    };
    "generate-random-with-source-and-bytes": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Which system to source random data from, ether "platform", "seal", or "all". */
                source: string;
                /** @description The number of bytes to generate (POST URL parameter) */
                urlbytes: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GenerateRandomWithSourceAndBytesRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GenerateRandomWithSourceAndBytesResponse"];
                };
            };
        };
    };
    "generate-random-with-bytes": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The number of bytes to generate (POST URL parameter) */
                urlbytes: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GenerateRandomWithBytesRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GenerateRandomWithBytesResponse"];
                };
            };
        };
    };
    unseal: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UnsealRequest"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UnsealResponse"];
                };
            };
        };
    };
    "version-history": {
        parameters: {
            query: {
                /** @description Must be set to `true` */
                list: "true";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["VersionHistoryResponse"];
                };
            };
        };
    };
    "read-wrapping-properties2": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ReadWrappingProperties2Response"];
                };
            };
        };
    };
    "read-wrapping-properties": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ReadWrappingPropertiesRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ReadWrappingPropertiesResponse"];
                };
            };
        };
    };
    rewrap: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RewrapRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    unwrap: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UnwrapRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    wrap: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "kv-read-config": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Path that the backend was mounted at */
                secret_mount_path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "kv-write-config": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Path that the backend was mounted at */
                secret_mount_path: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["KvWriteConfigRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "kv-read-data-path": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Location of the secret. */
                path: string;
                /** @description Path that the backend was mounted at */
                secret_mount_path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "kv-write-data-path": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Location of the secret. */
                path: string;
                /** @description Path that the backend was mounted at */
                secret_mount_path: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["KvWriteDataPathRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "kv-delete-data-path": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Location of the secret. */
                path: string;
                /** @description Path that the backend was mounted at */
                secret_mount_path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description empty body */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "kv-write-delete-path": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Location of the secret. */
                path: string;
                /** @description Path that the backend was mounted at */
                secret_mount_path: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["KvWriteDeletePathRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "kv-write-destroy-path": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Location of the secret. */
                path: string;
                /** @description Path that the backend was mounted at */
                secret_mount_path: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["KvWriteDestroyPathRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "kv-list-detailed-metadata-path": {
        parameters: {
            query: {
                /** @description Must be set to `true` */
                list: "true";
            };
            header?: never;
            path: {
                /** @description Location of the secret. */
                path: string;
                /** @description Path that the backend was mounted at */
                secret_mount_path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "kv-read-metadata-path": {
        parameters: {
            query?: {
                /** @description Return a list if `true` */
                list?: string;
            };
            header?: never;
            path: {
                /** @description Location of the secret. */
                path: string;
                /** @description Path that the backend was mounted at */
                secret_mount_path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "kv-write-metadata-path": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Location of the secret. */
                path: string;
                /** @description Path that the backend was mounted at */
                secret_mount_path: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["KvWriteMetadataPathRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "kv-delete-metadata-path": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Location of the secret. */
                path: string;
                /** @description Path that the backend was mounted at */
                secret_mount_path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description empty body */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "kv-read-subkeys-path": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Location of the secret. */
                path: string;
                /** @description Path that the backend was mounted at */
                secret_mount_path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "kv-write-undelete-path": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Location of the secret. */
                path: string;
                /** @description Path that the backend was mounted at */
                secret_mount_path: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["KvWriteUndeletePathRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
}
